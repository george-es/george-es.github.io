<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>React 之核心概念</title>
    <url>/2022/05/08/frontEnd/react%E4%B9%8B%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<p>123</p>
<span id="more"></span>

<blockquote>
<p>文章中统一用 <code>JS</code> 表示 <code>JavaScript</code></p>
</blockquote>
<h2 id="JSX-简介"><a href="#JSX-简介" class="headerlink" title="JSX 简介"></a>JSX 简介</h2><h3 id="什么是-JSX"><a href="#什么是-JSX" class="headerlink" title="什么是 JSX"></a>什么是 JSX</h3><p><code>JSX</code> 是一个 <code>JS</code> 的语法扩展。它可以很好地描述 <code>UI</code> 应该呈现出它应有交互的本质形式。</p>
<h3 id="为什么使用-JSX"><a href="#为什么使用-JSX" class="headerlink" title="为什么使用 JSX"></a>为什么使用 JSX</h3><ul>
<li><code>React</code> 认为渲染逻辑本质上与其他 <code>UI</code> 逻辑内在耦合</li>
<li><code>React</code> 并没有采用将标记与逻辑进行分离到不同文件这种人为地分离方式，而是通过将二者共同存放在称之为“组件”的松散耦合单元之中，来实现关注点分离。</li>
</ul>
<h3 id="JSX-中嵌套表达式"><a href="#JSX-中嵌套表达式" class="headerlink" title="JSX 中嵌套表达式"></a>JSX 中嵌套表达式</h3><p>在 <code>JSX</code> 语法中，你可以在大括号内放置任何有效的 <code>JS</code> 表达式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const name = &#x27;george&#x27;</span><br><span class="line">const el = &lt;div&gt;&#123;name&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure>



<h3 id="JSX-也是一个表达式"><a href="#JSX-也是一个表达式" class="headerlink" title="JSX 也是一个表达式"></a>JSX 也是一个表达式</h3><p>编译之后，<code>JSX</code>  表达式会被转为普通 <code>JS</code> 函数调用，并且对其取值后得到 <code>JS</code> 对象。</p>
<p>也就是说，可以将 <code>JSX</code> 赋值给变量，把 <code>JSX</code> 当作参数传入，以及从函数中返回 <code>JSX</code>。</p>
<h3 id="JSX-特定属性"><a href="#JSX-特定属性" class="headerlink" title="JSX 特定属性"></a>JSX 特定属性</h3><p>在 <code>JSX</code> 中可以使用引号来指定字符串（<code>string</code>）类型，也可以使用大括号在属性值中插入一个 <code>JS</code> 表达式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const el = &lt;img src=&#x27;http://www.george.com&#x27; /&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const url = &#x27;http://www.george.com&#x27;</span><br><span class="line">const el = &lt;img src=&#123;url&#125; /&gt;</span><br></pre></td></tr></table></figure>



<h3 id="JSX-防止注入攻击"><a href="#JSX-防止注入攻击" class="headerlink" title="JSX 防止注入攻击"></a>JSX 防止注入攻击</h3><p><code>React DOM</code> 在渲染所有输入内容之前，默认会进行转义，它可以确保你的应用中，永远不会注入那些并非自己明确编写的内容。所有的内容在渲染之前都被转换成了字符串，这样可以有效防止 <code>XSS(跨站脚本)</code>攻击。</p>
<h3 id="JSX-表示对象"><a href="#JSX-表示对象" class="headerlink" title="JSX 表示对象"></a>JSX 表示对象</h3><p><code>Babel</code> 会把 <code>JSX</code> 转译成一名为 <code>React.createElement()</code> 函数调用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const el = (</span><br><span class="line">	&lt;div className=&#x27;greeting&#x27;&gt;</span><br><span class="line">		Hello world!</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 被塞入 createElement 后</span><br><span class="line">const el = React.createElement(</span><br><span class="line">	&#x27;h1&#x27;,</span><br><span class="line">	&#123;className: &#x27;greeting&#x27;&#125;,</span><br><span class="line">	&#x27;Hello world!&#x27;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>最后会被转换成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const el = &#123;</span><br><span class="line">	type: &#x27;h1&#x27;,</span><br><span class="line">	props: &#123;</span><br><span class="line">		className: &#x27;greeting&#x27;,</span><br><span class="line">		children: &#x27;Hello world!&#x27;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="元素渲染"><a href="#元素渲染" class="headerlink" title="元素渲染"></a>元素渲染</h2><h3 id="什么是元素渲染"><a href="#什么是元素渲染" class="headerlink" title="什么是元素渲染"></a>什么是元素渲染</h3><p>元素是构成 <code>React</code> 应用的最小砖块，它描述了你在屏幕上想看到的内容。</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const el = &lt;div&gt;Hello world!&lt;/div&gt;</span><br></pre></td></tr></table></figure>



<h3 id="将一个元素渲染为-DOM"><a href="#将一个元素渲染为-DOM" class="headerlink" title="将一个元素渲染为 DOM"></a>将一个元素渲染为 DOM</h3><p>通过 <code>ReactDOM.createRoot()</code> 可以将一个 <code>React</code> 元素渲染到根 <code>DOM</code> 节点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&#x27;root&#x27; /&gt;</span><br><span class="line">const root = ReactDOM.createRoot(document.getElementById(&#x27;root&#x27;))</span><br><span class="line">root.render()</span><br></pre></td></tr></table></figure>



<h3 id="更新已渲染的元素"><a href="#更新已渲染的元素" class="headerlink" title="更新已渲染的元素"></a>更新已渲染的元素</h3><p><code>React</code> 元素是不可变对象。一旦被创建，你就无法更改它的子元素或属性。</p>
<h3 id="React-只更新它需要更新的部分"><a href="#React-只更新它需要更新的部分" class="headerlink" title="React 只更新它需要更新的部分"></a>React 只更新它需要更新的部分</h3><p><code>React DOM</code> 会将元素和它的子元素与她们之前的状态进行比较，只会进行局部更新。</p>
<h2 id="组件-amp-Props"><a href="#组件-amp-Props" class="headerlink" title="组件 &amp; Props"></a>组件 &amp; Props</h2><p>组件允许你将 <code>UI</code> 拆分为独立可复用的代码片段，并对每个片段进行独立构思。</p>
<h3 id="函数组件与-class-组件"><a href="#函数组件与-class-组件" class="headerlink" title="函数组件与 class 组件"></a>函数组件与 class 组件</h3><p>定义组件最简单的方式就是编写 JS 函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Hi() &#123;</span><br><span class="line">	return &lt;h1&gt;Hello&lt;/h1&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数是一个有效的 <code>React</code> 组件，因为它接收唯一带有数据的 <code>props</code> 对象并返回一个<code>React</code> 元素。这类组件被称为“函数组件”，因为它本质上就是 <code>javascript</code> 函数。</p>
<h3 id="渲染组件"><a href="#渲染组件" class="headerlink" title="渲染组件"></a>渲染组件</h3><p><code>React</code> 既可是 <code>DOM</code> 标签，也可是用户自定义组件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// DOM 标签</span><br><span class="line">const el = &lt;div /&gt;</span><br><span class="line"></span><br><span class="line">// 自定义组件</span><br><span class="line">const el = &lt;Hi name=&#x27;george&#x27; /&gt;</span><br></pre></td></tr></table></figure>

<p>当 <code>React</code> 元素为用户自定义组件时，它会将 <code>JSX</code> 所接收的属性，以及子组件，转换为单个对象传递给组件，这个对象称之为 <code>props</code>。</p>
<h3 id="组合组件"><a href="#组合组件" class="headerlink" title="组合组件"></a>组合组件</h3><p>组件可以在其输出中引用其他组件，这就可以让我们用同一组件抽象出任意层次的细节。</p>
<p>通常来说，每个新的 <code>React</code> 应用程序的顶层组件都是 <code>App</code> 组件.</p>
<h3 id="提取组件"><a href="#提取组件" class="headerlink" title="提取组件"></a>提取组件</h3><p>将组件拆分为更小的组件。虽然提取组件是一件繁重的工作，但是在大型应用中，构建可复用组件库是完全值得的。</p>
<p>根据经验来看，如果 <code>UI</code> 中有一部分被多次使用，或者组件本身就足够复杂，那么它就是一个可复用组件的候选项。</p>
<h3 id="Props-的只读性"><a href="#Props-的只读性" class="headerlink" title="Props 的只读性"></a>Props 的只读性</h3><p>组件无论是函数组件还是类（<code>class</code>）组件，都不能修改自身的 <code>props</code>。</p>
<p><code>React</code> 虽然非常灵活，但它有个严格的规则：<strong>所有 React 组件都必须像纯函数一样保护它们的 props 不被更改</strong>。</p>
<h2 id="State-amp-生命周期"><a href="#State-amp-生命周期" class="headerlink" title="State &amp; 生命周期"></a>State &amp; 生命周期</h2><h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><p><code>state</code> 可以理解为组件内部维护的状态。和 <code>props</code> 很相似，只不过 <code>props</code> 是改变不了的，<code>state</code> 可以被改变。</p>
<h3 id="State-的更新可能是异步的"><a href="#State-的更新可能是异步的" class="headerlink" title="State 的更新可能是异步的"></a>State 的更新可能是异步的</h3><p>出于性能考虑，<code>React</code> 可能会把多个 <code>setState</code> 调用合并成一个调用。<strong>因为 <code>this.props</code> 和 <code>this.state</code> 可能会异步更新，所以你不要依赖他们的值来更新下一个状态。</strong></p>
<p>要解决 <code>setState</code> 异步问题，可以让 <code>setState</code> 接收一个函数而不是一个对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this.setState((state, props) =&gt; (&#123;</span><br><span class="line">	test: state.test + props.test</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure>



<h3 id="State-的更新会被合并"><a href="#State-的更新会被合并" class="headerlink" title="State 的更新会被合并"></a>State 的更新会被合并</h3><p>当你调用 <code>setState</code> 的时候，<code>React</code> 会把你提供的对象合并到当前的 <code>state</code>。</p>
<p>这是 <code>state</code> 中的数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">constructor(props) &#123;</span><br><span class="line">	super(props)</span><br><span class="line">	this.state = &#123;</span><br><span class="line">		test1:[],</span><br><span class="line">		test2:[],</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>单独更新 <code>test1</code>，并不会影响 <code>test2</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this.setState(&#123;</span><br><span class="line">	test1:[1, 2, 3]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>你可以理解为 <code>setState</code> 实际上是执行了 <code>Object.assign(原始 data, 更新 data)</code> 操作</p>
<h3 id="数据是向下流动的"><a href="#数据是向下流动的" class="headerlink" title="数据是向下流动的"></a>数据是向下流动的</h3><p>不管是父组件或是子组件都无法知道某个组件是有状态还是无状态的，并且它们也并不关心它是函数组件还是 <code>class</code> 组件。</p>
<p>这就是为什么称 <code>state</code> 为局部的或是封装的的原因。除了拥有并设置了它的组件，其他组件都无法访问。</p>
<h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><ul>
<li><p><code>React</code> 事件的命名采用小驼峰式（<code>camelCase</code>），而不是纯小写 </p>
</li>
<li><p>使用 <code>JSX</code> 语法时你需要传入一个函数作为事件处理函数，而不是一个字符串</p>
</li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>没有目的的旅行</title>
    <url>/2022/05/04/pages/%E6%B2%A1%E6%9C%89%E7%9B%AE%E7%9A%84%E7%9A%84%E6%97%85%E8%A1%8C/</url>
    <content><![CDATA[<p>故事开始前，想问问，在场的所有人，有多少人经历过一场没有目的的旅行，就是那种我不知道要去哪里，也不知道要干什么，只知道在路上，享受其中的过程。<br>加了两天班，没什么出行计划，醒来后一个想法冒出来，为啥旅行要有目的，一个包，装上几件衣服，说走就走。<br>没有目的，自然也不会走错路，也就不用导航，只知道向着太阳升起的方向走，没有了时间的紧迫感，一路上，能让则让，遇上堵车，也不会像以前一样变的烦躁，肚子饿了就去找吃的，困了就小歇一下，躺在草地上，望着天空，感叹这世界之大，我们之小，让旅行的意义从对远方具象的期待，变成了身边近处的风景。<br>或许不知道从什么时候开始，我们的生活被一个个目标所捆绑，上小学，老师告诉我们要以100分为目标，高考时，我们要以985、211为目标，工作时，我们要以全球前100企业为目标，这种思维定式，无形的渗透到了我们的生活中，仿佛失去了目标，就失去了生活的意义。沿途的风景变的不再令我们陶醉，我们憧憬的，是那些远方的风景。<br>于是乎大家在出门前，都会下意识的做攻略，仿佛要做到不虚此行，到了景区发现人满为患，心情直接down到了谷底，遇到了下雨天，又会焦躁不安，回到酒店反问自己，这趟旅行，来了个寂寞。<br>没有目的的旅行，最大的挑战，不是路上发生的一切，而是自己，在此过程中你会经历其他过程中完全不会经历的剧烈的情绪起伏，在最初可能是剧烈的欢乐，新鲜感，惊奇，到后面可能是剧烈的孤独，无助，迷茫，安全感缺失，但无论发生什么情况，你都依旧要保持乐观。这种不确定性，就好比恋爱时，你完全不知道女朋友何时，为啥事会生气，但只要生气了，你再不开心也要先保持乐观去陪伴她。<br>没有目的的旅行，才是人生的常态，一开始那个问题，其实大家都有经历过，从呱呱坠地那一刻，上帝就赋予我们拥有在任意环境中，创造属于自己的天地的能力，越长大，这种能力消失的越快，你们可能会好奇，这能力到底是什么？它就是少年感，永远年轻，永远热泪盈眶，永远相信梦想。<br>最后，我开到了一个海边，看着潮起潮落，浪花一次次的拍打在礁石上，突然好像懂了杨绛先生说的那句话：“我们曾经如此渴望命运的波澜，到最后才发现，人生最曼妙的风景，竟是内心淡定和从容。”<br>旅行，不止于此，故事，也不“只”于此。</p>
]]></content>
      <categories>
        <category>碎碎念</category>
      </categories>
      <tags>
        <tag>碎碎念</tag>
      </tags>
  </entry>
  <entry>
    <title>nestjs 之数据库操作</title>
    <url>/2022/03/21/rearEnd/nestjs%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<blockquote>
<p>后端大概率是绕不开数据库的，这里记录在后端学习过程中的数据库操作</p>
</blockquote>
<span id="more"></span>

<h2 id="对数据库的理解"><a href="#对数据库的理解" class="headerlink" title="对数据库的理解"></a>对数据库的理解</h2><p>数据库，顾名思义是用来存储数据的，它有自己的语句，对于开发者而言，很多语言都提供了 <code>typeorm</code> 库来实现对数据库的操作，这些库封装了数据库语句，简化了开发成本，对于简单的操控，可以用库提供的方法实现，对于复杂的操作，还是需要用数据库语句的。</p>
<h2 id="mysql-的安装和基本操作"><a href="#mysql-的安装和基本操作" class="headerlink" title="mysql 的安装和基本操作"></a>mysql 的安装和基本操作</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install --save @nestjs/typeorm typeorm mysql</span><br></pre></td></tr></table></figure>



<h3 id="mysql配置文件"><a href="#mysql配置文件" class="headerlink" title="mysql配置文件"></a>mysql配置文件</h3><p>这里介绍两种配置方法</p>
<h4 id="通过-json-文件配置"><a href="#通过-json-文件配置" class="headerlink" title="通过 json 文件配置"></a>通过 json 文件配置</h4><p>在根目录下创建一个 <code>ormconfig.json</code> 文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	type: &#x27;mysql&#x27;,</span><br><span class="line">	host: &#x27;127.0.0.1&#x27;,</span><br><span class="line">	port: &#x27;3306&#x27;,</span><br><span class="line">	username: &#x27;root&#x27;,</span><br><span class="line">  password: &#x27;12345678&#x27;,</span><br><span class="line">  database: &#x27;test&#x27;,</span><br><span class="line">	migrations: [&#x27;migration/*.ts&#x27;],</span><br><span class="line">	timezone: &#x27;UTC&#x27;,</span><br><span class="line">	charset: &#x27;uft8mb4&#x27;,</span><br><span class="line">	multipleStatements: true,</span><br><span class="line">	dropSchema: false,</span><br><span class="line">	synchronize: true, // 是否自动将实体类同步到数据库</span><br><span class="line">	logging: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>app.module.ts</code> 文件中使用数据库配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; Module &#125; from &#x27;@nestjs/common&#x27;</span><br><span class="line">// 引入数据库配置文件</span><br><span class="line">import &#123; TypeOrmModule, TypeOrmModuleOptions &#125; from &#x27;@nestjs/typeorm&#x27;</span><br><span class="line"></span><br><span class="line">@Module(&#123;</span><br><span class="line">	import: [</span><br><span class="line">		TypeOrmModule.forRoot(), // 数据库的</span><br><span class="line">	]</span><br><span class="line">&#125;)</span><br><span class="line">export class AppModule &#123;&#125;</span><br></pre></td></tr></table></figure>



<h4 id="直接在-forRoot-中配置"><a href="#直接在-forRoot-中配置" class="headerlink" title="直接在 forRoot 中配置"></a>直接在 forRoot 中配置</h4><p>当然你还有另外一种方法去配置数据库文件，将配置数据写在 <code>TypeOrmModule.forRoot()</code>里</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; Module &#125; from &#x27;@nestjs/common&#x27;;</span><br><span class="line">import &#123; TypeOrmModule &#125; from &#x27;@nestjs/typeorm&#x27;;</span><br><span class="line">import &#123; AppController &#125; from &#x27;./app.controller&#x27;;</span><br><span class="line">import &#123; AppService &#125; from &#x27;./app.service&#x27;;</span><br><span class="line"></span><br><span class="line">@Module(&#123;</span><br><span class="line">  imports: [</span><br><span class="line">    TypeOrmModule.forRoot(&#123;</span><br><span class="line">      type: &#x27;mysql&#x27;,</span><br><span class="line">      host: &#x27;127.0.0.1&#x27;,</span><br><span class="line">      port: 3306,</span><br><span class="line">      username: &#x27;root&#x27;,</span><br><span class="line">      password: &#x27;12345678&#x27;,</span><br><span class="line">      database: &#x27;test&#x27;,</span><br><span class="line">      // entities: [&#x27;dist/**/*.entity&#123;.ts,.js&#125;&#x27;], </span><br><span class="line">      autoLoadEntities: true,</span><br><span class="line">      synchronize: true,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  controllers: [AppController],</span><br><span class="line">  providers: [AppService],</span><br><span class="line">&#125;)</span><br><span class="line">export class AppModule &#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>TypeOrmModule.forRoot()</code> 是干嘛的呢？它提供了所有的配置参数给 <code>TypeORM</code> 包的<code>createConnection</code> 方法</p>
<p>基本属性</p>
<ul>
<li><p>type：数据库类型</p>
</li>
<li><p>host：数据库 <code>ip</code> 地址</p>
</li>
<li><p>port：端口</p>
</li>
<li><p>username：登录名</p>
</li>
<li><p>password：密码</p>
</li>
<li><p>database：数据库名称</p>
</li>
<li><p>entities：扫描本项目中 <code>.entity.ts</code> 或者 <code>.entity.js</code> 的文件</p>
</li>
<li><p>synchronize：定义数据库表结构与实体类字段同步（这里一旦数据库少了字段就会自动加入，根据需要来使用）</p>
</li>
<li><p>timezone：时区（+08：00）表示东八区</p>
</li>
<li><p>retryAttempts：默认10，尝试连接数据库的次数</p>
</li>
<li><p>retryDelay：默认3000，尝试连接数据库延迟时间</p>
</li>
<li><p>autoLoadEntities：默认false，如果为true，entities将会被自动加载</p>
</li>
<li><p>keepConnectionAlive：默认false，如果为true，连接在应用被关闭时不会关闭</p>
</li>
</ul>
<p><strong>在连接数据库的时候，我们配置了synchronize: true这个属性，我们的实体就能与数据表进行对应。即只要我们创建了实体之后，哪怕我们不去创建数据表，当项目启动时候，数据库也会自动生成对应的数据表。</strong></p>
<h3 id="构建表"><a href="#构建表" class="headerlink" title="构建表"></a>构建表</h3><p><code>mysql</code> 数据库中的表好比一个个 <code>excel</code>，我们可以通过 <code>DBeaver</code> 数据库工具在里面手动创建，也可以通过代码去创建。</p>
<p><code>typeorm</code> 提供配置<strong>实体</strong>的方式去创建表，那么什么是实体呢？</p>
<blockquote>
<p>实体是一个映射到数据库表的类，你可以通过定义一个新类来创建一个实体，并用 @Entity() 来标记。</p>
</blockquote>
<p>也就是说，实体就是一张数据表，在 <code>typeorm</code> 中我们不需要对数据库的表使用相关工具进行创建与关联，而只需要创建一个实体，并将实体中的数据内容设置好，项目启动后，就会自动生成对应的表，并且将表与表直接的关系给创建好。</p>
<p>新建一个目录叫 <code>entities</code> 用于存放实体</p>
<p><code>./entities/user.entity.ts</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; Column, Entity, PrimaryGeneratedColumn, BaseEntity &#125; from &#x27;typeorm&#x27;</span><br><span class="line"></span><br><span class="line">/* 表结构 */</span><br><span class="line">@Entity()</span><br><span class="line">export class User entends BaseEntity &#123;</span><br><span class="line">	@PrimaryGeneratedColumn() // 每个实体必须至少有一个主列</span><br><span class="line">	id: number;</span><br><span class="line">	</span><br><span class="line">	@Column(&#x27;text&#x27;, &#123; name: &#x27;name&#x27;/*这里对应是数据库中字段*/ &#125;) // 通过 Column 创建列</span><br><span class="line">	name: string; // 接口返回给客户端字段</span><br><span class="line">	</span><br><span class="line">	@Column(&#x27;int&#x27;, &#123; name: &#x27;age&#x27; &#125;)</span><br><span class="line">	age: number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在数据库中我们就可以看到</p>
<p><img src="/2022/03/21/rearEnd/nestjs%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/image-20220319170502140.png" alt="image-20220319170502140"></p>
<p>一个 <code>User</code> 类名称对应一张名叫 <code>user</code> 的表名称，它的数据类型，字段名，是否为 <code>null</code>，默认值，都可以在实体 <code>@Column</code> 装饰器进行配置。</p>
<p>更多信息参考如下：</p>
<ul>
<li><p><a href="https://typeorm.biunav.com/zh/entities.html#%E5%AE%9E%E4%BD%93%E5%88%97">主列@PrimaryGeneratedColumn()</a></p>
</li>
<li><p><a href="https://typeorm.biunav.com/zh/entities.html#%E5%88%97%E9%80%89%E9%A1%B9">@Column()</a></p>
</li>
</ul>
<h3 id="注册实体类"><a href="#注册实体类" class="headerlink" title="注册实体类"></a>注册实体类</h3><p>配置完实体还要注册才能使用</p>
<p><code>user.module.ts</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; TypeOrmModule &#125; from &#x27;@nestjs/typeorm&#x27;</span><br><span class="line">import &#123; User &#125; from &#x27;./entities/user.entity.ts&#x27;</span><br><span class="line">@Module(&#123;</span><br><span class="line">	imports: [TypeOrmModule.forFeature([User])</span><br><span class="line">&#125;)</span><br><span class="line">export class UserModule &#123;&#125;</span><br></pre></td></tr></table></figure>



<h3 id="实体注入服务层"><a href="#实体注入服务层" class="headerlink" title="实体注入服务层"></a>实体注入服务层</h3><p>将实体注入服务层（<code>service</code>）后，就可以在服务层调用 <code>Repository</code> 提供的方法，来操作数据库了</p>
<p><code>user.service.ts</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; Repository &#125; from &#x27;typeorm&#x27;</span><br><span class="line">import &#123; InjectRepository &#125; from &#x27;@nestjs/typeorm&#x27;</span><br><span class="line">import &#123; UserEntity &#125; from &#x27;./entities/user.entity&#x27;</span><br><span class="line"></span><br><span class="line">export class UserService &#123;</span><br><span class="line">	constructor (</span><br><span class="line">		@InjectRepository(UserEntity)</span><br><span class="line">		private readonly userRepository: Repository&lt;UserEntity&gt;,</span><br><span class="line">	)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h3><h4 id="增"><a href="#增" class="headerlink" title="增"></a>增</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; Repository &#125; from &#x27;typeorm&#x27;</span><br><span class="line">import &#123; InjectRepository &#125; from &#x27;@nestjs/typeorm&#x27;</span><br><span class="line">import &#123; UserEntity &#125; from &#x27;./entities/user.entity&#x27;</span><br><span class="line"></span><br><span class="line">export class UserService &#123;</span><br><span class="line">	constructor (</span><br><span class="line">		@InjectRepository(UserEntity)</span><br><span class="line">		private readonly userRepository: Repository&lt;UserEntity&gt;,</span><br><span class="line">	)&#123;&#125;</span><br><span class="line">	async create(data: UserEntity): Promise&lt;string&gt; &#123;</span><br><span class="line">		const isSuccess = await this.userRepository.insert(data)</span><br><span class="line">		if (isSuccess) &#123;</span><br><span class="line">			return &#x27;新增成功&#x27;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			return &#x27;新增失败&#x27;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="删"><a href="#删" class="headerlink" title="删"></a>删</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; Repository &#125; from &#x27;typeorm&#x27;</span><br><span class="line">import &#123; InjectRepository &#125; from &#x27;@nestjs/typeorm&#x27;</span><br><span class="line">import &#123; UserEntity &#125; from &#x27;./entities/user.entity&#x27;</span><br><span class="line"></span><br><span class="line">export class UserService &#123;</span><br><span class="line">	constructor (</span><br><span class="line">		@InjectRepository(UserEntity)</span><br><span class="line">		private readonly userRepository: Repository&lt;UserEntity&gt;,</span><br><span class="line">	)&#123;&#125;</span><br><span class="line">	async remove(id: number): Promise&lt;void&gt; &#123;</span><br><span class="line">		await this.userRepository.delete(id)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="改"><a href="#改" class="headerlink" title="改"></a>改</h4><h4 id="查"><a href="#查" class="headerlink" title="查"></a>查</h4><p>查找有两种方式，一种是通过 <code>Repository</code> 提供的方法查找，简单快捷</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; Repository &#125; from &#x27;typeorm&#x27;</span><br><span class="line">import &#123; InjectRepository &#125; from &#x27;@nestjs/typeorm&#x27;</span><br><span class="line">import &#123; UserEntity &#125; from &#x27;./entities/user.entity&#x27;</span><br><span class="line"></span><br><span class="line">export class UserService &#123;</span><br><span class="line">	constructor (</span><br><span class="line">		@InjectRepository(UserEntity)</span><br><span class="line">		private readonly userRepository: Repository&lt;UserEntity&gt;,</span><br><span class="line">	)&#123;&#125;</span><br><span class="line">	findAll(): Promise&lt;UserEntity[]&gt; &#123;</span><br><span class="line">		const lists = this.userRepository.find()</span><br><span class="line">		return lists</span><br><span class="line">	&#125;</span><br><span class="line">	findOne(id: number): Promise&lt;UserEntity&gt; &#123;</span><br><span class="line">		const list = this.userRepository.findOne(id)</span><br><span class="line">		return list</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一种是通过 <code>SQL</code> 语句，功能强大，推荐第二种</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; InjectRepository &#125; from &#x27;@nestjs/typeorm&#x27;;</span><br><span class="line">import &#123; Repository, getRepository &#125; from &#x27;typeorm&#x27;;</span><br><span class="line"></span><br><span class="line">export class UserService &#123;</span><br><span class="line">	constructor (</span><br><span class="line">		@InjectRepository(UserEntity)</span><br><span class="line">	) &#123;&#125;</span><br><span class="line">	async find(id): Promise&lt;UserEntity[]&gt; &#123;</span><br><span class="line">		const list = await getRepository(UserEntity)</span><br><span class="line">			.createQueryBuilder(&#x27;user&#x27;)</span><br><span class="line">			.where(&#x27;user.id = :id&#x27;, &#123; id ))</span><br><span class="line">			.getMany();</span><br><span class="line">		return list</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面语句解析为，在数据库中查找符合 <code>id</code> 的数据值，并返回。</p>
<p>更多操作参考<a href="https://typeorm.biunav.com/zh/">TypeORM 中文文档</a></p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>nestjs</tag>
      </tags>
  </entry>
  <entry>
    <title>Rxjs 基础</title>
    <url>/2022/03/21/rearEnd/rxjs%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p><img src="/2022/03/21/rearEnd/rxjs%E5%9F%BA%E7%A1%80/image-20220321213146392.png" alt="image-20220321213146392"></p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>什么是 rxjs？</p>
<p>一组可用来处理非同步或事件的 <code>javascript</code> 函数库，也就是说，通过 <code>rxjs</code> 可以按照我们的意愿，有序的控制和管理异步。</p>
<p>打个比方，有序发出 <code>5</code> 个 <code>ajax</code>，返回的结果未必会按照 <code>1,2,3,4,5</code> 的顺序返回，可能是 <code>1,3,2,5,4</code> ，异步请求返回时间会受多方面的影响，我们想要异步结果按照一定的顺序返回时，<code>rxjs</code> 可以帮助我们解决这个问题。</p>
<span id="more"></span>



<p>什么是非同步？</p>
<ul>
<li><p>ajax / XHR（XMLHttpRequest） / fetch API</p>
</li>
<li><p>Service Worker / Node Stream</p>
</li>
<li><p>setTimeout / setInterval</p>
</li>
<li><p>Promise</p>
</li>
</ul>
<p>什么是事件</p>
<ul>
<li>各式 <code>DOM</code> 事件（<code>click</code>，<code>dblclick</code>，<code>keyup</code>，<code>mousemove</code>）</li>
<li><code>CSS</code> 动画事件（<code>CSS3 transitionEnd event</code>）</li>
<li><code>HTML5 Geolication</code> / <code>WebSockets</code> / <code>Server Send Event</code></li>
</ul>
<h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><ul>
<li><p><strong>Observable（可观测的对象）</strong></p>
<p>代表一组未来即将产生的事件资料（被观察的物件）。</p>
<p>什么叫被观察，打比方 <code>click</code> 事件，当它触发后，是会发出一些信号的，被观察事件可以理解为具有发射源，它总会朝外发出某些信号。</p>
</li>
<li><p><strong>Observer（观察者对象）</strong></p>
<p>是个函数，代表一个用来接受<strong>观察结果</strong>的物件（收到的就是事件信息），<code>Observer</code> 就是一个物件包含 <code>3</code> 个含有回调函数的属性（next，error，complete）</p>
<p>观察者对象是用来干什么呢？它是用于接受 <code>Observable</code> 信号的，<code>Observable</code> 发出信号后，总有个东西去接受这些信号才可以。</p>
<p><strong><code>Rxjs</code> 最核心的就是上述这两个概念，一个发出，一个接受</strong></p>
</li>
<li><p><strong>Subscription（订阅物件）</strong></p>
<p>代表正在执行 <code>Observable / Observer</code> 的执行个体（可用来取消订阅）</p>
<p>我们通过 <code>Observer</code> 去观察 <code>Observable</code> 的结果，它的结果基本上就是丢事件信号出来。这整件事的过程可以理解为订阅的行为，通过 <code>Observer</code> 去订 <code>Observable</code>，这整件事，我们称之为一个 <code>Subscription</code></p>
</li>
<li><p><strong>Operators（操作符）</strong></p>
<p>必须拥有函数编程中纯函数（没有副作用）的特性，主要用来处理一些列的事件资料集合，常见的操作符包含<code>map</code>，<code>filter</code>，<code>concat</code>，<code>flatMap</code>，<code>switchMap</code></p>
<p>通过 <code>Observable</code> 产生一个可观测的环境，让 <code>Observer</code> 去观察它，这整件事变成一个 <code>Subscription</code>，那么，从 <code>Observable</code> 发出的事件，到 <code>Observer</code> 观察前的这段时间，我们可以通过 <code>Operators</code> 操作符去处理，转换 <code>Observable</code> 产生的信号，使其增强，过滤，融合等操作去调整他们，并把最后结果给到 <code>Observer</code></p>
</li>
<li><p><strong>Subject（主体）</strong></p>
<p>和 <code>EventEmitter</code> 一样，主要用来广播收到的事件资料给多位 <code>Observer</code></p>
<p>也就是说，<code>Observable</code> 发出事件后，可以通过 <code>Subject</code> 先接收起来，然后再转发给多个 <code>Observer</code>去拿到这个事件，从原本的一个发生，一个接受，变成了多个发生，多个接受，你可以把 <code>Subject</code> 理解为代理。</p>
<p>为什么要有 <code>Subject</code> 这是因为 <code>Observable</code> 需要靠 <code>Observer</code> 去运作，如果没有 <code>Observer</code> 去订阅 <code>Observable</code> 的变化，就算 <code>Observable</code> 有值，它也没有意义，没人去接受它。有种场景，需要两个 <code>Observable</code> 发出信号，如果订阅两次，这可能会出现问题，打比方有两个 <code>click</code> 事件，当有一个 <code>click</code> 发生以后，它就会把事件产生 <code>2</code> 遍，然后送给两个 <code>Observer</code>，这就等于做了两遍 <code>click</code>，而实际上只有一遍。</p>
<p>也就是说<strong>订阅几次，Observable 就会发出（触发）几次信号</strong>。</p>
</li>
<li><p><strong>Schedulers(调度器)</strong></p>
<p>用来管理和调度多个事件</p>
<p>当 <code>Observable</code> 种类很多的时候，你又要在一段时间内，同时并发，这复杂度就会变的很高，<code>Schedulers</code> 用来调控这些事件如何去管理，在什么时间点才去发出信号。</p>
</li>
</ul>
<h2 id="公式详解"><a href="#公式详解" class="headerlink" title="公式详解"></a>公式详解</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rxjs.interval(500).pipe(rxjs.operators.take(4)).subscribe(console.log)</span><br></pre></td></tr></table></figure>

<ul>
<li>rxjs.interval(500)：建立一个 <code>Observable</code>，这个步骤也称为<strong>建立（creation）</strong>，每 <code>500</code> 毫秒会发出一个信号。</li>
<li>pipe(rxjs.operators.take(4))：是个水管，称为<strong>过滤（Filtering）</strong>，在里面可以执行 <code>Operators</code> 操作符，该操作符意思是取前 <code>4</code> 个信号。</li>
<li>subscribe(console.log)：是订阅并与 <code>Observable</code> 建立联系，称为<strong>观察（Observer）</strong>，<code>console.log</code> 是 <code>Observer</code>，用于观察由 <code>Observable</code> 送出来的信息。<strong>Observer 通常是一个 function</strong></li>
<li>上述代码的结果会返回一个 <code>Subscription</code>，拿到这个 <code>Subscription</code> 我们可以用来取消订阅它。</li>
</ul>
<h2 id="rxjs-编写方式"><a href="#rxjs-编写方式" class="headerlink" title="rxjs 编写方式"></a>rxjs 编写方式</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><ul>
<li><p>建立可观察的 <code>Observable</code> 对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var clicks$ = rxjs.fromEvent(document, &#x27;click&#x27;)</span><br></pre></td></tr></table></figure></li>
<li><p>建立观察者对象 <code>Observer</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var observer = &#123; next: (x) =&gt; console.log(x) &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>建立订阅关系（订阅 Observable 对象，并传入 Observer 观察者对象）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var sub$ = clicks$.subscribe(observer)</span><br></pre></td></tr></table></figure></li>
<li><p>取消订阅 <code>Subscription</code> 对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">subs$.unsubscribe() </span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h3><ul>
<li><p>建立可观察的  <code>Observable</code> 对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var clicks$ = rxjs.fromEvent(document, &#x27;click&#x27;)</span><br></pre></td></tr></table></figure></li>
<li><p>套用 <code>filter</code> 操作符</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">clicks$ = clicks$.pipe(filter(x =&gt; x.clientX &lt; 100))</span><br></pre></td></tr></table></figure>

<p><code>pipe</code> 参数可以有多个，用逗号隔开</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">clicks$ = clicks$.pipe(</span><br><span class="line">	filter(x =&gt; x.clientX &lt; 100),</span><br><span class="line">	take(4)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
<li><p>建立订阅关系（订阅 Observable 对象，并传入 Observer 观察者对象）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var subs$ = clicks$.subscribe(console.log)</span><br></pre></td></tr></table></figure></li>
<li><p>取消订阅 <code>Subscription</code> 对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">subs$.unsubscribe()</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="主体-Subject-用法"><a href="#主体-Subject-用法" class="headerlink" title="主体 Subject 用法"></a>主体 Subject 用法</h3><ul>
<li><p>建立主体（<code>Subject</code>）(之后要靠这个主体物件进行广播)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var subject = new rxjs.Subject()</span><br></pre></td></tr></table></figure></li>
<li><p>建立可观察的 <code>Observable</code> 对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var clicks$ = rxjs.fromEvent(document, &#x27;click&#x27;)</span><br></pre></td></tr></table></figure></li>
<li><p> 设置过滤条件，最多取两次，<code>Observable</code> 就结束</p>
</li>
</ul>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">clicks$ = clicks$.pipe(take(2))</span><br></pre></td></tr></table></figure>

<ul>
<li><p>设置将 <code>clicks$</code> 全部交由 <code>subject</code> 主体进行广播</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">clicks$.subscribe(subject)</span><br></pre></td></tr></table></figure>

<p><code>subject</code> 对 <code>Observable</code>  只是一次的订阅，因此 ``Observable` 就不会发两次出来</p>
</li>
<li><p>最后再由 <code>subject</code> 去建立 <code>Observer</code> 观察者对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var subs1$ = subject.subscribe(console.log)</span><br><span class="line">var subs2$ = subject.subscribe(console.log)</span><br></pre></td></tr></table></figure></li>
<li><p>取消订阅 <code>Subscription</code> 对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">subs1$.unsubscribe()</span><br><span class="line">subs2$.unsubscribe()</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="弹珠图-运算符"><a href="#弹珠图-运算符" class="headerlink" title="弹珠图(运算符)"></a>弹珠图(运算符)</h2><p><a href="https://reactive.how/rxjs/map">Rxjs Explorer</a></p>
<p><a href="https://rxjs.dev/">Rxjs 官网</a></p>
<h3 id="创建运算符"><a href="#创建运算符" class="headerlink" title="创建运算符"></a>创建运算符</h3><p>负责建立一个 <code>Observable</code> 物件</p>
<ul>
<li> 常用运算符</li>
<li>from将 promise 转成 Observable</li>
<li>fromEvent</li>
<li>fromEventPattern</li>
<li>interval</li>
<li>of</li>
<li>range</li>
<li>throwError</li>
<li>timer当 timer 结束时发出一个值<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 1秒后发出0，然后结束，因为没有提供第二个参数</span><br><span class="line">const source = timer(1000);</span><br><span class="line">// 输出: 0</span><br><span class="line">const subscribe = source.subscribe(val =&gt; console.log(val));</span><br></pre></td></tr></table></figure></li>
<li>其他运算符<ul>
<li>ajax</li>
<li>bindCallback</li>
<li>bindNodeCallback</li>
<li>defer</li>
<li>generate</li>
<li>iif</li>
</ul>
</li>
</ul>
<h3 id="组合创建运算符"><a href="#组合创建运算符" class="headerlink" title="组合创建运算符"></a>组合创建运算符</h3><p>可将多个 <code>Observable</code> 对象，合并成一个 <code>Observable</code> 对象</p>
<ul>
<li>常用运算符<ul>
<li><p>combineLatest</p>
</li>
<li><p>concat</p>
<p>解释：用来连接多个 observable。并顺序依次执行</p>
<p>特点：按照顺序，前一个 observable 完成了再订阅下一个 observable 并发出值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source : ----0----1----2|</span><br><span class="line">source2: (3)|</span><br><span class="line">source3: (456)|</span><br><span class="line">            concat()</span><br><span class="line">example: ----0----1----2(3456)|</span><br></pre></td></tr></table></figure></li>
<li><p>forkJoin</p>
</li>
<li><p>merge</p>
<p>特点：merge 把多个 observable <strong>同时</strong>处理，这跟 concat 一次处理一个 observable 是完全不一样的，由于是同时处理行为会变得较为复杂。 merge 的逻辑有点像是 OR(||)，就是当两个 observable 其中一个被触发时都可以被处理，这很常用在一个以上的按钮具有部分相同的行为。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source : ----0----1----2|</span><br><span class="line">source2: --0--1--2--3--4--5|</span><br><span class="line">            merge()</span><br><span class="line">example: --0-01--21-3--(24)--5|</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>其他运算符<ul>
<li><p>race</p>
</li>
<li><p>zip</p>
<p>在所有 observables 发出后，将它们的值作为数组发出，操作符会订阅所有内部 observables，然后等待每个发出一个值。一旦发生这种情况，将发出具有相应索引的所有值。这会持续进行，直到至少一个内部 observable 完成。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const sourceOne = of(&#x27;Hello&#x27;);</span><br><span class="line">const sourceTwo = of(&#x27;World!&#x27;);</span><br><span class="line">const sourceThree = of(&#x27;Goodbye&#x27;);</span><br><span class="line">const sourceFour = of(&#x27;World!&#x27;);</span><br><span class="line">// 一直等到所有 observables 都发出一个值，才将所有值作为数组发出</span><br><span class="line">const example = zip(</span><br><span class="line">  sourceOne,</span><br><span class="line">  sourceTwo.pipe(delay(1000)),</span><br><span class="line">  sourceThree.pipe(delay(2000)),</span><br><span class="line">  sourceFour.pipe(delay(3000))</span><br><span class="line">);</span><br><span class="line">// 输出: [&quot;Hello&quot;, &quot;World!&quot;, &quot;Goodbye&quot;, &quot;World!&quot;]</span><br><span class="line">const subscribe = example.subscribe(val =&gt; console.log(val));</span><br></pre></td></tr></table></figure></li>
<li><p>partition</p>
</li>
</ul>
</li>
</ul>
<h3 id="转换运算符"><a href="#转换运算符" class="headerlink" title="转换运算符"></a>转换运算符</h3><p>负责将 Observable 传入的信息转换成另一种格式</p>
<ul>
<li><p>常用运算符</p>
<ul>
<li><p>concatMap</p>
<p>将值映射成内部 observable，并按顺序订阅和发出。</p>
</li>
<li><p>concatMapTo</p>
</li>
<li><p>map</p>
</li>
<li><p>mapTo</p>
<p>将每个发出值映射成常量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 每2秒发出值</span><br><span class="line">const source = interval(2000);</span><br><span class="line">// 将所有发出值映射成同一个值</span><br><span class="line">const example = source.pipe(mapTo(&#x27;HELLO WORLD!&#x27;));</span><br><span class="line">// 输出: &#x27;HELLO WORLD!&#x27;...&#x27;HELLO WORLD!&#x27;...&#x27;HELLO WORLD!&#x27;...</span><br><span class="line">const subscribe = example.subscribe(val =&gt; console.log(val));</span><br></pre></td></tr></table></figure></li>
<li><p>mergeMap</p>
<p>将值转换成 observable 并发出值，无序的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 发出 &#x27;Hello&#x27;</span><br><span class="line">const source = of(&#x27;Hello&#x27;);</span><br><span class="line">// 映射成 observable 并将其打平</span><br><span class="line">const example = source.pipe(mergeMap(val =&gt; of(`$&#123;val&#125; World!`)));</span><br><span class="line">// 输出: &#x27;Hello World!&#x27;</span><br><span class="line">const subscribe = example.subscribe(val =&gt; console.log(val));</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 发出 &#x27;Hello&#x27;</span><br><span class="line">const source = of(&#x27;Hello&#x27;);</span><br><span class="line">// mergeMap 还会发出 promise 的结果</span><br><span class="line">const myPromise = val =&gt;</span><br><span class="line">  new Promise(resolve =&gt; resolve(`$&#123;val&#125; World From Promise!`));</span><br><span class="line">// 映射成 promise 并发出结果</span><br><span class="line">const example = source.pipe(mergeMap(val =&gt; myPromise(val)));</span><br><span class="line">// 输出: &#x27;Hello World From Promise&#x27;</span><br><span class="line">const subscribe = example.subscribe(val =&gt; console.log(val));</span><br></pre></td></tr></table></figure></li>
<li><p>mergeMapTo</p>
</li>
<li><p>switchMap</p>
</li>
<li><p>switchMapTo</p>
</li>
<li><p>pluck</p>
</li>
</ul>
</li>
<li><p>其他运算符</p>
<ul>
<li>buffer</li>
<li>bufferCount</li>
<li>bufferTime</li>
<li>bufferToggle</li>
<li>bufferWhen</li>
<li>exhaust</li>
<li>exhaustMap</li>
<li>expand</li>
<li>groupBy</li>
<li>mergeScan</li>
<li>pairwise</li>
<li>scan</li>
<li>window</li>
<li>windowCount</li>
</ul>
</li>
</ul>
<h3 id="过滤运算符"><a href="#过滤运算符" class="headerlink" title="过滤运算符"></a>过滤运算符</h3><p>负责将 <code>Observable</code> 传入的信息过滤、筛选掉</p>
<ul>
<li>常用运算符<ul>
<li>debounce</li>
<li>debounceTime</li>
<li>distinct</li>
<li>filter</li>
<li>first/last</li>
<li>skip/take</li>
<li>throttle</li>
<li>throttleTime</li>
</ul>
</li>
<li>其他运算符<ul>
<li>audit</li>
<li>auditTime</li>
<li>distinctUntilChanged</li>
<li>distinctKey</li>
<li>distinctUnitlKeyCHnage</li>
</ul>
</li>
</ul>
<h3 id="组合运算符"><a href="#组合运算符" class="headerlink" title="组合运算符"></a>组合运算符</h3><p>负责组合多个 <code>Observable</code></p>
<ul>
<li>常用运算符<ul>
<li><p>combineAll</p>
</li>
<li><p>concatAll</p>
<p>有时我们的 Observable 送出的元素又是一个 observable，就像是二维数组，数组里面的元素是数组，这时我们就可以用 concatAll 把它摊平成一维数组，大家也可以直接把 concatAll 想成把所有元素 concat 起来。 </p>
<p>特点：摊平 Observable</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fromEvent(document.body, &#x27;click&#x27;)</span><br><span class="line">	.pipe(</span><br><span class="line">	// 内部发出值是 observable 类型</span><br><span class="line">		map(e =&gt; of(1,2,3)),</span><br><span class="line">		// 取 observable 的值</span><br><span class="line">		concatAll(),</span><br><span class="line">	)</span><br><span class="line">	.subscribe(val =&gt;</span><br><span class="line">		console.log(val)</span><br><span class="line">	);</span><br></pre></td></tr></table></figure></li>
<li><p>mergeAll</p>
</li>
<li><p>startWith</p>
</li>
</ul>
</li>
<li>其他运算符<ul>
<li>exhaust</li>
<li>withLatestFrom</li>
</ul>
</li>
</ul>
<h3 id="多播运算符"><a href="#多播运算符" class="headerlink" title="多播运算符"></a>多播运算符</h3><p>负责将 <code>Observable</code> 广播给多位观察者（<code>Observer</code>）</p>
<ul>
<li>常见运算符<ul>
<li>publish</li>
<li>publishReplay</li>
<li>share</li>
</ul>
</li>
<li>其他运算符<ul>
<li>multicast</li>
<li>publishBehavior</li>
<li>publishLast</li>
</ul>
</li>
</ul>
<h3 id="错误处理运算符"><a href="#错误处理运算符" class="headerlink" title="错误处理运算符"></a>错误处理运算符</h3><p>负责处理 <code>Observable</code> 观察过程中出现的额外错误</p>
<ul>
<li>常用运算符<ul>
<li>catchError</li>
<li>retry</li>
<li>retryWhen</li>
</ul>
</li>
</ul>
<h3 id="工具函数运算符"><a href="#工具函数运算符" class="headerlink" title="工具函数运算符"></a>工具函数运算符</h3><p>负责提供 <code>Observable</code> 执行过程的工具函数</p>
<ul>
<li>常用运算符<ul>
<li>tap</li>
<li>delay</li>
<li>materialize</li>
<li>timeout</li>
<li>timeoutWith</li>
<li>toArray</li>
</ul>
</li>
<li>其他运算符<ul>
<li>delayWhen</li>
<li>dematerialize</li>
<li>observeOn</li>
<li>subscribeOn</li>
<li>timeInterval</li>
<li>times tamp</li>
</ul>
</li>
</ul>
<h3 id="条件式布尔运算符"><a href="#条件式布尔运算符" class="headerlink" title="条件式布尔运算符"></a>条件式布尔运算符</h3><p>负责计算特定条件并回传布尔值的运算符</p>
<ul>
<li>常用运算符<ul>
<li>defaultEmpty</li>
<li>every</li>
<li>find</li>
<li>findIndex</li>
<li>isEmpty</li>
</ul>
</li>
</ul>
<h3 id="汇总运算符"><a href="#汇总运算符" class="headerlink" title="汇总运算符"></a>汇总运算符</h3><p>负责将 <code>Observable</code> 传来的信息进行数学汇总运算</p>
<ul>
<li>常用运算符<ul>
<li>count</li>
<li>max</li>
<li>min</li>
</ul>
</li>
<li>其他运算符<ul>
<li>reduce</li>
</ul>
</li>
</ul>
<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q &amp; A"></a>Q &amp; A</h2><ul>
<li><p>Q: <a href="https://stackoverflow.com/questions/64349628/what-is-injectable-in-nestjs">What is Injectable in NestJS?</a></p>
<p>A: </p>
</li>
</ul>
<h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><ul>
<li><a href="https://rxjs.dev/">rxjs 官网</a></li>
<li><a href="https://rxmarbles.com/">弹珠图</a></li>
<li><a href="https://rxjs-cn.github.io/learn-rxjs-operators/">操作符</a></li>
<li><a href="http://rx.js.cool/">rxjs 入门到精通</a></li>
</ul>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>rxjs</tag>
      </tags>
  </entry>
  <entry>
    <title>Nestjs 返回给前端数据格式封装</title>
    <url>/2022/03/19/rearEnd/nestjs%E8%BF%94%E5%9B%9E%E7%BB%99%E5%89%8D%E7%AB%AF%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E5%B0%81%E8%A3%85/</url>
    <content><![CDATA[<blockquote>
<p>最近在学 node，用的是 nestjs 框架，今天在前后端联调时，发现返回的数据并不是预想中的，因此记录下封装过程。</p>
</blockquote>
<span id="more"></span>

<h3 id="为什么要对数据进行封装"><a href="#为什么要对数据进行封装" class="headerlink" title="为什么要对数据进行封装"></a>为什么要对数据进行封装</h3><p>接口写完后，皆大欢喜，前端请求发现拿到的数据是这样的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&#123;&quot;id&quot;:4321,&quot;createdTime&quot;:&quot;2022-02-28T16:00:00.000Z&quot;,&quot;sprintName&quot;:&quot;第一次迭代&quot;,&quot;describe&quot;:&quot;第一次迭代呀&quot;,&quot;devOwner&quot;:&quot;es&quot;,&quot;testOwner&quot;:&quot;test&quot;,&quot;status&quot;:&quot;未开始&quot;&#125;]</span><br></pre></td></tr></table></figure>

<p>咦，感觉有点不太一样，印象中后端返回的数据有 <code>data</code>，<code>code</code>，<code>message</code> 字段的，问了后端的同事，才知道，原来返回给前端的数据要封装的</p>
<p>我们预期的是酱紫的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&quot;data&quot;:[&#123;&quot;id&quot;:4321,&quot;createdTime&quot;:&quot;2022-02-28T16:00:00.000Z&quot;,&quot;sprintName&quot;:&quot;第一次迭代&quot;,&quot;describe&quot;:&quot;第一次迭代呀&quot;,&quot;devOwner&quot;:&quot;es&quot;,&quot;testOwner&quot;:&quot;test&quot;,&quot;status&quot;:&quot;未开始&quot;&#125;],&quot;code&quot;:0,&quot;message&quot;:&quot;请求成功&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>带着疑问，在 <code>nest</code> 中能够对原本 <code>request</code>/<code>response</code> 加工的有过滤器（filter）拦截器（interceptors）以及中间件（middleware）</p>
<h3 id="interceptor，filter，middleware-的区别"><a href="#interceptor，filter，middleware-的区别" class="headerlink" title="interceptor，filter，middleware 的区别"></a>interceptor，filter，middleware 的区别</h3><h4 id="interceptor"><a href="#interceptor" class="headerlink" title="interceptor"></a>interceptor</h4><p><code>nest.js</code> 提供 <code>interceptor</code> 可以对于程式要进入 <code>method</code> 之前与之后，执行一段程式或是对输入输出讯息做处理，称之 <code>Aspect-Oriented Programming(AOP)</code>。</p>
<p><strong>条件：<code>interceptor</code> 必须拥有 <code>NestInterceptor</code> 接口</strong></p>
<p><code>interceptor</code> 方法传入两个引数 <code>ExecutionContext</code></p>
<ul>
<li>ExecutionContext: 可以取得controller、及http相关信息(http context)</li>
<li><code>call$</code>: 这部分比较抽象，简单来说，<code>call$ </code>就是回传到 <code>client</code> 的 <code>response stream</code>，如果<code>interceptor</code> 没有回传 <code>call$</code>，则等于是 <code>controller</code> 处理完后不会丢回 <code>response</code>。</li>
</ul>
<h4 id="filter-Exception-Filters-异常过滤器"><a href="#filter-Exception-Filters-异常过滤器" class="headerlink" title="filter(Exception Filters)异常过滤器"></a>filter(Exception Filters)异常过滤器</h4><p>当接口错误，就属于异常了，它会被 <code>throw</code> 抛出异常，因此这个时候，我们需要用到异常过滤器（filter）来获取到其异常内容，然后可以自定义修改返回给前端。</p>
<p><strong>异常过滤器在路由处理程序和拦截器之后调用。它们是在响应消失之前最后进行更改的地方。</strong></p>
<p>通过命令创建一个过滤器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nest g f filters/httpException</span><br></pre></td></tr></table></figure>



<h4 id="middleware"><a href="#middleware" class="headerlink" title="middleware"></a>middleware</h4><p>仅在调用路由处理程序之前调用中间件。您可以访问响应对象，但没有路由处理程序的结果。它们基本上是表达的中间件功能。</p>
<h3 id="成功数据统一封装"><a href="#成功数据统一封装" class="headerlink" title="成功数据统一封装"></a>成功数据统一封装</h3><p>成功请求不属于异常，因此通过 <code>interceptor</code> 封装请求</p>
<p>在根目录新建 <code>src/interceptor/transform.interceptor.ts</code> 文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123;</span><br><span class="line">  Injectable,</span><br><span class="line">  NestInterceptor,</span><br><span class="line">  CallHandler,</span><br><span class="line">  ExecutionContext,</span><br><span class="line">&#125; from &#x27;@nestjs/common&#x27;;</span><br><span class="line"></span><br><span class="line">import &#123; map &#125; from &#x27;rxjs/operators&#x27;;</span><br><span class="line">import &#123; Observable &#125; from &#x27;rxjs&#x27;;</span><br><span class="line">interface Response&lt;T&gt; &#123;</span><br><span class="line">  data: T;</span><br><span class="line">&#125;</span><br><span class="line">@Injectable()</span><br><span class="line">export class TransformInterceptor&lt;T&gt;</span><br><span class="line">  implements NestInterceptor&lt;T, Response&lt;T&gt;&gt;</span><br><span class="line">&#123;</span><br><span class="line">  intercept(</span><br><span class="line">    context: ExecutionContext,</span><br><span class="line">    next: CallHandler&lt;T&gt;,</span><br><span class="line">  ): Observable&lt;Response&lt;T&gt;&gt; &#123;</span><br><span class="line">    return next.handle().pipe(</span><br><span class="line">      map((data) =&gt; &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">          data,</span><br><span class="line">          // 一般来说成功请求码为 0 或 1000</span><br><span class="line">          code: 0,</span><br><span class="line">          message: &#x27;请求成功&#x27;,</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>全局注册</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; TransformInterceptor &#125; from &#x27;./interceptor/transform.interceptor&#x27;;</span><br><span class="line">sync function bootstrap() &#123;</span><br><span class="line">	...</span><br><span class="line">	// 全局注册拦截器</span><br><span class="line">	app.useGlobalInterceptors(new TransformInterceptor());</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line">bootstrap()</span><br></pre></td></tr></table></figure>



<h3 id="拦截全部错误请求"><a href="#拦截全部错误请求" class="headerlink" title="拦截全部错误请求"></a>拦截全部错误请求</h3><p>请求任何一个地方失败了，都会被异常过滤器捕获</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123;</span><br><span class="line">  ArgumentsHost,</span><br><span class="line">  Catch,</span><br><span class="line">  ExceptionFilter,</span><br><span class="line">  HttpException,</span><br><span class="line">  HttpStatus,</span><br><span class="line">  Logger,</span><br><span class="line">&#125; from &#x27;@nestjs/common&#x27;;</span><br><span class="line"></span><br><span class="line">@Catch(HttpException)</span><br><span class="line">export class HttpExceptionFilter implements ExceptionFilter &#123;</span><br><span class="line">  catch(exception: HttpException, host: ArgumentsHost) &#123;</span><br><span class="line">    const ctx = host.switchToHttp();</span><br><span class="line">    const response = ctx.getResponse();</span><br><span class="line">    const request = ctx.getRequest();</span><br><span class="line"></span><br><span class="line">    const message = exception.message;</span><br><span class="line">    Logger.log(&#x27;error&#x27;, message);</span><br><span class="line">    const errorResponse = &#123;</span><br><span class="line">    	// 这里没写，失败请求码自定义，根据业务场景定</span><br><span class="line">      data: &#123;</span><br><span class="line">        error: message,</span><br><span class="line">      &#125;,</span><br><span class="line">      message: &#x27;请求失败&#x27;,</span><br><span class="line">    &#125;;</span><br><span class="line">    const status =</span><br><span class="line">      exception instanceof HttpException</span><br><span class="line">        ? exception.getStatus()</span><br><span class="line">        : HttpStatus.INTERNAL_SERVER_ERROR;</span><br><span class="line"></span><br><span class="line">    response.status(status);</span><br><span class="line">    response.header(&#x27;Content-Type&#x27;, &#x27;application/json; charset=utf-8&#x27;);</span><br><span class="line">    response.send(errorResponse);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="请求从客户端到服务器经历的步骤"><a href="#请求从客户端到服务器经历的步骤" class="headerlink" title="请求从客户端到服务器经历的步骤"></a>请求从客户端到服务器经历的步骤</h3><p>从客户端发送一个 <code>post</code> 请求，路径为：/user/login，请求参数为：{ use: ‘xx’, psd: ‘xx’ }，到服务器接收请求内容，触发绑定的函数并且执行相关逻辑完毕，然后返回内容给客户端的整个过程大体上要经过如下几个步骤：</p>
<p><img src="/2022/03/19/rearEnd/nestjs%E8%BF%94%E5%9B%9E%E7%BB%99%E5%89%8D%E7%AB%AF%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E5%B0%81%E8%A3%85/image-20220318194756876.png" alt="image-20220318194756876"></p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>nestjs</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode</title>
    <url>/2022/02/26/algorithms/leetcode/</url>
    <content><![CDATA[<p><img src="/2022/02/26/algorithms/leetcode/image-20220226225324917.png" alt="image-20220226225324917"></p>
<blockquote>
<p>leetcode 题解</p>
</blockquote>
<span id="more"></span>



<h2 id="Sqrt-x"><a href="#Sqrt-x" class="headerlink" title="Sqrt(x)"></a>Sqrt(x)</h2><blockquote>
<p>给你一个非负整数 <code>x</code> ，计算并返回 <code>x</code> 的 <strong>算术平方根</strong> 。</p>
<p>由于返回类型是整数，结果只保留 <strong>整数部分</strong> ，小数部分将被 <strong>舍去 。</strong></p>
<p><strong>注意：</strong>不允许使用任何内置指数函数和算符，例如 <code>pow(x, 0.5)</code> 或者 <code>x ** 0.5</code> 。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：x = 4</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：x = 8</span><br><span class="line">输出：2</span><br><span class="line">解释：8 的算术平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>我们知道，要获取平方根，只需找到一个数，它的平方小于 x，它加 <code>1</code> 的平方大于 x</p>
<p>因此，可以通过二分查找找到这个值，创建两个指针，<code>left</code> 和 <code>right</code>，重点是那个中间值 <code>mid</code> 怎么求</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1,2,3,4,5,6,7,8,9</span><br></pre></td></tr></table></figure>

<p>通过这几个数字，我们可以理解，为啥要 <code>left + ((right - left) &gt;&gt; 1)</code>，其中 <code>(right - left) &gt;&gt; 1</code> 计算的就是 <code>right</code> 和 <code>left</code> 的偏移差，然后再用 <code>left</code> 加这个偏移差，就是中间值。</p>
<p>例如计算 <code>4 ~ 8</code> 的中间值， <code>4 +  ((8 - 4)/ 2) = 6</code></p>
<h3 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h3><p>js 版</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number&#125; x</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">var mySqrt = function(x) &#123;</span><br><span class="line">  if (x &lt;= 1) return x</span><br><span class="line">  let left = 0</span><br><span class="line">  let right = x</span><br><span class="line">  while (left &lt;= right) &#123;</span><br><span class="line">    const mid = left + ((right - left) &gt;&gt; 1)</span><br><span class="line">    if ((mid * mid) &lt;= x) &#123;</span><br><span class="line">      left = mid + 1</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      right = mid - 1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return right</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h2 id="存在重复元素-II"><a href="#存在重复元素-II" class="headerlink" title="存在重复元素 II"></a>存在重复元素 II</h2><blockquote>
<p>给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的绝对值至多为 k。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [1,2,3,1], k = 3</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [1,0,1,1], k = 1</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [1,2,3,1,2,3], k = 2</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>判断重复元素，每次往 <code>Set</code> 里面塞元素，题目要求的是，最多为 <code>k</code>，那么如果大于 k 都没有找到，滑动窗口右移。</p>
<p>也就是说，它要找的是 <code>k</code> 长度内是否有重复元素。</p>
<h3 id="解题-1"><a href="#解题-1" class="headerlink" title="解题"></a>解题</h3><p>js 版</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number[]&#125; nums</span><br><span class="line"> * @param &#123;number&#125; k</span><br><span class="line"> * @return &#123;boolean&#125;</span><br><span class="line"> */</span><br><span class="line">var containsNearbyDuplicate = function(nums, k) &#123;</span><br><span class="line">    const s = new Set()</span><br><span class="line">    for(let i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">        if (s.has(nums[i])) &#123;</span><br><span class="line">            return true</span><br><span class="line">        &#125;</span><br><span class="line">        s.add(nums[i])</span><br><span class="line">        if (s.size &gt; k) &#123;</span><br><span class="line">            s.delete(nums[i - k])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h2 id="二叉树的中序遍历"><a href="#二叉树的中序遍历" class="headerlink" title="二叉树的中序遍历"></a>二叉树的中序遍历</h2><blockquote>
<p>给定一个二叉树的根节点 <code>root</code> ，返回它的 <strong>中序</strong> 遍历。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1,null,2,3]</span><br><span class="line">输出：[1,3,2]</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>首先要理解，什么叫二叉树的中序遍历，按照访问左子树——根节点——右子树的方式遍历这棵树，而在访问左子树或者右子树的时候我们按照同样的方式遍历，直到遍历完整棵树。</p>
<p>因此我们通过维护一个栈</p>
<p>首先，将左子树挨个插入到栈中，<code>root.left</code> 为 <code>undefined</code> 则停止插入，随后在栈中，弹出最上面的，将值放在 <code>res</code> 中，同理，<code> root = root.right</code> 即右子树，这就形成<strong>左中右</strong>插入方式。</p>
<h3 id="解题-2"><a href="#解题-2" class="headerlink" title="解题"></a>解题</h3><p>js 版</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * function TreeNode(val, left, right) &#123;</span><br><span class="line"> *     this.val = (val===undefined ? 0 : val)</span><br><span class="line"> *     this.left = (left===undefined ? null : left)</span><br><span class="line"> *     this.right = (right===undefined ? null : right)</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> * @param &#123;TreeNode&#125; root</span><br><span class="line"> * @return &#123;number[]&#125;</span><br><span class="line"> */</span><br><span class="line">var inorderTraversal = function(root) &#123;</span><br><span class="line">    const res = []</span><br><span class="line">    const stk = []</span><br><span class="line">    while(root || stk.length) &#123;</span><br><span class="line">        while(root) &#123;</span><br><span class="line">            stk.push(root)</span><br><span class="line">            root = root.left</span><br><span class="line">        &#125;</span><br><span class="line">        root = stk.pop()</span><br><span class="line">        res.push(root.val)</span><br><span class="line">        root = root.right</span><br><span class="line">    &#125;</span><br><span class="line">    return res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h2 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a>合并区间</h2><blockquote>
<p>以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：intervals = [[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">输出：[[1,6],[8,10],[15,18]]</span><br><span class="line">解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：intervals = [[1,4],[4,5]]</span><br><span class="line">输出：[[1,5]]</span><br><span class="line">解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><ul>
<li>要找到区间范围，首先要做的是，对数组根据开始区间进行排序</li>
<li>创建一个数组，用于存储输出数据</li>
<li>通过循环，比较输出数据的边界和原区间的大小，更新边界</li>
</ul>
<h3 id="解题-3"><a href="#解题-3" class="headerlink" title="解题"></a>解题</h3><p>js 版</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number[][]&#125; intervals</span><br><span class="line"> * @return &#123;number[][]&#125;</span><br><span class="line"> */</span><br><span class="line">var merge = function(intervals) &#123;</span><br><span class="line">    if(intervals.length === 0) return []</span><br><span class="line">    intervals.sort((a, b) =&gt; a[0] - b[0])</span><br><span class="line">    let outputs = []</span><br><span class="line">    outputs.push(intervals[0])</span><br><span class="line">    for (let i = 1; i &lt; intervals.length; i++) &#123;</span><br><span class="line">        const lastInterval = outputs[outputs.length - 1]</span><br><span class="line">        const startIntarval = intervals[i][0]</span><br><span class="line">        const endIntarval = intervals[i][1]</span><br><span class="line">        if (lastInterval[1] &lt; startIntarval) &#123;</span><br><span class="line">            outputs.push(intervals[i])</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            lastInterval[1] = Math.max(lastInterval[1], endIntarval)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return outputs</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h2><blockquote>
<p>给你一个链表的头节点 head ，判断链表中是否有环。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p>
<p>如果链表中存在环，则返回 true 。 否则，返回 false 。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2], pos = 0</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure>

<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1], pos = -1</span><br><span class="line">输出：false</span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>判断是否有环，可以用快慢指针，快指针一次前进 2 步，慢指针一次前进 1 步，如果有换，它们终将相遇。</p>
<p>有环，while 会一直执行下去，直到它们相遇，没环，快指针最终会遇到 <code>null</code>。</p>
<h3 id="解题-4"><a href="#解题-4" class="headerlink" title="解题"></a>解题</h3><p>js 版</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * function ListNode(val) &#123;</span><br><span class="line"> *     this.val = val;</span><br><span class="line"> *     this.next = null;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @param &#123;ListNode&#125; head</span><br><span class="line"> * @return &#123;boolean&#125;</span><br><span class="line"> */</span><br><span class="line">var hasCycle = function(head) &#123;</span><br><span class="line">    var slow = head</span><br><span class="line">    var fast = head</span><br><span class="line">    while(fast &amp;&amp; fast.next) &#123;</span><br><span class="line">        slow = slow.next</span><br><span class="line">        fast = fast.next.next</span><br><span class="line">        if (slow === fast) &#123;</span><br><span class="line">            return true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="汇总区间"><a href="#汇总区间" class="headerlink" title="汇总区间"></a>汇总区间</h2><blockquote>
<p>给定一个无重复元素的有序整数数组 nums 。</p>
<p>返回 恰好覆盖数组中所有数字 的 最小有序 区间范围列表。也就是说，nums 的每个元素都恰好被某个区间范围所覆盖，并且不存在属于某个范围但不属于 nums 的数字 x 。</p>
<p>列表中的每个区间范围 [a,b] 应该按如下格式输出：</p>
<p>“a-&gt;b” ，如果 a != b<br>“a” ，如果 a == b</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,1,2,4,5,7]</span><br><span class="line">输出：[&quot;0-&gt;2&quot;,&quot;4-&gt;5&quot;,&quot;7&quot;]</span><br><span class="line">解释：区间范围是：</span><br><span class="line">[0,2] --&gt; &quot;0-&gt;2&quot;</span><br><span class="line">[4,5] --&gt; &quot;4-&gt;5&quot;</span><br><span class="line">[7,7] --&gt; &quot;7&quot;</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,2,3,4,6,8,9]</span><br><span class="line">输出：[&quot;0&quot;,&quot;2-&gt;4&quot;,&quot;6&quot;,&quot;8-&gt;9&quot;]</span><br><span class="line">解释：区间范围是：</span><br><span class="line">[0,0] --&gt; &quot;0&quot;</span><br><span class="line">[2,4] --&gt; &quot;2-&gt;4&quot;</span><br><span class="line">[6,6] --&gt; &quot;6&quot;</span><br><span class="line">[8,9] --&gt; &quot;8-&gt;9&quot;</span><br></pre></td></tr></table></figure>

<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p>示例 4：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [-1]</span><br><span class="line">输出：[&quot;-1&quot;]</span><br></pre></td></tr></table></figure>

<p>示例 5：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0]</span><br><span class="line">输出：[&quot;0&quot;]</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p>解决问题的核心点在于，如何判断是否区间终止，从位置 0 出发，向右遍历。每次遇到相邻元素之间的差值大于 1 时，我们就找到了一个区间。<code>nums[i] === nums[i - 1] + 1</code> 可判断数字是否连续，若连续加一</p>
<h3 id="解题-5"><a href="#解题-5" class="headerlink" title="解题"></a>解题</h3><p>js 版</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number[]&#125; nums</span><br><span class="line"> * @return &#123;string[]&#125;</span><br><span class="line"> */</span><br><span class="line">var summaryRanges = function(nums) &#123;</span><br><span class="line">  const res = []</span><br><span class="line">  let i = 0</span><br><span class="line">  const len = nums.length</span><br><span class="line">  while (i &lt; len) &#123;</span><br><span class="line">    const low = i</span><br><span class="line">    i++</span><br><span class="line">    while (i &lt; len &amp;&amp; nums[i] === nums[i - 1] + 1) &#123;</span><br><span class="line">      i++</span><br><span class="line">    &#125;</span><br><span class="line">    const high = i - 1</span><br><span class="line">    const temp = [&#x27;&#x27; + nums[low]];</span><br><span class="line">    if (low &lt; high) &#123;</span><br><span class="line">      temp.push(&#x27;-&gt;&#x27;);</span><br><span class="line">      temp.push(&#x27;&#x27; + nums[high]);</span><br><span class="line">    &#125;</span><br><span class="line">    res.push(temp.join(&#x27;&#x27;));</span><br><span class="line">  &#125;</span><br><span class="line">  return res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h2 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h2><blockquote>
<p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出和为目标值 target  的那两个整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p>
<p>你可以按任意顺序返回答案。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,7,11,15], target = 9</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,2,4], target = 6</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure>

<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,3], target = 6</span><br><span class="line">输出：[0,1]</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><ul>
<li><p>第一种方法是暴力破解，很明显，这样不行，用两个 for 循环，导致时间复杂度为 O(n²)</p>
</li>
<li><p>第二种方法通过 <code>hashmap</code> 的唯一性去存值，数组中的元素作为key，index 作为值，通过循环，找到另一个值，另一个值无非是 <code>target - 当前值</code>，如果这个值存在，就返回，否则将当前值插入到 <code>hashmap</code> 中，这样时间复杂度就变成 <code>O(n)</code></p>
</li>
</ul>
<h3 id="解题-6"><a href="#解题-6" class="headerlink" title="解题"></a>解题</h3><p>js 版</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var twoSum = function(nums, target) &#123;</span><br><span class="line">    let map = new Map()</span><br><span class="line">    for(let i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">        if(map.has(target - nums[i]))&#123;</span><br><span class="line">            return[map.get(target - nums[i]), i]</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            map.set(nums[i], i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return []</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h2 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h2><blockquote>
<p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。</p>
<p>注意：答案中不可以包含重复的三元组。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [-1,0,1,2,-1,-4]</span><br><span class="line">输出：[[-1,-1,2],[-1,0,1]]</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0]</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h3><ul>
<li><p>方法1，暴力破解不多说，O(n³)</p>
</li>
<li><p>方法2，对数组进行排序，从左开始取数，记为 <code>nums</code>，再定两个左右指针 <code>numsL</code> 和 <code>numsR</code>，分别是 nums 后面的两端。</p>
<ul>
<li>若 nums &gt; 0 返回，不可能了，因为大于 0 ，两个指针又是后面数的两端，根本不会有小于零的数。</li>
<li><code>numsL</code> &lt; <code>numsR</code> 数字相同，该层循环取值结束。</li>
<li>记得去重</li>
</ul>
</li>
</ul>
<h3 id="解题-7"><a href="#解题-7" class="headerlink" title="解题"></a>解题</h3><p>js 版</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var threeSum = function(nums) &#123;</span><br><span class="line">    let ans = [];</span><br><span class="line">    const len = nums.length;</span><br><span class="line">    if(nums == null || len &lt; 3) return ans;</span><br><span class="line">    nums.sort((a, b) =&gt; a - b); // 排序</span><br><span class="line">    for (let i = 0; i &lt; len ; i++) &#123;</span><br><span class="line">        if(nums[i] &gt; 0) break; // 如果当前数字大于0，则三数之和一定大于0，所以结束循环</span><br><span class="line">        if(i &gt; 0 &amp;&amp; nums[i] == nums[i-1]) continue; // 去重</span><br><span class="line">        let L = i+1;</span><br><span class="line">        let R = len-1;</span><br><span class="line">        while(L &lt; R)&#123;</span><br><span class="line">            const sum = nums[i] + nums[L] + nums[R];</span><br><span class="line">            if(sum == 0)&#123;</span><br><span class="line">                ans.push([nums[i],nums[L],nums[R]]);</span><br><span class="line">                while (L&lt;R &amp;&amp; nums[L] == nums[L+1]) L++; // 去重</span><br><span class="line">                while (L&lt;R &amp;&amp; nums[R] == nums[R-1]) R--; // 去重</span><br><span class="line">                L++;</span><br><span class="line">                R--;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (sum &lt; 0) L++;</span><br><span class="line">            else if (sum &gt; 0) R--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;        </span><br><span class="line">    return ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h2 id="删除有序数组中的重复项"><a href="#删除有序数组中的重复项" class="headerlink" title="删除有序数组中的重复项"></a>删除有序数组中的重复项</h2><blockquote>
<p>给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p>
<p>说明:</p>
<p>为什么返回数值是整数，但输出的答案是数组呢?</p>
<p>请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>
<p>你可以想象内部操作如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span></span><br><span class="line">int len = removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在函数里修改输入数组对于调用者是可见的。</span></span><br><span class="line"><span class="comment">// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。</span></span><br><span class="line"><span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,1,2]</span><br><span class="line">输出：2, nums = [1,2]</span><br><span class="line">解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,0,1,1,1,2,2,3,3,4]</span><br><span class="line">输出：5, nums = [0,1,2,3,4]</span><br><span class="line">解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h3><p>核心是快慢指针，快指针负责取值，慢指针负责数据存储，快指针自己前一项对比，如果数据一致，则自加，否则将当前数据存储到慢指针位置。</p>
<h3 id="解题-8"><a href="#解题-8" class="headerlink" title="解题"></a>解题</h3><p>js 版</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var removeDuplicates = function(nums) &#123;</span><br><span class="line">    const n = nums.length;</span><br><span class="line">    if (n === 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    let fast = 1, slow = 1;</span><br><span class="line">    while (fast &lt; n) &#123;</span><br><span class="line">        if (nums[fast] !== nums[fast - 1]) &#123;</span><br><span class="line">            nums[slow] = nums[fast];</span><br><span class="line">            ++slow;</span><br><span class="line">        &#125;</span><br><span class="line">        ++fast;</span><br><span class="line">    &#125;</span><br><span class="line">    return slow;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="相似题"><a href="#相似题" class="headerlink" title="相似题"></a>相似题</h3><h4 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h4><blockquote>
<p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</p>
<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
</blockquote>
<h5 id="解题-9"><a href="#解题-9" class="headerlink" title="解题"></a>解题</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number[]&#125; nums</span><br><span class="line"> * @param &#123;number&#125; val</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">var removeElement = function(nums, val) &#123;</span><br><span class="line">    let slow = 0</span><br><span class="line">    let fast = 0</span><br><span class="line">    let len = nums.length</span><br><span class="line">    while(fast &lt; len) &#123;</span><br><span class="line">        if(nums[fast] !== val) &#123;</span><br><span class="line">            nums[slow] = nums[fast]</span><br><span class="line">            slow++</span><br><span class="line">        &#125;</span><br><span class="line">        fast++</span><br><span class="line">    &#125;</span><br><span class="line">    return slow</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h2 id="盛最多水的容器"><a href="#盛最多水的容器" class="headerlink" title="盛最多水的容器"></a>盛最多水的容器</h2><blockquote>
<p>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p>
<p>说明：你不能倾斜容器。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[1,8,6,2,5,4,8,3,7]</span><br><span class="line">输出：49 </span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：height = [1,1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：height = [4,3,2,1,4]</span><br><span class="line">输出：16</span><br></pre></td></tr></table></figure>

<p>示例 4：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：height = [1,2,1]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h3><ul>
<li><p>第一种方法是暴力破解，很明显，这样不行，用两个 for 循环，导致时间复杂度为 O(n²)</p>
</li>
<li><p>第二种方法称为双指针法，我们发现，面积的决定因素在于最短边和长度，因此指针从左右两边开始，每次移动最短那条边，依次将面积和之前的比较，这样时间复杂度控制在 O(n)</p>
</li>
</ul>
<h3 id="解题-10"><a href="#解题-10" class="headerlink" title="解题"></a>解题</h3><p>js 版</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var maxArea = function(height) &#123;</span><br><span class="line">    let max = 0</span><br><span class="line">    let i = 0, j = height.length - 1</span><br><span class="line">    while(i !== j) &#123;</span><br><span class="line">        const left = height[i] // 最左边</span><br><span class="line">        const right = height[j] // 最右边</span><br><span class="line">        const sum =  Math.min(left, right) * (j - i)</span><br><span class="line">        if (left &gt; right) &#123; // 判断移动那一边</span><br><span class="line">            j--</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            i++</span><br><span class="line">        &#125;</span><br><span class="line">        max = Math.max(max, sum)</span><br><span class="line">    &#125;</span><br><span class="line">    return max</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h2 id="搜索旋转排序数组"><a href="#搜索旋转排序数组" class="headerlink" title="搜索旋转排序数组"></a>搜索旋转排序数组</h2><blockquote>
<p>整数数组 nums 按升序排列，数组中的值 互不相同 。</p>
<p>在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。</p>
<p>给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [4,5,6,7,0,1,2], target = 0</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [4,5,6,7,0,1,2], target = 3</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure>

<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1], target = 0</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h3><p>这道题的核心就是二分查找</p>
<p>先看一波定义</p>
<blockquote>
<p>二分查找也称折半查找（Binary Search），是一种在有序数组中查找某一特定元素的搜索算法。我们可以从定义可知，<strong>运用二分搜索的前提是数组必须是有序的</strong>，这里需要注意的是，我们的输入不一定是数组，也可以是数组中某一区间的起始位置和终止位置</p>
</blockquote>
<p>解这道题是通过双指针 + 二分查找实现的</p>
<ul>
<li><p>先定一个开始（start）和结束（end）指针分别代表头和尾。</p>
</li>
<li><p>这里计算中间数有个技巧，通过位运算 start + ((end - start) &gt;&gt; 1)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">100 &gt;&gt; 1 // 50   1代表除2</span><br><span class="line">100 &gt;&gt; 2 // 25   2代表除2后除2</span><br><span class="line">100 &gt;&gt; 3 // 12   3代表除2后除2再除2</span><br></pre></td></tr></table></figure></li>
<li><p>由于我们不知道在哪里旋转，因此通过中间数 <code>nums[mid]</code> 和始末位置的对比，可以判断前面递增还是后面递增</p>
<p>4567123 中间值是 7，如果中间值大于第一个数，说明中间值往左是递增的，否则中间值往右是递增的。</p>
</li>
<li><p>让中间值和 <code>target</code> 对比，看 <code>target</code> 位于那一部分</p>
</li>
<li><p>通过 while 循环二分查找，最终找到值</p>
</li>
<li><p>需要注意的是在判断中需要 <code>=</code> 号</p>
</li>
</ul>
<h3 id="解题-11"><a href="#解题-11" class="headerlink" title="解题"></a>解题</h3><p>js 版</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var search = function(nums, target) &#123;</span><br><span class="line">  // 时间复杂度：O(logn)</span><br><span class="line">  // 空间复杂度：O(1)</span><br><span class="line">  // [6,7,8,1,2,3,4,5]</span><br><span class="line">  let start = 0;</span><br><span class="line">  let end = nums.length - 1;</span><br><span class="line"></span><br><span class="line">  while (start &lt;= end) &#123;</span><br><span class="line">    const mid = start + ((end - start) &gt;&gt; 1);</span><br><span class="line">    if (nums[mid] === target) return mid;</span><br><span class="line"></span><br><span class="line">    // [start, mid]有序</span><br><span class="line"></span><br><span class="line">    // ️⚠️注意这里的等号</span><br><span class="line">    if (nums[mid] &gt;= nums[start]) &#123;</span><br><span class="line">      //target 在 [start, mid] 之间</span><br><span class="line"></span><br><span class="line">      // 其实target不可能等于nums[mid]， 但是为了对称，我还是加上了等号</span><br><span class="line">      if (target &gt;= nums[start] &amp;&amp; target &lt;= nums[mid]) &#123;</span><br><span class="line">        end = mid - 1;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        //target 不在 [start, mid] 之间</span><br><span class="line">        start = mid + 1;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // [mid, end]有序</span><br><span class="line"></span><br><span class="line">      // target 在 [mid, end] 之间</span><br><span class="line">      if (target &gt;= nums[mid] &amp;&amp; target &lt;= nums[end]) &#123;</span><br><span class="line">        start = mid + 1;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        // target 不在 [mid, end] 之间</span><br><span class="line">        end = mid - 1;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return -1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h2 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a>无重复字符的最长子串</h2><blockquote>
<p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure>

<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure>

<p>示例 4：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;&quot;</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h3><p>这道题是说，找到不重复的字串，也就是说遇到重复的，前面都要抛弃，返回不重复子串的长度</p>
<p>譬如说，<code>abcddace</code>，不重复子串，<code>abcd</code>，遇到 <code>d</code> 时，就要删除 <code>d</code> 以及 <code>d</code> 前面的，重新计算。</p>
<h3 id="解题-12"><a href="#解题-12" class="headerlink" title="解题"></a>解题</h3><p>js 版</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;string&#125; s</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">var lengthOfLongestSubstring = function(s) &#123;</span><br><span class="line">    let arr = [], max = 0</span><br><span class="line">    for(let i = 0; i &lt; s.length; i++) &#123;</span><br><span class="line">        const index = arr.indexOf(s[i])</span><br><span class="line">        if (~index) &#123; // ~-1 = 0</span><br><span class="line">            arr.splice(0, index + 1)</span><br><span class="line">        &#125;</span><br><span class="line">        arr.push(s[i])</span><br><span class="line">        max = Math.max(max, arr.length)</span><br><span class="line">    &#125;</span><br><span class="line">    return max</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h2 id="下一个排列"><a href="#下一个排列" class="headerlink" title="下一个排列"></a>下一个排列</h2><blockquote>
<p>实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列（即，组合出下一个更大的整数）。</p>
<p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p>
<p>必须 原地 修改，只允许使用额外常数空间。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[1,3,2]</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,2,1]</span><br><span class="line">输出：[1,2,3]</span><br></pre></td></tr></table></figure>

<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,1,5]</span><br><span class="line">输出：[1,5,1]</span><br></pre></td></tr></table></figure>

<p>示例 4：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h3><p>这道题比较难一点，理解题意也就是说你要找到这组数的下一个排序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/// 譬如说给到数组为[1,2,3]，它的递增逻辑如下</span><br><span class="line">123</span><br><span class="line">132</span><br><span class="line">213</span><br><span class="line">231</span><br><span class="line">312</span><br><span class="line">321</span><br><span class="line"></span><br><span class="line">123456</span><br><span class="line">123465</span><br><span class="line">123546</span><br><span class="line">...</span><br><span class="line">654321</span><br></pre></td></tr></table></figure>

<ul>
<li><p>从数据排列上来看，是个升序的</p>
</li>
<li><p>我们希望下一个数<strong>要比当前数大</strong>，说明位数要从后往前找，也就是说 nums[i]  &gt; nums[i+1]</p>
</li>
<li><p>希望下一个数<strong>增加的幅度尽可能的小</strong>，这样才满足“下一个排列与当前排列紧邻“的要求</p>
<ul>
<li><p>要<strong>尽可能靠右的低位</strong>进行交换，需要从后向前查找。</p>
</li>
<li><p>将一个 <strong>尽可能小的「大数」</strong> 与前面的「小数」交换。比如 <code>123465</code>，下一个排列应该把 <code>5</code> 和 <code>4</code> 交换而不是把 <code>6</code> 和 <code>4</code> 交换</p>
</li>
<li><p>将「大数」换到前面后，需要将「大数」后面的所有数重置为升序，升序排列就是最小的排列。以 123465 为例：首先按照上一步，交换 5 和 4，得到 123564；然后需要将 5 之后的数重置为升序，得到 123546。显然 123546 比 123564 更小，123546 就是 123465 的下一个排列</p>
</li>
</ul>
</li>
</ul>
<p>因此，算法可以这样设计</p>
<ul>
<li><p><strong>从后向前</strong>查找第一个<strong>相邻升序</strong>的元素对 <code>(i,j)</code>，满足 <code>A[i] &lt; A[j]</code>。此时 <code>[j,end)</code> 必然是降序</p>
</li>
<li><p>在 <code>[j,end)</code> <strong>从后向前</strong>查找第一个满足 <code>A[i] &lt; A[k]</code> 的 <code>k</code>。<code>A[i]</code>、<code>A[k]</code> 分别就是上文所说的「小数」、「大数」</p>
</li>
<li><p>将 <code>A[i]</code> 与 <code>A[k]</code> 交换</p>
</li>
<li><p>可以断定这时 <code>[j,end)</code> 必然是降序，逆置 <code>[j,end)</code>，使其升序</p>
</li>
<li><p>如果在步骤 1 找不到符合的相邻元素对，说明当前 <code>[begin,end)</code> 为一个降序顺序，则直接跳到步骤 4</p>
</li>
</ul>
<h3 id="解题-13"><a href="#解题-13" class="headerlink" title="解题"></a>解题</h3><p>js 版</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number[]&#125; nums</span><br><span class="line"> * @return &#123;void&#125; Do not return anything, modify nums in-place instead.</span><br><span class="line"> */</span><br><span class="line">var nextPermutation = function(nums) &#123;</span><br><span class="line">   let i = nums.length - 2</span><br><span class="line">   while(i &gt;= 0 &amp;&amp; nums[i] &gt;= nums[i + 1]) &#123;</span><br><span class="line">       i --</span><br><span class="line">   &#125;</span><br><span class="line">   if(i &gt;= 0) &#123;</span><br><span class="line">       let j = nums.length - 1</span><br><span class="line">       while(j &gt;= 0 &amp;&amp; nums[j] &lt;= nums[i]) &#123;</span><br><span class="line">           j--</span><br><span class="line">       &#125;</span><br><span class="line">       [nums[i], nums[j]]=[nums[j], nums[i]]</span><br><span class="line">   &#125;</span><br><span class="line">   let l = i + 1</span><br><span class="line">   let r = nums.length - 1</span><br><span class="line">   while(l &lt; r) &#123;</span><br><span class="line">       [nums[l], nums[r]] = [nums[r], nums[l]]</span><br><span class="line">       l++</span><br><span class="line">       r--</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h2 id="杨辉三角"><a href="#杨辉三角" class="headerlink" title="杨辉三角"></a>杨辉三角</h2><blockquote>
<p>给定一个非负整数 <em><code>numRows</code>，</em>生成「杨辉三角」的前 <em><code>numRows</code></em> 行。</p>
<p>在「杨辉三角」中，每个数是它左上方和右上方的数的和。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: numRows = 5</span><br><span class="line">输出: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: numRows = 1</span><br><span class="line">输出: [[1]]</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="思路-13"><a href="#思路-13" class="headerlink" title="思路"></a>思路</h3><p>第三行开始就有规律了，第三行数等于上一行之间相加，最后再加个 1</p>
<h3 id="解题-14"><a href="#解题-14" class="headerlink" title="解题"></a>解题</h3><p>js 版</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number&#125; numRows</span><br><span class="line"> * @return &#123;number[][]&#125;</span><br><span class="line"> */</span><br><span class="line">var generate = function (numRows) &#123;</span><br><span class="line">  if (numRows &lt; 1) return []</span><br><span class="line">  if (numRows === 1) return [[1]]</span><br><span class="line">  if (numRows === 2) return [[1], [1, 1]]</span><br><span class="line">  const res = [[1], [1, 1]]</span><br><span class="line">  for (let i = 2; i &lt; numRows; i++) &#123;</span><br><span class="line">    const v = res[res.length - 1]</span><br><span class="line">    const v1 = [1]</span><br><span class="line">    for (let j = 1; j &lt; v.length; j++) &#123;</span><br><span class="line">      v1.push(v[j] + v[j - 1])</span><br><span class="line">    &#125;</span><br><span class="line">    v1.push(1)</span><br><span class="line">    res.push(v1)</span><br><span class="line">  &#125;</span><br><span class="line">  return res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="变型"><a href="#变型" class="headerlink" title="变型"></a>变型</h3><blockquote>
<p>给定一个非负索引 <code>rowIndex</code>，返回「杨辉三角」的第 <code>rowIndex</code> 行。</p>
<p>示例1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: rowIndex = 3</span><br><span class="line">输出: [1,3,3,1]</span><br></pre></td></tr></table></figure>

<p>示例2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: rowIndex = 0</span><br><span class="line">输出: [1]</span><br></pre></td></tr></table></figure>

<p>示例3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: rowIndex = 1</span><br><span class="line">输出: [1,1]</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="思路-14"><a href="#思路-14" class="headerlink" title="思路"></a>思路</h4><p>创建一个数组，从最顶层逐级往下累加，最终计算出该行数的值。因为杨辉三角，每个数是它左上方和右上方的数的和。</p>
<h4 id="解题-15"><a href="#解题-15" class="headerlink" title="解题"></a>解题</h4><p>js 版</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var getRow = (rowIndex) =&gt; &#123;</span><br><span class="line">	const row = new Array(rowIndex + 1).fill(0);</span><br><span class="line">	row[0] = 1;</span><br><span class="line">	for(let i = 1; i &lt;= rowIndex; ++i) &#123;</span><br><span class="line">		for(let j = i; j &gt; 0; --j) &#123;</span><br><span class="line">			row[j] += row[j - 1]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return row;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>，在上述代码中，<code>++i</code> 是先累加后赋值，在 <code>for</code> 循环中和 <code>i++</code> 是一样的，因为 <code>for</code> 是先判断，再改变 <code>i</code> 的，但放在 <code>while</code> 中就有出入了。</p>
<h2 id="有效的括号"><a href="#有效的括号" class="headerlink" title="有效的括号"></a>有效的括号</h2><blockquote>
<p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<ol>
<li>左括号必须用相同类型的右括号闭合。</li>
<li>左括号必须以正确的顺序闭合。</li>
</ol>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;()&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;()[]&#123;&#125;&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;(]&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p>示例 4：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;([)]&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p>示例 5：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;&#123;[]&#125;&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="思路-15"><a href="#思路-15" class="headerlink" title="思路"></a>思路</h3><ul>
<li><p><code>s</code> 一定是偶数，奇数是不可能匹配的，因此直接返回 <code>false</code></p>
</li>
<li><p>创建一个 <code>map</code> ，对象依依映射</p>
</li>
<li><p>通过 <code>obj[i]</code> 可以将左括号放在 <code>stack</code> 中</p>
</li>
<li><p>如果是右括号，通过出栈的方式去匹配，匹配不上返回 <code>false</code></p>
</li>
</ul>
<h3 id="解题-16"><a href="#解题-16" class="headerlink" title="解题"></a>解题</h3><p>js 版</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;string&#125; s</span><br><span class="line"> * @return &#123;boolean&#125;</span><br><span class="line"> */</span><br><span class="line">var isValid = function(s) &#123;</span><br><span class="line">    if (s % 2 === 1) &#123;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line">    const obj = &#123;&#x27;)&#x27;:&#x27;(&#x27;, &#x27;]&#x27;:&#x27;[&#x27;, &#x27;&#125;&#x27;:&#x27;&#123;&#x27;&#125;;</span><br><span class="line">    const stack = []</span><br><span class="line">    for (let i of s) &#123;</span><br><span class="line">        if (obj[i]) &#123;</span><br><span class="line">            if (stack.pop() !== obj[i]) return false</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            stack.push(i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return stack.length === 0</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h2 id="有效的数独"><a href="#有效的数独" class="headerlink" title="有效的数独"></a>有效的数独</h2><blockquote>
<p>请你判断一个 9 x 9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。</p>
<p>数字 1-9 在每一行只能出现一次。<br>数字 1-9 在每一列只能出现一次。<br>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）</p>
<p>示例图</p>
<p>5，3，’.’，’.’，7，’.’，’.’，’.’，’.’</p>
<p>6，’.’，’.’，1，9，5，’.’，’.’，’.’</p>
<p>‘.’，9，8，’.’，’.’，’.’，’.’，6，’.’</p>
<p>8，’.’，’.’，’.’，6，’.’，’.’，’.’，3</p>
<p>4，’.’，’.’，8，’.’，3，’.’，’.’，1</p>
<p>7，’.’，’.’，’.’，2，’.’，’.’，’.’，6</p>
<p>‘.’，’.’，’.’，’.’，’.’，’.’，’.’，’.’，’.’</p>
<p>‘.’，’.’，’.’，’.’，’.’，’.’，’.’，’.’，’.’</p>
<p>‘.’，’.’，’.’，’.’，’.’，’.’，’.’，’.’，’.’</p>
<p><strong>注意：</strong></p>
<ul>
<li>一个有效的数独（部分已被填充）不一定是可解的。</li>
<li>只需要根据以上规则，验证已经填入的数字是否有效即可。</li>
<li>空白格用 <code>&#39;.&#39;</code> 表示。</li>
</ul>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：board = </span><br><span class="line">[[&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;]</span><br><span class="line">,[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;]</span><br><span class="line">,[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：board = </span><br><span class="line">[[&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;]</span><br><span class="line">,[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;]</span><br><span class="line">,[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]</span><br><span class="line">输出：false</span><br><span class="line">解释：除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="思路-16"><a href="#思路-16" class="headerlink" title="思路"></a>思路</h3><p>这道题只是去搜索，看是否有重复项，循环二维数组遍历即可</p>
<p>创建 <code>3</code> 个数组，分别记录行坐标，列坐标，子数独，看是否有重复</p>
<ul>
<li><p>通过 <code>i</code> 和 <code>j</code> 可以计算出当前块的数字，</p>
</li>
<li><p><code>const boxIndex = parseInt(i / 3) * 3 + parseInt(j / 3)</code> 是这次解题的关键，我们看看如何实现的从示例图中，我们可以将大的数独，分解成 9 个子数独，所以，boxIndex 其实计算的是 <code>0 ~ 9</code>。</p>
<p><code>i / 3</code> 是指从行的角度 <code>012</code> 属于 <code>0</code>，<code>345</code> 属于 <code>1</code>，<code>678</code> 属于 <code>2</code>，同理 <code>j / 3</code> ，因此问题变成了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	0 1 2</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">如何计算出 </span><br><span class="line">0 1 2</span><br><span class="line">3 4 5</span><br><span class="line">6 7 8</span><br></pre></td></tr></table></figure>

<p>因此得出 <code>(x * 3) + y</code></p>
</li>
</ul>
<h3 id="解题-17"><a href="#解题-17" class="headerlink" title="解题"></a>解题</h3><p>js 版</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;character[][]&#125; board</span><br><span class="line"> * @return &#123;boolean&#125;</span><br><span class="line"> */</span><br><span class="line">var isValidSudoku = function(board) &#123;</span><br><span class="line">    const [rows, columns, boxes] = [&#123;&#125;, &#123;&#125;, &#123;&#125;]</span><br><span class="line">    for(let i = 0; i &lt; board.length; i++) &#123;</span><br><span class="line">        for(let j = 0; j &lt; board[i].length; j++) &#123;</span><br><span class="line">            const num = board[i][j]</span><br><span class="line">            if(num !== &#x27;.&#x27;) &#123;</span><br><span class="line">                const boxIndex = parseInt(i / 3) * 3 + parseInt(j / 3);</span><br><span class="line">                if (rows[i + &#x27;-&#x27; + num] || columns[j + &#x27;-&#x27; + num] || boxes[boxIndex + &#x27;-&#x27; + num]) &#123;</span><br><span class="line">                    return false</span><br><span class="line">                &#125;</span><br><span class="line">                 // 三个方向上每个位置，将当前数做标记，表示出现过了</span><br><span class="line">                rows[i + &#x27;-&#x27; + num] = true;</span><br><span class="line">                columns[j + &#x27;-&#x27; + num] = true;</span><br><span class="line">                boxes[boxIndex + &#x27;-&#x27; + num] = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h2 id="在排序数组中查找元素的第一个和最后一个位置"><a href="#在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="在排序数组中查找元素的第一个和最后一个位置"></a>在排序数组中查找元素的第一个和最后一个位置</h2><blockquote>
<p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p>
<p>如果数组中不存在目标值 target，返回 [-1, -1]。</p>
<p>进阶：</p>
<p>你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [5,7,7,8,8,10], target = 8</span><br><span class="line">输出：[3,4]</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [5,7,7,8,8,10], target = 6</span><br><span class="line">输出：[-1,-1]</span><br></pre></td></tr></table></figure>

<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [], target = 0</span><br><span class="line">输出：[-1,-1]</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="思路-17"><a href="#思路-17" class="headerlink" title="思路"></a>思路</h3><p>要想时间复杂度为 <code>O(logn)</code>，也就是让我们用二分查找，通过二分查找，先找到 <code>mid</code> 值，通过循环 <code>target</code> 与 <code>mid</code> 之间的关系，最终找到 <code>target</code> 所在的位置，在位置附近，再去找到范围边界。</p>
<h3 id="解题-18"><a href="#解题-18" class="headerlink" title="解题"></a>解题</h3><p>js 版</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number[]&#125; nums</span><br><span class="line"> * @param &#123;number&#125; target</span><br><span class="line"> * @return &#123;number[]&#125;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">var searchRange = function(nums, target) &#123;</span><br><span class="line">	let left = 0, right = nums.length - 1, mid;</span><br><span class="line">	while(left &lt;= right) &#123;</span><br><span class="line">		mid = (left + right) &gt;&gt; 1</span><br><span class="line">		if (nums[mid] === target) break; // 说明找到了</span><br><span class="line">		if (nums[mid] &gt; target) &#123;</span><br><span class="line">			right = mid - 1</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			left = mid + 1</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if(left &gt; right) return [-1, -1];</span><br><span class="line">	let i = mid, j = mid</span><br><span class="line">	while(nums[i] === nums[i-1]) i--</span><br><span class="line">	while(nums[j] === nums[j+1]) j++</span><br><span class="line">	return [i,j]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="整数转罗马数字"><a href="#整数转罗马数字" class="headerlink" title="整数转罗马数字"></a>整数转罗马数字</h2><blockquote>
<p>罗马数字包含以下七种字符： <code>I</code>， <code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">字符          数值</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure>

<p>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p>
<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p>
<ul>
<li>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。</li>
<li>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 </li>
<li>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</li>
</ul>
<p>给你一个整数，将其转为罗马数字。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: num = 3</span><br><span class="line">输出: &quot;III&quot;</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: num = 4</span><br><span class="line">输出: &quot;IV&quot;</span><br></pre></td></tr></table></figure>

<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: num = 9</span><br><span class="line">输出: &quot;IX&quot;</span><br></pre></td></tr></table></figure>
<p>示例 4： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: num = 58</span><br><span class="line">输出: &quot;LVIII&quot;</span><br><span class="line">解释: L = 50, V = 5, III = 3</span><br></pre></td></tr></table></figure>
<p>示例 5： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: num = 1994</span><br><span class="line">输出: &quot;MCMXCIV&quot;</span><br><span class="line">解释: M = 1000, CM = 900, XC = 90, IV = 4</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="思路-18"><a href="#思路-18" class="headerlink" title="思路"></a>思路</h3><p>通过 <code>map</code> 把所有可能出现的组合都列出来，从大往下去减，关键在于 <code>i++</code> 和 <code>i--</code>， <code>num / Number(str[i])</code> 大于 <code>1</code> 情况下，说明有这个数，要让它加回去，因为有可能遇到多个千位数或百位数这种情况，否则自减 <code>1</code>。</p>
<h3 id="解题-19"><a href="#解题-19" class="headerlink" title="解题"></a>解题</h3><p>js 版</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number&#125; num</span><br><span class="line"> * @return &#123;string&#125;</span><br><span class="line"> */</span><br><span class="line">var intToRoman = function(num) &#123;</span><br><span class="line">    const numToString = &#123;</span><br><span class="line">        1: &#x27;I&#x27;,</span><br><span class="line">        4: &#x27;IV&#x27;,</span><br><span class="line">        5: &#x27;V&#x27;,</span><br><span class="line">        9: &#x27;IX&#x27;,</span><br><span class="line">        10: &#x27;X&#x27;,</span><br><span class="line">        40: &#x27;XL&#x27;,</span><br><span class="line">        50: &#x27;L&#x27;,</span><br><span class="line">        90: &#x27;XC&#x27;,</span><br><span class="line">        100: &#x27;C&#x27;,</span><br><span class="line">        400: &#x27;CD&#x27;,</span><br><span class="line">        500: &#x27;D&#x27;,</span><br><span class="line">        900: &#x27;CM&#x27;,</span><br><span class="line">        1000: &#x27;M&#x27;,</span><br><span class="line">   &#125;</span><br><span class="line">   let result = &#x27;&#x27;</span><br><span class="line">   const str = Object.keys(numToString)</span><br><span class="line">   for (let i = str.length &gt; 0; i&gt;=0; i--) &#123;</span><br><span class="line">   	if(num / Number(str[i]) &gt;=1) &#123;</span><br><span class="line">   		result += numToString[str[i]]</span><br><span class="line">   		num -= Number(str[i])</span><br><span class="line">   		i++</span><br><span class="line">   	&#125;</span><br><span class="line">   	if(num === 0) &#123;</span><br><span class="line">   		break</span><br><span class="line">   	&#125;</span><br><span class="line">   &#125;</span><br><span class="line">   return result</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="类似题"><a href="#类似题" class="headerlink" title="类似题"></a>类似题</h3><h4 id="罗马数字转整数"><a href="#罗马数字转整数" class="headerlink" title="罗马数字转整数"></a>罗马数字转整数</h4><blockquote>
<p>罗马数字包含以下七种字符: <code>I</code>， <code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">字符          数值</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure>

<p>例如， 罗马数字 2 写做 II ，即为两个并列的 1 。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p>
<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p>
<p>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。<br>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>给定一个罗马数字，将其转换成整数。</p>
<p>示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;III&quot;</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;IV&quot;</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>


<p>示例 3:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;IX&quot;</span><br><span class="line">输出: 9</span><br></pre></td></tr></table></figure>

<p>示例 4:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;LVIII&quot;</span><br><span class="line">输出: 58</span><br><span class="line">解释: L = 50, V= 5, III = 3.</span><br></pre></td></tr></table></figure>

<p>示例 5:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;MCMXCIV&quot;</span><br><span class="line">输出: 1994</span><br><span class="line">解释: M = 1000, CM = 900, XC = 90, IV = 4.</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="思路-19"><a href="#思路-19" class="headerlink" title="思路"></a>思路</h4><p>从大范围往小范围搜索，因为它最多匹配两个，因此 <code>numToString[s.substring(i, i+2)]</code> 来识别是否满足需求，如果满足则加上去，否则缩小范围找</p>
<h4 id="解题-20"><a href="#解题-20" class="headerlink" title="解题"></a>解题</h4><p>js 版</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;string&#125; s</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">var romanToInt = function(s) &#123;</span><br><span class="line">    const numToString = &#123;</span><br><span class="line">        &#x27;I&#x27;: 1,</span><br><span class="line">        &#x27;IV&#x27;: 4,</span><br><span class="line">        &#x27;V&#x27;: 5,</span><br><span class="line">        &#x27;IX&#x27;: 9,</span><br><span class="line">        &#x27;X&#x27;: 10,</span><br><span class="line">        &#x27;XL&#x27;: 40,</span><br><span class="line">        &#x27;L&#x27;: 50,</span><br><span class="line">        &#x27;XC&#x27;: 90,</span><br><span class="line">        &#x27;C&#x27;: 100,</span><br><span class="line">        &#x27;CD&#x27;: 400,</span><br><span class="line">        &#x27;D&#x27;: 500,</span><br><span class="line">        &#x27;CM&#x27;: 900,</span><br><span class="line">        &#x27;M&#x27;: 1000,</span><br><span class="line">   &#125;</span><br><span class="line">   let res = 0</span><br><span class="line">   for(let i = 0; i &lt; s.length;) &#123;</span><br><span class="line">       if (i + 1 &lt; s.length &amp;&amp; numToString[s.substring(i, i+2)]) &#123;</span><br><span class="line">           res += numToString[s.substring(i, i+2)]</span><br><span class="line">           i += 2</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           res += numToString[s.substring(i, i+1)]</span><br><span class="line">           i++</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   return res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h2 id="最长公共前缀"><a href="#最长公共前缀" class="headerlink" title="最长公共前缀"></a>最长公共前缀</h2><blockquote>
<p>编写一个函数来查找字符串数组中的最长公共前缀。</p>
<p>如果不存在公共前缀，返回空字符串 <code>&quot;&quot;</code>。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：strs = [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">输出：&quot;fl&quot;</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：strs = [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line">输出：&quot;&quot;</span><br><span class="line">解释：输入不存在公共前缀。</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="思路-20"><a href="#思路-20" class="headerlink" title="思路"></a>思路</h3><ul>
<li><p>当字符串数组长度为 0 时则公共前缀为空，直接返回</p>
</li>
<li><p>既然是公共前缀，任何一个子串都会存在，因此我们就取第一个， <code>strs[0]</code></p>
</li>
<li><p>通过两个 <code>for</code> 循环去比较，内层 <code>for</code> 循环逐个判断，是否相等，不等就退出，逐渐缩小范围</p>
</li>
<li><p>如果查找过程中出现了 ans 为空的情况，则公共前缀不存在直接返回</p>
</li>
</ul>
<h3 id="解题-21"><a href="#解题-21" class="headerlink" title="解题"></a>解题</h3><p>js 版</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;string[]&#125; strs</span><br><span class="line"> * @return &#123;string&#125;</span><br><span class="line"> */</span><br><span class="line">var longestCommonPrefix = function(strs) &#123;</span><br><span class="line">    if(strs.length === 0) &#123;</span><br><span class="line">        return &#x27;&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">    let ans = strs[0]</span><br><span class="line">    for(let i = 1; i &lt; strs.length; i++)&#123;</span><br><span class="line">        let j = 0</span><br><span class="line">        for(; j &lt; ans.length&amp;&amp;j &lt; strs[i].length; j++)&#123;</span><br><span class="line">            if (ans[j] != strs[i][j])&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = ans.substr(0, j)</span><br><span class="line">        if (ans === &quot;&quot;)&#123;</span><br><span class="line">            return ans</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h2 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h2><blockquote>
<p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;babad&quot;</span><br><span class="line">输出：&quot;bab&quot;</span><br><span class="line">解释：&quot;aba&quot; 同样是符合题意的答案。</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;cbbd&quot;</span><br><span class="line">输出：&quot;bb&quot;</span><br></pre></td></tr></table></figure>

<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;a&quot;</span><br><span class="line">输出：&quot;a&quot;</span><br></pre></td></tr></table></figure>

<p>示例 4： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;ac&quot;</span><br><span class="line">输出：&quot;a&quot;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="思路-21"><a href="#思路-21" class="headerlink" title="思路"></a>思路</h3><p>最长回文的匹配原则就是左右两个数相等，分两种情况，奇数或偶数，对于一个数组，你并不知道它是奇数匹配还是偶数匹配，因此，通过 <code>for</code> 循环逐个查找，在 <code>while</code> 中，通过 <code>l</code> 和 <code>r</code> 双指针”左右开弓”去查找，如果左右的数字是一样的，那么继续，否则就返回了。</p>
<p>至于为什么 <code>l + 1</code> 因为减去后才不相等，所以相等就是加上去。 </p>
<h3 id="解题-22"><a href="#解题-22" class="headerlink" title="解题"></a>解题</h3><p>js 版</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;string&#125; s</span><br><span class="line"> * @return &#123;string&#125;</span><br><span class="line"> */</span><br><span class="line">var longestPalindrome = function(s) &#123;</span><br><span class="line">    const getResult = (s, l ,r) =&gt; &#123;</span><br><span class="line">        while(l &gt;= 0 &amp;&amp; r &lt; s.length &amp;&amp; s[l] === s[r]) &#123;</span><br><span class="line">            l--</span><br><span class="line">            r++</span><br><span class="line">        &#125;</span><br><span class="line">        return s.substr(l + 1, r - l - 1)</span><br><span class="line">    &#125;</span><br><span class="line">    let res = &#x27;&#x27;</span><br><span class="line">    for (let i = 0; i &lt; s.length; i++) &#123;</span><br><span class="line">        const s1 = getResult(s, i, i) // 奇数匹配</span><br><span class="line">        const s2 = getResult(s, i, i+1) // 偶数匹配</span><br><span class="line">        res = res.length &gt; s1.length ? res : s1</span><br><span class="line">        res = res.length &gt; s2.length ? res : s2</span><br><span class="line">    &#125;</span><br><span class="line">    return res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>algorithms</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>受控组件和非受控组件</title>
    <url>/2022/02/26/frontEnd/%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6%E5%92%8C%E9%9D%9E%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<p><img src="/2022/02/26/frontEnd/%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6%E5%92%8C%E9%9D%9E%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6/image-20220226224911608.png" alt="image-20220226224911608"></p>
<blockquote>
<p>在前端学习生涯中，你总会绕不开一个概念，受控组件和非受控组件，这到底是什么呢？这一讲，我们来好好聊聊这个话题。</p>
</blockquote>
<span id="more"></span>

<p>不要觉得这两概念很高大上，按照字面意思理解就行，顾名思义</p>
<ul>
<li>受控组件：受 <code>xxx</code> 控制的组件</li>
<li>非受控组件，不受 <code>xxx</code> 控制的组件</li>
</ul>
<p>我们现在只要了解 <code>xxx</code> 是谁就行了</p>
<p>带着这个疑问，我们猜一下，<code>xxx</code> 能是谁呢？凭借你们朴素的情感，和明锐的逻辑，那个更合理呢？代码、用户、状态。</p>
<p>很明显，<strong>状态</strong>更加合理，毕竟 <code>vue</code> 和 <code>react</code> 框架都有一个词，<code>state</code> 。</p>
<p>好，我们现在知道了，<strong>受控组件，就是受状态控制的组件，非受控组件，就是不受状态控制的组件</strong>。在基础组件中，有个值叫 <code>value</code>， 通过它可以控制组件的状态。</p>
<p>举个例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const Comp = () =&gt; &#123;</span><br><span class="line">	const [state, setState] = useState(&#x27;张三&#x27;)</span><br><span class="line">	return (</span><br><span class="line">		&lt;&gt;</span><br><span class="line">			&lt;input value=&#123;state&#125; /&gt; // 这就是受控组件</span><br><span class="line">			&lt;input /&gt; // 这是非受控组件</span><br><span class="line">		&lt;/&gt;</span><br><span class="line">	)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于前者，无论我们输入任何东西，都不会改变输入框的内容，它用于是”张三“，因为被控制了，对于后者，我们可以输入任意的值。</p>
<p><strong>状态</strong></p>
<p>这里要说明下，有内部状态和外部状态，在 <code>HTML</code> 表单元素中，内部会维护一套 <code>state</code> 状态，拿 <code>&lt;input /&gt;</code> 组件为例，值的改变会导致状态的改变，从而触发各种事件，<code>onChange</code> 呀之类的，而元素中有个属性叫 <code>value</code>，它能够接收外部的状态，从而控制内部的状态，因此受控组件和非受控组件，也可以理解为<strong>受外部状态控制的组件叫受控组件，不受外部状态控制的组件叫非受控组件。</strong></p>
<p>没错，概念已经结束了，我们了解了什么是受控组件什么是非受控组件，剩下的就是如何正确的在不同场景下使用不同的组件了。如果是场景简单，只是提交，非受控组件是可以的，打比方，内容搜索，如果是场景复杂多变，又要发起第三方请求，又要校验，还是老老实实用受控组件吧。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>表单解决方案react-hook-form</title>
    <url>/2022/01/16/frontEnd/%E8%A1%A8%E5%8D%95%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88react-hook-form/</url>
    <content><![CDATA[<p><img src="/2022/01/16/frontEnd/%E8%A1%A8%E5%8D%95%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88react-hook-form/image-20220226230706238.png" alt="image-20220226230706238"></p>
<blockquote>
<p>表单作为客户端向服务器端提交数据的主要载体，表单验证是避免提交的数据不合法的重要途径，而实时性的校验能够提升用户体验。为此市面上有很多表单校验解决方案，例如 <a href="https://v2.formilyjs.org/zh-CN">Formily</a>、<a href="https://react-hook-form.com/zh/get-started/">React Hook Form</a>，前者的学习成本有点高，功能也非常强大，后者是简化表单校验的一个基于非受控组件实现的 <code>React</code> 表单库，能够满足绝大部分的需求。</p>
</blockquote>
<span id="more"></span>

<p>非受控表单就不是使用 <code>state</code> 单向数据流来控制表单，它是通过 <code>ref</code> 来直接拿到表单组件，从而可以直接拿到表单的值，不需要对表单的值进行状态维护，这就使得<strong>非受控表单可以减少很多不必要的渲染</strong>。当然非受控表单也存在着它的问题，在动态校验、动态修改（联动）方面不是很方便，于是诞生了一个以非受控思想为基础的表单库 <a href="https://react-hook-form.com/">React-Hook-Form</a>，它可以帮助我们解决这些问题。还有一点好处就是基于非受控的组件，完全拥抱原生 HTML 标准。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install react-hook-form</span><br></pre></td></tr></table></figure>



<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p><code>React Hook Form</code> 的一个关键概念是将非受控组件<strong>注册</strong>到Hook中，从而在表单校验和提交时可以获取到它的值。为此该库要求<strong>每个表单项都需要唯一的 <code>name</code> 作为注册的键</strong>。</p>
<p><code>useForm</code> 作为 <code>react-hook-form</code> 的核心  <code>api</code> ，它提供了一系列最基础的方法，这里列举几个核心的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const &#123;</span><br><span class="line">	control，register, handleSubmit, formState: &#123; errors &#125;,</span><br><span class="line">&#125; = useForm()</span><br></pre></td></tr></table></figure>

<p>其中</p>
<ul>
<li>register：该方法允许您将输入组件/选择组件中的 <code>Ref</code> 和校验规则注册到 <code>React Hook Form</code> 中，主要针对<strong>非受控组件</strong>而言的。</li>
<li>control：针对  <code>&lt;Controller&gt;</code> 使用的，为 <code>React Hook Form</code> 的 <code>Controller</code> 组件提供的对象，包含了 <code>React Hook Form</code> 注册受控组件所需的方法。</li>
<li>handleSubmit：当表单校验成功触发</li>
<li>errors：错误处理</li>
</ul>
<p>所以，你要使用非受控组件，就用 <code>register</code>，如果你想要使用受控组件，那就用 <code>control</code>，通过 <strong>Controller</strong> 去包裹你的组件。</p>
<h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><p>注册有两种方式，受控和非受控</p>
<ul>
<li><p>非受控组件，使用 <code>register</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">register: (name: string, RegisterOptions?) =&gt; (&#123; onChange, onBlur, name, ref &#125;)</span><br></pre></td></tr></table></figure>

<p>该函数接收两个参数，<code>name</code> 和 <code>RegisterOptions</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">register(&#x27;name&#x27;)</span><br><span class="line">// output</span><br><span class="line">&#123;</span><br><span class="line">  name: &#x27;name&#x27;,</span><br><span class="line">  onBlur: async event =&gt; &#123;...&#125;,</span><br><span class="line">  onChange: async event =&gt; &#123;...&#125;,</span><br><span class="line">  ref: ref =&gt; &#123;...&#125;,</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>
<p>  使用：</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input &#123;...register(&quot;name&quot;)&#125; /&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>受控组件，使用 <code>control</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Controller</span><br><span class="line">	name=&quot;my-controller&quot;</span><br><span class="line">	control=&#123;control&#125;</span><br><span class="line">	render=&#123;(&#123; field &#125;) =&gt; &lt;Input &#123;...field&#125; /&gt;&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h3><p><code>form</code> 内要有个能触发 <code>javascript:form.submit()</code> 的方法，可以是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&#x27;submit&#x27; value=&#x27;登录&#x27;/&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;button type=&#x27;submit&#x27;&gt;登录&lt;/button&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div onclick=&quot;javascript: form.submit()&quot;&gt;</span><br><span class="line">	&lt;span&gt;提交&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>



<p>和原生的一样，用 <code>form</code> 包裹需要提交的表单</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const &#123; handleSubmit, control &#125; = useForm(&#123;</span><br><span class="line">   defaultValues: &#123;</span><br><span class="line">     input: &#x27;&#x27;,</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br><span class="line">const onSubmit = data =&gt; console.log(data);</span><br><span class="line">const onError = (errors, e) =&gt; console.log(errors, e);</span><br><span class="line"></span><br><span class="line">&lt;form onSubmit=&#123;handleSubmit(onSubmit, onError)&#125;&gt;</span><br><span class="line">	 &lt;Controller</span><br><span class="line">   		name=&quot;input&quot;</span><br><span class="line">   		control=&#123;control&#125;</span><br><span class="line">   		render=&#123;(&#123; field &#125;) =&gt; &lt;Input &#123;...field&#125; /&gt;&#125;</span><br><span class="line">   /&gt;</span><br><span class="line">   &lt;input type=&quot;submit&quot; /&gt; </span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>



<p>这里有两个方法 <code>handleSubmit</code> 和 <code>onSubmit</code></p>
<p><code>handleSubmit</code> 的官网解释是这样的</p>
<blockquote>
<p>This function will receive the form data if form validation is successful.</p>
</blockquote>
<p>翻译成人话就是，如果这个表单校验成功，那么就会触发 <code>onSubmit</code> 这个函数，也就是说，<code>onSubmit</code> 函数是 <code>form</code> 校验成功后，触发的，整个 <code>form</code> 的逻辑校验都被封装在了 <code>handleSubmit</code> 中。</p>
<h3 id="校验"><a href="#校验" class="headerlink" title="校验"></a>校验</h3><p>校验也有两种方法</p>
<h4 id="HTML原生"><a href="#HTML原生" class="headerlink" title="HTML原生"></a>HTML原生</h4><p>这种方法特点是简单，学习成本低，适用于比较简单基础的场景。</p>
<p>它的校验规则，全部基于 <code>HTML</code>，比如 <code>required</code>，<code>maxLength</code>，<code>pattern</code>等</p>
<p><strong>register 中</strong></p>
<ul>
<li><p>required</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input</span><br><span class="line">  &#123;...register(&quot;test&quot;, &#123;</span><br><span class="line">    required: true</span><br><span class="line">  &#125;)&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>maxLength</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input</span><br><span class="line">  &#123;...register(&quot;test&quot;, &#123;</span><br><span class="line">      maxLength: 2</span><br><span class="line">  &#125;)&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>pattern</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input</span><br><span class="line">  &#123;...register(&quot;test&quot;, &#123;</span><br><span class="line">    pattern: /[A-Za-z]&#123;3&#125;/</span><br><span class="line">  &#125;)&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>Controller 中</strong></p>
<p>放在 <code>rules</code> 中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Controller</span><br><span class="line">   name=&quot;checkbox&quot;</span><br><span class="line">   control=&#123;control&#125;</span><br><span class="line">   rules=&#123;&#123; required: true &#125;&#125;</span><br><span class="line">   render=&#123;(&#123; field &#125;) =&gt; &lt;Input &#123;...field&#125; /&gt;&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>

<p><a href="https://react-hook-form.com/api/useform/register">更多参考</a></p>
<h4 id="yup"><a href="#yup" class="headerlink" title="yup"></a>yup</h4><p>该方式比较强大，适用的场景比较多，需要点学习成本</p>
<p><strong>安装依赖</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yarn add yup @hookform/resolvers</span><br></pre></td></tr></table></figure>



<p><strong>引入依赖</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; yupResolver &#125; from &#x27;@hookform/resolvers/yup&#x27;;</span><br><span class="line">import * as yup from &#x27;yup&#x27;;</span><br></pre></td></tr></table></figure>



<p><strong>定义 schema</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const schema = yup.object().shape(&#123;</span><br><span class="line">  firstName: yup.string().required(),</span><br><span class="line">  lastName: yup.string().required(),</span><br><span class="line">  phone: yup.string().required(),</span><br><span class="line">  password: yup.string().required().min(8)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>注意，这里的 <code>key</code> 值对应的是 <code>register</code> 中的 <code>name</code></p>
<p>有了这个schema，就可以在创建表单的时候添加该验证规则了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const &#123;</span><br><span class="line">  register,</span><br><span class="line">  handleSubmit,</span><br><span class="line">  formState: &#123; errors &#125;,</span><br><span class="line">&#125; = useForm(&#123;</span><br><span class="line">  resolver: yupResolver(schema)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>yup</code> 的强大之处远不于此，它还能实现条件验证</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const schema = yup.object().shape(&#123;</span><br><span class="line">  firstName: yup.string().required(),</span><br><span class="line">  lastName: yup.string().required(),</span><br><span class="line">  showPhone: yup.boolean(),</span><br><span class="line">  phone: yup.string()</span><br><span class="line">  					.required(&quot;Please enter a valid number.&quot;)</span><br><span class="line">            .when(&quot;showPhone&quot;, &#123;</span><br><span class="line">              is: true,</span><br><span class="line">              then: yup.string().required(&quot;phone number must be provided.&quot;)</span><br><span class="line">            &#125;),</span><br><span class="line">  password: yup.string().required().min(8)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<p><strong>register 中</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input &#123;...register(&#x27;firstName&#x27;)&#125; /&gt;</span><br></pre></td></tr></table></figure>

<p>在 <code>useForm</code> 中使用 <code>resolver</code> 后，就不需要在 <code>register</code> 写 <code>RegisterOptions</code> 了。</p>
<p><strong>Controller 中</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Controller</span><br><span class="line">	name=&quot;firstName&quot;</span><br><span class="line">	control=&#123;control&#125;</span><br><span class="line">	render=&#123;(&#123; field &#125;) =&gt; &lt;Input placeholder=&quot;useName&quot; &#123;...field&#125; /&gt;&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>

<p>同理 <code>Controller</code> 也一样</p>
<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p><code>useForm</code> 会返回一个 <code>formState</code>，它有个 <code>errors</code>  字段，该字段包含 <code>yup</code> 中所有带 <code>required</code> 的 <code>key</code> 字段，如果有错误，它就会返回带有该字段的数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">errors: &#123;</span><br><span class="line">	xxx: &#123;</span><br><span class="line">		message: &#x27;&#x27;,</span><br><span class="line">		ref: React.ref,</span><br><span class="line">		type: &#x27;&#x27;,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过该字段是否存在，可以判断是否有错误信息，从而在组件中，显示错误提示。</p>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>了解了基础 <code>API</code>，我们来看下表单校验的几个场景</p>
<h3 id="基础校验"><a href="#基础校验" class="headerlink" title="基础校验"></a>基础校验</h3><p>用户登录，注册类的</p>
<p>这类很简单</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const schema = yup.object().shape(&#123;</span><br><span class="line">  name: yup.string().required(),</span><br><span class="line">&#125;)</span><br><span class="line">const &#123;</span><br><span class="line">	formState: &#123; errors &#125;,</span><br><span class="line">	control,</span><br><span class="line">	handleSubmit</span><br><span class="line">&#125; = useForm(&#123;</span><br><span class="line">	resolver: yupResolver(schema)</span><br><span class="line">&#125;)</span><br><span class="line">const onSubmit = data =&gt; console.log(data)</span><br><span class="line">&lt;form onSubmit=&#123;handleSubmit(onSubmit)&#125;&gt;</span><br><span class="line">	&lt;Controller</span><br><span class="line">  	name=&quot;name&quot;</span><br><span class="line">  	control=&#123;control&#125;</span><br><span class="line">  	render=&#123;(&#123; field &#125;) =&gt; &lt;Input</span><br><span class="line">  		placeholder=&quot;useName&quot;</span><br><span class="line">  		&#123;...field&#125;</span><br><span class="line">  		errors=&#123; !!(errors.name) &#125;</span><br><span class="line">  	/&gt;&#125;</span><br><span class="line">  /&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>





<h3 id="动态表单"><a href="#动态表单" class="headerlink" title="动态表单"></a>动态表单</h3><p><code>React-Hook-Form</code> 中的动态表单是通过 <code>useFieldArray</code> 实现的。</p>
<p>要注意，<code>useFieldArray</code>  返回的 <code>fields</code> 是一个不受控制的字段，<strong>这点很重要</strong>。这意味着它不会存储在全局的 <code>_formValues</code> 中，所以在使用 <code>useFieldArray</code> 遍历动态字段的时候，还需要我们自己对需要操作的数据进行一次注册操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const &#123; fields, append &#125; = useFieldArray(&#123;</span><br><span class="line">	control,</span><br><span class="line">	name: &#x27;itemName&#x27;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><code>useFieldArray</code> 接收一个对象</p>
<ul>
<li>name：表单项名称，它指代的是这个数组的名</li>
<li>control：通过 <code>useForm</code> 得到的对象</li>
</ul>
<p>使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const &#123; fields, append &#125; = useFieldArray(&#123;</span><br><span class="line">   control,</span><br><span class="line">   name: &quot;fruits&quot;,</span><br><span class="line">&#125;);</span><br><span class="line">&lt;form onSubmit=&#123;handleSubmit(onSubmit)&#125;&gt;</span><br><span class="line">  &lt;Grid container&gt;</span><br><span class="line">  	&#123;fields.map((item, index) =&gt; (</span><br><span class="line">  		&lt;Grid item xs=&#123;12&#125; key=&#123;item.id&#125;&gt;</span><br><span class="line">   			&lt;Controller</span><br><span class="line">    			render=&#123;(&#123; field &#125;) =&gt;  (</span><br><span class="line">    				&lt;TextField</span><br><span class="line">              size=&#x27;small&#x27;</span><br><span class="line">              label=&quot;你喜欢吃什么水果?&quot;</span><br><span class="line">              variant=&quot;standard&quot;</span><br><span class="line">              error=&#123;!!get(errors, `fruits.$&#123;index&#125;.name`.split(&#x27;.&#x27;))&#125;</span><br><span class="line">              helperText=&#123;get(errors, `fruits.$&#123;index&#125;.name.message`.split(&#x27;.&#x27;))&#125;</span><br><span class="line">    					&#123;...field&#125;</span><br><span class="line">    				/&gt;</span><br><span class="line">    			)&#125;</span><br><span class="line">  				name=&#123;`fruits.$&#123;index&#125;.name`&#125;</span><br><span class="line">  				control=&#123;control&#125;</span><br><span class="line">  			/&gt;</span><br><span class="line">  		&lt;/Grid&gt;</span><br><span class="line">     ))&#125;</span><br><span class="line">     &lt;Grid&gt;</span><br><span class="line">       &lt;Button</span><br><span class="line">       	onClick=&#123;() =&gt; &#123;</span><br><span class="line">       		append(&#123;</span><br><span class="line">       			name: &#x27;&#x27;,</span><br><span class="line">       		&#125;)</span><br><span class="line">       	&#125;&#125;</span><br><span class="line">       &gt;add&lt;/Button&gt;</span><br><span class="line">     &lt;/Grid&gt;</span><br><span class="line">     &lt;Grid&gt;</span><br><span class="line">       &lt;Button</span><br><span class="line">         type=&#x27;submit&#x27;</span><br><span class="line">       &gt;提交&lt;/Button&gt;</span><br><span class="line">     &lt;/Grid&gt;</span><br><span class="line">  &lt;/Grid&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>

<p>返回的 <code>fields</code> 是个动态数组，<code>append</code> 是一个方法，将单个/多个输入组件追加到表单项列表的末尾并聚焦。</p>
<p>动态表单在校验方面也有点区别，要用到 <code>yup</code> 的 <code>array</code> 方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const schema = yup.object().shape(&#123;</span><br><span class="line">  fruits: yup.array().of(</span><br><span class="line">    yup.object().shape(&#123;</span><br><span class="line">      name: yup.string().required(),</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h3 id="联动"><a href="#联动" class="headerlink" title="联动"></a>联动</h3><p><code>React-Hook-Form</code> 中的动态校验和联动是通过 <code>watch</code> 或性能更好的 <code>useWatch</code> 实现的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const getName = useWatch(&#123;</span><br><span class="line">	control,</span><br><span class="line">  name: &#x27;name&#x27;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><code>useWatch</code> 接收几个参数，其中 </p>
<ul>
<li><code>name</code> 是表单项名称</li>
<li><code>control</code> 是通过调用 <code>useForm</code> 得到的对象。</li>
</ul>
<p>在 <code>React-hook-form</code> 它的数据都是由库去管理的，我们只有在校验成功后 <code>handleSubmit</code> 中才能拿到，但联动是要实时知道选了那些值，因此，通过 <code>useWatch</code> 方式可以监听获得到相应的 <em>表单项</em> 名称。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const getSex = useWatch(&#123;</span><br><span class="line">  control,</span><br><span class="line">  name: &#x27;sex&#x27;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>form</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;form&gt;</span><br><span class="line">	&lt;Controller</span><br><span class="line">		control=&#123;control&#125;</span><br><span class="line">		name=&#x27;sex&#x27;</span><br><span class="line">		render=&#123;(&#123;field&#125;) =&gt; (</span><br><span class="line">			&lt;Select</span><br><span class="line">				label=&#x27;性别&#x27;</span><br><span class="line">				variant=&#x27;standard&#x27;</span><br><span class="line">				error=&#123;!!get(errors, [&#x27;sex&#x27;])&#125;</span><br><span class="line">				&#123;...field&#125;</span><br><span class="line">			&gt;</span><br><span class="line">				&lt;MenuItem value=&#123;&#x27;boy&#x27;&#125;&gt;男孩&lt;/MenuItem&gt;</span><br><span class="line">				&lt;MenuItem value=&#123;&#x27;girl&#x27;&#125;&gt;女孩&lt;/MenuItem&gt;</span><br><span class="line">			&lt;/Select&gt;</span><br><span class="line">		)&#125;</span><br><span class="line">	/&gt;</span><br><span class="line">	&#123;getSex === &#x27;boy&#x27; &amp;&amp; (</span><br><span class="line">		&lt;Controller</span><br><span class="line">			control=&#123;control&gt;</span><br><span class="line">			name=&#x27;age&#x27;</span><br><span class="line">			render=&#123;(&#123;field&#125;) =&gt; (</span><br><span class="line">				&lt;TextField</span><br><span class="line">					label=&#x27;年龄&#x27;</span><br><span class="line">					variant=&#x27;standard&#x27;</span><br><span class="line">        	error=&#123;!!get(errors, [&#x27;age&#x27;])&#125;</span><br><span class="line">        	helperText=&#123;get(errors, [&#x27;age&#x27;, &#x27;message&#x27;])&#125;</span><br><span class="line">        	&#123;...field&#125;</span><br><span class="line">				/&gt;</span><br><span class="line">			&#125;&#125;</span><br><span class="line">		/&gt;</span><br><span class="line">	)&#125;</span><br><span class="line">	&lt;input type=&#x27;submit&#x27;&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>

<p>schema</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cosnt schema = yup.object().shape(&#123;</span><br><span class="line">	sex: yup.string().required(),</span><br><span class="line">	age: yup.number().when(&#x27;sex&#x27;, &#123;</span><br><span class="line">		is: &#x27;boy&#x27;,</span><br><span class="line">		then: yup.string().required(&#x27;必填哟！&#x27;)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h3 id="跨层级通讯"><a href="#跨层级通讯" class="headerlink" title="跨层级通讯"></a>跨层级通讯</h3><p><code>React-hook-form</code> 的跨层级通讯原理是 <code>context</code>，因此和大多数 <code>context</code> 一样，最外层需要有个包裹层，这里用的是 <code>FormProvider</code>，它接收 <code>useForm</code> 的返回值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; useForm, FormProvider &#125; from &quot;react-hook-form&quot;;</span><br><span class="line">const methods = useForm();</span><br><span class="line"></span><br><span class="line">&lt;FormProvider &#123;...methods&#125;&gt;</span><br><span class="line">	...</span><br><span class="line">	&lt;input type=&#x27;submit&#x27; /&gt;</span><br><span class="line">&lt;/FormProvider&gt;</span><br></pre></td></tr></table></figure>

<p>各子项中通过 <code>useFormContext</code> 接收</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const &#123; control, formState: &#123; errors &#125;&#125; = useFormContext()</span><br><span class="line"></span><br><span class="line">&lt;Controller</span><br><span class="line">	control=&#123;control&#125;</span><br><span class="line">	name=&#x27;address&#x27;</span><br><span class="line">	render=((&#123;field&#125;) =&gt; (</span><br><span class="line">		&lt;TextField </span><br><span class="line">			label=&#x27;地址&#x27;</span><br><span class="line">			variant=&#x27;standard&#x27;</span><br><span class="line">      error=&#123;!!get(errors, [&#x27;address&#x27;])&#125;</span><br><span class="line">      helperText=&#123;get(errors, [&#x27;address&#x27;, &#x27;message&#x27;])&#125;</span><br><span class="line">      &#123;...field&#125;</span><br><span class="line">		/&gt;</span><br><span class="line">	))</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>

<p>schema</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const schema = yup.object().shape(&#123;</span><br><span class="line">  address: yup.string().required(&#x27;不能为空&#x27;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<p>跨层级通讯和普通的几乎一样，<code>useFormContext</code> 就是把父级的 <code>control</code> 等数据传承下来使用。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><code>React-hook-form</code> 是一个轻量级表单解决方案，它通过 <code>register</code> 或 <code>control</code> 注册组件，<code>useFieldArray</code> 实现动态表单，<code>useWatch</code> 实现表单联动，<code>useFormContext</code> 实现表单通讯，所有的验证规则通过 <code>yup</code> 来制定，并将验证后的数据存储在 <code>errors</code> 中。</p>
<p><a href="https://www.zhouzh.tech/posts/03c48bb0-54e1-11ec-813a-97cf46d0b736">学习 React-hook-form</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack迁移到 vite</title>
    <url>/2021/12/09/frontEnd/webpack%E8%BF%81%E7%A7%BB%E5%88%B0vite/</url>
    <content><![CDATA[<blockquote>
<p>React</p>
</blockquote>
<span id="more"></span>



<h3 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h3><p>在旧项目的 <code>package.json</code> 中添加 <code>vite</code> 包，如果不知道添加那些问题，自己通过👇🏻命令创建一个看看就知道了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm init vite@latest</span><br></pre></td></tr></table></figure>



<p>这里，我在 <code>package.json</code> 中加入了以下几行代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;script&quot;: &#123;</span><br><span class="line">		&quot;dev-vite&quot;: &quot;vite&quot;,</span><br><span class="line">    &quot;build-vite&quot;: &quot;tsc &amp;&amp; vite build&quot;,</span><br><span class="line">    &quot;serve-vite&quot;: &quot;vite preview&quot;,</span><br><span class="line">	&#125;</span><br><span class="line">	&quot;devDependencies&quot;: &#123;</span><br><span class="line">		&quot;@vitejs/plugin-react&quot;: &quot;^1.0.0&quot;,</span><br><span class="line">    &quot;vite&quot;: &quot;^2.6.4&quot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>然后执行 <code>npm install</code> 安装依赖</p>
<h3 id="增加配置文件"><a href="#增加配置文件" class="headerlink" title="增加配置文件"></a>增加配置文件</h3><p>当以命令行方式运行  <code>vite</code>  时，Vite 会自动解析<strong>项目根目录</strong>下名为 <code>vite.config.js</code> 的文件。</p>
<p>在开发期间 Vite 是一个服务器，而 <code>index.html</code> 是该 Vite 项目的入口文件，因此 <code>public</code> 中的 <code>index.html</code> 需要移到最外层，且删除  <code>index.html</code>  中的 <code>%PUBLIC_URL%</code> 占位符，因为 <code>index.html</code>  中的 URL 将被自动转换。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// vite.config.js</span><br><span class="line">import &#123; defineConfig &#125; from &#x27;vite&#x27;</span><br><span class="line">import react from &#x27;@vitejs/plugin-react&#x27;</span><br><span class="line"></span><br><span class="line">// https://vitejs.dev/config/</span><br><span class="line">export default defineConfig((&#123; command, mode &#125;) =&gt; &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    plugins: [react()],</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>运行 <code>npm run dev</code> 后出现报错</p>
<p><img src="/2021/12/09/frontEnd/webpack%E8%BF%81%E7%A7%BB%E5%88%B0vite/image-20211203113150906.png" alt="image-20211203113150906"></p>
<p>这是因为 <code>tsconfig.json</code> 文件中 <code>&quot;target&quot;: &quot;es5&quot;</code> 设置成了 <code>es5</code> ，要改成 <code>esnext</code></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈freeze, seal, preventExtensions</title>
    <url>/2021/11/11/frontEnd/%E6%B5%85%E8%B0%88freeze,seal,preventExtensions/</url>
    <content><![CDATA[<p><img src="/2021/11/11/frontEnd/%E6%B5%85%E8%B0%88freeze,seal,preventExtensions/image-20211113145712772.png" alt="image-20211113145712772"></p>
<span id="more"></span>

<blockquote>
<p>在 JS 中，有三种方法来控制对象的安全性</p>
</blockquote>
<ul>
<li>Object.freeze 冻结</li>
<li>Object.seal 密封</li>
<li>Object.preventExtensions 不可扩展</li>
</ul>
<p>每个对象被创建后都有几个默认的属性，分别是</p>
<ul>
<li><code>configurable</code>：用于控制该对象是否可操作，包括增，删，改，默认 <code>false</code>。</li>
<li><code>enumerable</code>：可枚举，用来控制所描述的属性，是否将被包括在for…in循环之中。具体来说，如果一个属性的enumerable为false，<code> for..in循环</code>，<code>Object.keys方法</code>，<code>JSON.stringify方法</code>这三个操作不会取到该属性。</li>
<li><code>value</code>：与属性关联的值。可以是任何有效的JavaScript值（数字，对象，函数等）默认为：undefined。</li>
<li><code>writable</code>：属性的值是否可以被重写。设置为true可以被重写；设置为false，不能被重写，默认为false。</li>
<li><code>get</code>：方法来的，当读取这个对象值时，会调用这个方法。</li>
<li><code>set</code>：方法来的，当设置这个对象值时，会调用这个方法。</li>
</ul>
<h3 id="Object-freeze"><a href="#Object-freeze" class="headerlink" title="Object.freeze()"></a>Object.freeze()</h3><p>Object.freeze() 方法指冻结一个对象，被冻结的对象既不能修改，也不能添加新属性，删除已有属性也是不可以的。</p>
<p>被冻结的对象，原型修改也是不行的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let test = &#123; prop: 1 &#125;</span><br><span class="line">Object.freeze(test)</span><br><span class="line">test.prop = 3</span><br><span class="line">console.log(test) // &#123;prop: 1&#125;</span><br><span class="line"></span><br><span class="line">delete test.prop // false</span><br></pre></td></tr></table></figure>



<h3 id="Object-seal"><a href="#Object-seal" class="headerlink" title="Object.seal()"></a>Object.seal()</h3><p>Object.seal() 方法封闭一个对象，不能添加新属性，也不能删除旧属性，但可以修改原来的属性值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let test = &#123; prop: 1 &#125;</span><br><span class="line">Object.seal(test)</span><br><span class="line">test.prop = 2</span><br><span class="line">console.log(test) // &#123; prop: 2 &#125; 可以修改</span><br><span class="line"></span><br><span class="line">test.newProp = 3</span><br><span class="line">console.log(test) // &#123; prop: 2 &#125; 不能新增</span><br><span class="line">delete test.prop // false 不能删除</span><br></pre></td></tr></table></figure>



<h3 id="Object-preventExtensions"><a href="#Object-preventExtensions" class="headerlink" title="Object.preventExtensions()"></a>Object.preventExtensions()</h3><p>Object.preventExtensions() 方法将它变成不可扩展的对象，不能添加新属性，但是可以修改和删除旧属性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let test = &#123; prop: 1 &#125;</span><br><span class="line">Object.preventExtensions(test)</span><br><span class="line">test.newProp = 2</span><br><span class="line">console.log(test) // &#123;prop: 1&#125; 不能添加新属性</span><br><span class="line"></span><br><span class="line">test.prop = 3 // &#123;prop: 3&#125; 可以修改旧属性</span><br><span class="line">delete test.prop // test 可以删除旧属性</span><br><span class="line">console.log(test) // &#123;&#125;</span><br></pre></td></tr></table></figure>



<p>这三个方法都是控制对象的安全性的，他们几个也有对应的方法去判断一个对象处于什么状态，分别是</p>
<ul>
<li><p>isFrozen 判断对象是否被冻结</p>
</li>
<li><p>isSealed 判断对象是否封闭</p>
</li>
<li><p>isExtensible 判断对象是否可扩展</p>
</li>
</ul>
<h3 id="小结一下"><a href="#小结一下" class="headerlink" title="小结一下"></a>小结一下</h3><table>
<thead>
<tr>
<th>方法</th>
<th>可控性</th>
</tr>
</thead>
<tbody><tr>
<td>Object.freeze</td>
<td>低，啥都不可以改，可以理解为冰冻了一样</td>
</tr>
<tr>
<td>Object.seal</td>
<td>中，可以修改值，但不能删除</td>
</tr>
<tr>
<td>Object.preventExtensions</td>
<td>高，除了不能添加值，其余都可以</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>互联网是如何工作的</title>
    <url>/2021/10/07/network/%E4%BA%92%E8%81%94%E7%BD%91%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/</url>
    <content><![CDATA[<p><img src="/2021/10/07/network/%E4%BA%92%E8%81%94%E7%BD%91%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/image-20211013225718305.png" alt="image-20211013225718305"></p>
<blockquote>
<p>由浅到深，由入门到放弃</p>
</blockquote>
<span id="more"></span>



<h2 id="什么是互联网"><a href="#什么是互联网" class="headerlink" title="什么是互联网"></a>什么是互联网</h2><h3 id="互联网的信息是怎么组成的？"><a href="#互联网的信息是怎么组成的？" class="headerlink" title="互联网的信息是怎么组成的？"></a>互联网的信息是怎么组成的？</h3><p>互联网是一种传送信息的有型物理系统，它类似我们的邮政服务，它是用二进制传递信息的，信息由比特组成，<strong>一个比特可以用来表示任何一组相对意义的词语</strong>，例如 “开” 或 “关”，“是” 或 ”否“，通常 <code>1</code> 表示“开”，<code>0</code> 表示 “关”，因为一个比特可以表示 <code>2</code> 种状态，我们称为二进制码。</p>
<p><code>8</code> 比特在一起构成一个字节。即</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8 Bits = 1 Byte</span><br></pre></td></tr></table></figure>

<p><code>1024</code> 字节加起来就是一千字节，通常用 <code>KB</code> 表示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1024 Byte = 1KB </span><br></pre></td></tr></table></figure>

<p><code>1024</code> 千字节加起来就是一兆字节，通常用 <code>MB</code> 表示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1024 KB = 1 MB</span><br></pre></td></tr></table></figure>

<p>注意，<strong>无论是多大的数据，互联网上的一切都是以比特形式表示和发送的</strong>，因此 <code>bit</code> 是信息的最小单位。</p>
<h3 id="互联网信息的传递介质是什么？"><a href="#互联网信息的传递介质是什么？" class="headerlink" title="互联网信息的传递介质是什么？"></a>互联网信息的传递介质是什么？</h3><p>我们知道互联网上的信息是由<strong>比特</strong>组成的，而传输<strong>比特</strong>的介质是<strong>电力，光和无线电</strong>。</p>
<p>从信息的组成得知，比特只有两种状态，那我们是通过只有 2 种状态的比特去表示世界上的所有信息呢？</p>
<p>因此我们在发送端和接收端规定了单位时间，1 秒内，发了怎么样组合的比特，例如 0001100，还是111000，这就是信息的表示。很明显，这样也不行，发送的信息量太少了，这时候，又引入了带宽的概念，这是设备的最大传输容量。</p>
<p>带宽是以比特率（Bitrate）来衡量的，指在单位时间内可以发送的比特数量，通常以秒为单位。</p>
<p>另一个测量速度的单位是延迟时间，指一个比特从一个地方到另一个地方所花的时间。<br><img src="/2021/10/07/network/%E4%BA%92%E8%81%94%E7%BD%91%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/image-20211007212420460.png" alt="image-20211007212420460"></p>
<p>有了这些东西，在将信号放在不同的介质上，就构成了我们能感受到的，网线，光纤，wifi，这就是我们的互联网世界。整个世界的互联网都是由这些基础设施构成的，每个国家都有自己的网线布局，而国家与国家之间又通过海底光纤来连接，一旦网线被切断，则互联网的通信就会中断。<br><img src="/2021/10/07/network/%E4%BA%92%E8%81%94%E7%BD%91%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/image-20211007213245417.png" alt="image-20211007213245417"></p>
<p>网线是通过电信号来传输 0 和 1 通信的</p>
<p>光纤是通过光信号在光缆中做不断弹跳进行传递的，根据光的弹跳角度不同能实现多组信号的发送</p>
<p>无线电则是将 0 和 1 转换成不同频率的无线电波来通信，接收机器还要将无线电波反转，转换回机器上的二进制文件。<br><img src="/2021/10/07/network/%E4%BA%92%E8%81%94%E7%BD%91%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/image-20211007213806112.png" alt="image-20211007213806112"></p>
<h3 id="互联网的约定——工作协议"><a href="#互联网的约定——工作协议" class="headerlink" title="互联网的约定——工作协议"></a>互联网的约定——工作协议</h3><p>有了协议，才让互联网的通信成为了可能。</p>
<p>互联网是一个网中网，它将全球数十亿台设备连接在一起，而每台设备都有各自的编码，这个编码就是网卡的 <code>MAC</code> 地址，它就像一个身份证，独立且唯一。通过这个地址，就能找到这个设备。</p>
<p>每个网络都不是直连的，它们的上面有个阀，它叫互联网服务提供商（ISP） 在中国由运营商（移动，联通，电信）来承担，而 <code>ISP</code> 就会将你连接到世界各地数十亿的设备上。</p>
<p><img src="/2021/10/07/network/%E4%BA%92%E8%81%94%E7%BD%91%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/image-20211007214843757.png" alt="image-20211007214843757"></p>
<p>互联网实际上是一种设计理念和一套协议所表达的体系结构。协议是一套总所周知的规则和标准，当大家都遵循时候，就可以畅通无阻的进行通信了。</p>
<p>互联网怎么运作的不重要，重要的是这个设计理念，它允许互联网适应和吸收新的通信技术。也就是说，在这个上面，它并不会规定必须使用某个协议，才能使用互联网，更包容的是，只要双方约定这个协议，就可以在互联网上进行通信。</p>
<h4 id="IP-协议"><a href="#IP-协议" class="headerlink" title="IP 协议"></a>IP 协议</h4><p>计算机的地址，注意哟，这个和 <code>MAC</code> 地址不太一样，<code>MAC</code> 地址是物理地址，无法更改，但 <code>IP</code> 可以。</p>
<p>访问任何网站实际上只是你的计算机向另一台计算机请求信息，你的计算机将信息发送到另一台计算机的 <code>IP</code> 地址。</p>
<p>IP 地址 <code>xxx.xxx.xxx.xxx</code> 它就是一堆数字，用<strong>位（Bits）</strong>表示</p>
<p><img src="/2021/10/07/network/%E4%BA%92%E8%81%94%E7%BD%91%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/image-20211007223001032.png" alt="image-20211007223001032"></p>
<p>IPv4 地址是 32 位长地址，每部分都有 8 位。1973 年设计的，于 20 世纪 80 年代广泛采用，为连接互联网设备提供超过 40 亿个唯一地址。<img src="/2021/10/07/network/%E4%BA%92%E8%81%94%E7%BD%91%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/image-20211007223133914.png" alt="image-20211007223133914"></p>
<p>每部分都有各自的含义，通常第一部分表示国家或本地网络，然后是子网络，最后是特定的设备地址。</p>
<p>显然 IPv4 已经逐渐不够用了，我们正往 IPv6 进行变迁。</p>
<p><img src="/2021/10/07/network/%E4%BA%92%E8%81%94%E7%BD%91%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/image-20211007223607371.png" alt="image-20211007223607371"></p>
<p>其中 IPv6 每个地址使用 128 个字节<strong>（因为 IPv6 是 16 位的，1 位等于8个字节所以是 128，而 IPv4 是 1 位的，所以是 8 个字节）</strong>，提供超过 340 * 10 千亿个唯一地址。</p>
<h4 id="DNS-协议"><a href="#DNS-协议" class="headerlink" title="DNS 协议"></a>DNS 协议</h4><p>为了记忆方便，我们可以给 IP 地址命名，譬如说域名为 <code>www.baidu.com</code> 的 <code>IP</code> 地址是 <code>14.215.177.39</code>，如果记 IP 比较难。</p>
<p>通过 <code>DNS</code>  我们可以搜索到其域名和与之关联的 <code>IP</code> 地址。</p>
<p>总而言之，访问互联网还是要通过 <code>IP</code> 地址的，域名只是为了好记，就好比手机通讯录，让你记所有人的电话号码很难，但是，给每个号码取个名字，下次找，一目了然，就是这个道理。</p>
<p><img src="/2021/10/07/network/%E4%BA%92%E8%81%94%E7%BD%91%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/dns_ip.gif" alt="dns_ip"></p>
<p>那么我们如何为数十亿台设备设计一个系统用来查找数十亿不同网站中的任何一个呢？显然一个 DNS 服务器无法处理来自所有设备的所有请求的，答案是，DNS 服务器以分布式层次结构连接，并被划分为区域，对主要领域，如 <code>.org</code>，<code>.com</code>，<code>net</code> 等进行职责划分</p>
<p><img src="/2021/10/07/network/%E4%BA%92%E8%81%94%E7%BD%91%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/image-20211007231437674.png" alt="image-20211007231437674"></p>
<p>由于 DNS 的开放性，它很容易受到网络攻击，最常见的就是 <strong>DNS 欺骗</strong>，即黑客侵入了 DNS 服务器，并将其更改为匹配具有错误 <code>IP</code> 地址的域名。这样攻击者就可以把人送到冒名顶替者的网站。因为进入了假网站，他让你输入账号密码，这样他们后台就知道了。</p>
<p><img src="/2021/10/07/network/%E4%BA%92%E8%81%94%E7%BD%91%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/image-20211007231728153.png" alt="image-20211007231728153"></p>
<h3 id="互联网是如何将数据可靠的传给你呢？"><a href="#互联网是如何将数据可靠的传给你呢？" class="headerlink" title="互联网是如何将数据可靠的传给你呢？"></a>互联网是如何将数据可靠的传给你呢？</h3><p>互联网上的信息从一台计算机传送到另一台计算机，我们称为信息包。它的方式就像电流，有些地方受限或拥堵了，它就会绕路前行。<br><img src="/2021/10/07/network/%E4%BA%92%E8%81%94%E7%BD%91%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/image-20211007233512111.png" alt="image-20211007233512111"></p>
<p>你可以使用 IP 数据包发送多种类型数字信息，但数据量太大就会受到一些限制。为了解决这个问题，我们提出分包思想，也就是将一个大文件拆分成多个小文件传输，最后再进行组装。</p>
<p><img src="/2021/10/07/network/%E4%BA%92%E8%81%94%E7%BD%91%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/package.gif" alt="package"></p>
<p>譬如说一个大文件，它由数百万个比特组成，数据太多了，无法在一个数据包中发送，它就会被拆分成一个个小部分，而每一个小部分都有它来自何处和去向何处的因特网地址。<br><img src="/2021/10/07/network/%E4%BA%92%E8%81%94%E7%BD%91%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/image-20211007234153265.png" alt="image-20211007234153265"></p>
<p>在互联网上，有一类特殊的计算机称为路由器，它像流量管理员意义，保持数据包顺利通过网络</p>
<p><img src="/2021/10/07/network/%E4%BA%92%E8%81%94%E7%BD%91%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/image-20211007235353644.png" alt="image-20211007235353644"></p>
<p>如果一条线路拥挤，则各个分组可以通过互联网传播不同的路由</p>
<p><img src="/2021/10/07/network/%E4%BA%92%E8%81%94%E7%BD%91%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/image-20211007235656557.png" alt="image-20211007235656557"></p>
<p>它们可能会在稍微不同的时间到达目的地，甚至会出现故障。</p>
<p><strong>我们来谈谈路由器是如何工作的</strong></p>
<p>每个路由器都会跟踪多条发送数据包的路径，它根据数据包的目标 IP 地址为每段数据选择最佳的可用路径，拥有路径选项可以使网络具有容错性，这意味着即使出现可怕的错误，网络也可以继续发送数据包，这就是互联网的关键原则基础<strong>可靠性</strong>。</p>
<p><img src="/2021/10/07/network/%E4%BA%92%E8%81%94%E7%BD%91%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/image-20211008000053483.png" alt="image-20211008000053483"></p>
<p>路由的多路径使互联网具备可靠性，单凭可靠性是不够的，我们还需要另一个原则，<strong>数据的完整性</strong></p>
<h4 id="TCP-—-传输控制协议"><a href="#TCP-—-传输控制协议" class="headerlink" title="TCP — 传输控制协议"></a>TCP — 传输控制协议</h4><p>TCP 以<strong>包</strong>的形式管理所有数据的发送和接收，数据通过 TCP 协议进行传输，当数据到达接收端时，TCP 会对数据包进行完整清点。并将收到的每个数据包的确认信息发回，如果所有数据包都到达了，且无遗漏，TCP 会签收，此时数据就完整了。</p>
<p><img src="/2021/10/07/network/%E4%BA%92%E8%81%94%E7%BD%91%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/image-20211008000619700.png" alt="image-20211008000619700"></p>
<p>如果 TCP 发现某些数据包丢失，它就拒收。</p>
<p>TCP 和路由器的优点在于它们是可扩展的，它可使用 8 到 80 亿台设备，由于具备容错和冗余这些原则，我们添加的路由器越多，互联网就越可靠</p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title>useState和setState</title>
    <url>/2021/09/05/frontEnd/useState%E5%92%8CsetState/</url>
    <content><![CDATA[<p><img src="/2021/09/05/frontEnd/useState%E5%92%8CsetState/image-20210817215151351.png" alt="image-20210817215151351"></p>
<span id="more"></span>

<blockquote>
<p>React Version: 17.0.2</p>
</blockquote>
<p>React 最常用的两个方法 <code>setState</code> 和 <code>useState</code>，前者用于类（<code>class</code>） 组件，后者用于 函数（<code>function</code>） 组件</p>
<p>我们从几个维度去深刨这两者的区别</p>
<h3 id="setState-使用"><a href="#setState-使用" class="headerlink" title="setState 使用"></a>setState 使用</h3><p><code>setState</code> 是以修改和新增的方式改变 <code>state</code> 的，不会改变没有涉及到的 <code>state</code>。也就是说，不会改变没有涉及到的 <code>state</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this.state = &#123;</span><br><span class="line">  a: 1,</span><br><span class="line">  b: 2,</span><br><span class="line">  c: 3,</span><br><span class="line">&#125;</span><br><span class="line">this.setState(&#123;</span><br><span class="line">  b: 5,</span><br><span class="line">&#125;)</span><br><span class="line">console.log(state)</span><br><span class="line">&#123;</span><br><span class="line">  a: 1,</span><br><span class="line">  b: 5,</span><br><span class="line">  c: 3,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="setState-源码"><a href="#setState-源码" class="headerlink" title="setState 源码"></a>setState 源码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Component.prototype.setState = function (partialState, callback) &#123;</span><br><span class="line">  if (!(typeof partialState === &#x27;object&#x27; || typeof partialState === &#x27;function&#x27; || partialState == null)) &#123;</span><br><span class="line">      &#123;</span><br><span class="line">        throw Error( &quot;setState(...): takes an object of state variables to update or a function which returns an object of state variables.&quot; );</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  this.updater.enqueueSetState(this, partialState, callback, &#x27;setState&#x27;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>首先会判断，如果 <code>partialState</code> 不为对象，函数，或者 <code>null</code>，则报错，参数名叫 <code>partialState</code>，说明只会影响到涉及的 <code>state</code>。<code>enqueueSetState</code> 是 <code>state</code> 队列管理的入口方法。</p>
<h4 id="enqueueSetState"><a href="#enqueueSetState" class="headerlink" title="enqueueSetState"></a>enqueueSetState</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enqueueSetState: function (inst, payload, callback) &#123;</span><br><span class="line">  // 创建 fiber，暂且不知道 fiber 是干嘛的，没关系</span><br><span class="line">  var fiber = get(inst);</span><br><span class="line"></span><br><span class="line">  // eventTime 是触发当前更新的时间戳</span><br><span class="line">  var eventTime = requestEventTime();</span><br><span class="line">  </span><br><span class="line">  // 获取本次更新的优先级 lane，返回值是一个数字 number</span><br><span class="line">  var lane = requestUpdateLane(fiber);</span><br><span class="line">  </span><br><span class="line">  // 创建 update 对象</span><br><span class="line">  var update = createUpdate(eventTime, lane);</span><br><span class="line">  </span><br><span class="line">  // payload 就是本次更新的 state 值</span><br><span class="line">  update.payload = payload;</span><br><span class="line">  if (callback !== undefined &amp;&amp; callback !== null) &#123;</span><br><span class="line">    &#123;</span><br><span class="line">      warnOnInvalidCallback(callback, &#x27;setState&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">    update.callback = callback;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // 将 update 放入 fiber 的 updateQueue（更新队列）</span><br><span class="line">  enqueueUpdate(fiber, update);</span><br><span class="line">  </span><br><span class="line">   // 开始进行调度</span><br><span class="line">  scheduleUpdateOnFiber(fiber, lane, eventTime);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>其中，创建一个 <code>update</code> 对象，并设置以下字段，用于说明本次更新的信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function createUpdate(eventTime, lane) &#123;</span><br><span class="line">   var update = &#123;</span><br><span class="line">     eventTime: eventTime, // 更新的产生时间</span><br><span class="line">     lane: lane, // 优先级</span><br><span class="line">     tag: UpdateState, // 表示更新是哪种类型（UpdateState=0，ReplaceState=1，ForceUpdate=2，CaptureUpdate=3）</span><br><span class="line">     payload: null, // 更新的数据</span><br><span class="line">     				// 类组件中，有两种可能，对象（&#123;&#125;），和函数（(prevState, nextProps): newState =&gt; &#123;&#125;）</span><br><span class="line">     				// 根组件中，为 React.element，即 ReactDOM.render 的第一个参数</span><br><span class="line">     callback: null, // 可理解为 setState 的回调</span><br><span class="line">     next: null // 指向下一个 update 的指针</span><br><span class="line">   &#125;;</span><br><span class="line">   return update;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="enqueueUpdate"><a href="#enqueueUpdate" class="headerlink" title="enqueueUpdate"></a>enqueueUpdate</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function enqueueUpdate(fiber, update) &#123;</span><br><span class="line">   // fiber 对象是个很庞大的东西，这里就不展示了，其中 updateQueue 是一个对象，它是个更新队列</span><br><span class="line">   var updateQueue = fiber.updateQueue;</span><br><span class="line">   if (updateQueue === null) &#123;</span><br><span class="line">     // Only occurs if the fiber has been unmounted.</span><br><span class="line">     return;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // 下面这段代码，如果更新队列（pending）中有，则先执行更新队列中的，将本次的放到下一个更新队列 next 中</span><br><span class="line">   var sharedQueue = updateQueue.shared;</span><br><span class="line">   var pending = sharedQueue.pending;</span><br><span class="line">	</span><br><span class="line">   if (pending === null) &#123;</span><br><span class="line">     // This is the first update. Create a circular list.</span><br><span class="line">     update.next = update;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">     update.next = pending.next;</span><br><span class="line">     pending.next = update;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   sharedQueue.pending = update;</span><br><span class="line"></span><br><span class="line">   &#123;</span><br><span class="line">      if (currentlyProcessingQueue === sharedQueue &amp;&amp; !didWarnUpdateInsideUpdate) &#123;</span><br><span class="line">        error(&#x27;An update (setState, replaceState, or forceUpdate) was scheduled &#x27; + &#x27;from inside an update function. Update functions should be pure, &#x27; + &#x27;with zero side-effects. Consider using componentDidUpdate or a &#x27; + &#x27;callback.&#x27;);</span><br><span class="line"></span><br><span class="line">        didWarnUpdateInsideUpdate = true;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>任务调度</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function scheduleUpdateOnFiber(fiber, lane, eventTime) &#123;</span><br><span class="line">    checkForNestedUpdates();</span><br><span class="line">    warnAboutRenderPhaseUpdatesInDEV(fiber);</span><br><span class="line">    var root = markUpdateLaneFromFiberToRoot(fiber, lane);</span><br><span class="line"></span><br><span class="line">    if (root === null) &#123;</span><br><span class="line">      warnAboutUpdateOnUnmountedFiberInDEV(fiber);</span><br><span class="line">      return null;</span><br><span class="line">    &#125; // Mark that the root has a pending update.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    markRootUpdated(root, lane, eventTime);</span><br><span class="line"></span><br><span class="line">    if (root === workInProgressRoot) &#123;</span><br><span class="line">      // Received an update to a tree that&#x27;s in the middle of rendering. Mark</span><br><span class="line">      // that there was an interleaved update work on this root. Unless the</span><br><span class="line">      // `deferRenderPhaseUpdateToNextBatch` flag is off and this is a render</span><br><span class="line">      // phase update. In that case, we don&#x27;t treat render phase updates as if</span><br><span class="line">      // they were interleaved, for backwards compat reasons.</span><br><span class="line">      &#123;</span><br><span class="line">        workInProgressRootUpdatedLanes = mergeLanes(workInProgressRootUpdatedLanes, lane);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (workInProgressRootExitStatus === RootSuspendedWithDelay) &#123;</span><br><span class="line">        // The root already suspended with a delay, which means this render</span><br><span class="line">        // definitely won&#x27;t finish. Since we have a new update, let&#x27;s mark it as</span><br><span class="line">        // suspended now, right before marking the incoming update. This has the</span><br><span class="line">        // effect of interrupting the current render and switching to the update.</span><br><span class="line">        // TODO: Make sure this doesn&#x27;t override pings that happen while we&#x27;ve</span><br><span class="line">        // already started rendering.</span><br><span class="line">        markRootSuspended$1(root, workInProgressRootRenderLanes);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; // TODO: requestUpdateLanePriority also reads the priority. Pass the</span><br><span class="line">    // priority as an argument to that function and this one.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    var priorityLevel = getCurrentPriorityLevel();</span><br><span class="line"></span><br><span class="line">    if (lane === SyncLane) &#123;</span><br><span class="line">      if ( // Check if we&#x27;re inside unbatchedUpdates</span><br><span class="line">      (executionContext &amp; LegacyUnbatchedContext) !== NoContext &amp;&amp; // Check if we&#x27;re not already rendering</span><br><span class="line">      (executionContext &amp; (RenderContext | CommitContext)) === NoContext) &#123;</span><br><span class="line">        // Register pending interactions on the root to avoid losing traced interaction data.</span><br><span class="line">        schedulePendingInteractions(root, lane); // This is a legacy edge case. The initial mount of a ReactDOM.render-ed</span><br><span class="line">        // root inside of batchedUpdates should be synchronous, but layout updates</span><br><span class="line">        // should be deferred until the end of the batch.</span><br><span class="line"></span><br><span class="line">        performSyncWorkOnRoot(root);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        ensureRootIsScheduled(root, eventTime);</span><br><span class="line">        schedulePendingInteractions(root, lane);</span><br><span class="line"></span><br><span class="line">        if (executionContext === NoContext) &#123;</span><br><span class="line">          // Flush the synchronous work now, unless we&#x27;re already working or inside</span><br><span class="line">          // a batch. This is intentionally inside scheduleUpdateOnFiber instead of</span><br><span class="line">          // scheduleCallbackForFiber to preserve the ability to schedule a callback</span><br><span class="line">          // without immediately flushing it. We only do this for user-initiated</span><br><span class="line">          // updates, to preserve historical behavior of legacy mode.</span><br><span class="line">          resetRenderTimer();</span><br><span class="line">          flushSyncCallbackQueue();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // Schedule a discrete update but only if it&#x27;s not Sync.</span><br><span class="line">      if ((executionContext &amp; DiscreteEventContext) !== NoContext &amp;&amp; ( // Only updates at user-blocking priority or greater are considered</span><br><span class="line">      // discrete, even inside a discrete event.</span><br><span class="line">      priorityLevel === UserBlockingPriority$2 || priorityLevel === ImmediatePriority$1)) &#123;</span><br><span class="line">        // This is the result of a discrete event. Track the lowest priority</span><br><span class="line">        // discrete update per root so we can flush them early, if needed.</span><br><span class="line">        if (rootsWithPendingDiscreteUpdates === null) &#123;</span><br><span class="line">          rootsWithPendingDiscreteUpdates = new Set([root]);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          rootsWithPendingDiscreteUpdates.add(root);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; // Schedule other updates after in case the callback is sync.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      ensureRootIsScheduled(root, eventTime);</span><br><span class="line">      schedulePendingInteractions(root, lane);</span><br><span class="line">    &#125; // We use this when assigning a lane for a transition inside</span><br><span class="line">    // `requestUpdateLane`. We assume it&#x27;s the same as the root being updated,</span><br><span class="line">    // since in the common case of a single root app it probably is. If it&#x27;s not</span><br><span class="line">    // the same root, then it&#x27;s not a huge deal, we just might batch more stuff</span><br><span class="line">    // together more than necessary.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    mostRecentlyUpdatedRoot = root;</span><br><span class="line">  &#125; // This is split into a separate function so we can mark a fiber with pending</span><br><span class="line">  // work without treating it as a typical update that originates from an event;</span><br><span class="line">  // e.g. retrying a Suspense boundary isn&#x27;t an update, but it does schedule work</span><br><span class="line">  // on a fiber.</span><br></pre></td></tr></table></figure>



<p><strong>总的来说，上面的操作执行了以下事情</strong></p>
<p>就是创建一个 <code>fiber</code> 并且将 <code>update</code> 放到 <code>fiber</code> 的 <code>updateQueue</code> 中，执行 <code>scheduleUpdateOnFiber</code> 开始任务调度 </p>
<ul>
<li>创建 fiber：获取产生更新的组件所对应的 fiber 节点，因为产生的 update 对象需要放到 fiber 节点的 updateQueue 上，然后获取当前这个 update 产生的时间</li>
<li>计算优先级 lane</li>
<li>创建update对象， 入队 updateQueue</li>
<li>执行 scheduleUpdateOnFiber 去调度执行更新任务：产生更新的fiber节点上会有一个 updateQueue，它包含了刚刚产生的 update。下面该进入scheduleUpdateOnFiber 了，开始进入真正的调度流程。通过调用 scheduleUpdateOnFiber，render 阶段的构建 workInProgress 树的任务会被调度执行，这个过程中，fiber 上的 updateQueue 会被处理。</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 如何隐藏文章</title>
    <url>/2021/08/15/hexo/Hexo%E5%A6%82%E4%BD%95%E9%9A%90%E8%97%8F%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<img src="/2021/08/15/hexo/Hexo%E5%A6%82%E4%BD%95%E9%9A%90%E8%97%8F%E6%96%87%E7%AB%A0/image-20210815102702972.png" alt="image-20210815102702972">

<blockquote>
<p>当一篇文章被设置为「隐藏」时，它不会出现在任何列表中（包括首页、存档、分类页面、标签页面、Feed、站点地图等），也不会被搜索引擎索引（前提是搜索引擎遵守 noindex 标签）。</p>
<p>只有知道文章链接的人才可以访问被隐藏的文章。</p>
</blockquote>
<span id="more"></span>

<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>在站点目录下，安装 <code>hexo-hide-posts</code> 插件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-hide-posts --save</span><br></pre></td></tr></table></figure>



<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>在站点目录下的 <code>_config.yml</code> 中如下配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># hexo-hide-posts</span><br><span class="line">hide_posts:</span><br><span class="line">  # 可以改成其他你喜欢的名字</span><br><span class="line">  filter: hidden</span><br><span class="line">  # 指定你想要传递隐藏文章的位置，比如让所有隐藏文章在存档页面可见</span><br><span class="line">  # 常见的位置有：index, tag, category, archive, sitemap, feed, etc.</span><br><span class="line">  # 留空则默认全部隐藏</span><br><span class="line">  public_generators: []</span><br><span class="line">  # 为隐藏的文章添加 noindex meta 标签，阻止搜索引擎收录</span><br><span class="line">  noindex: true</span><br></pre></td></tr></table></figure>

<p><code>filter</code> 属性可以让用户自定义 <code>Front-matter</code> 的隐藏属性名</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>譬如说 <code>hidden</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line"> title: &#x27;xxx&#x27;</span><br><span class="line"> categories: &#x27;xxx&#x27;</span><br><span class="line"> hidden: true</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>譬如说 <code>self</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line"> title: &#x27;xxx&#x27;</span><br><span class="line"> categories: &#x27;xxx&#x27;</span><br><span class="line"> self: true</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>在命令行运行 <code>hexo hidden:list</code> 来获取当前所有的已隐藏文章列表</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript 指北</title>
    <url>/2021/08/04/frontEnd/TypeScript%E6%8C%87%E5%8C%97/</url>
    <content><![CDATA[<p><img src="/2021/08/04/frontEnd/TypeScript%E6%8C%87%E5%8C%97/image-20210912235606551.png" alt="image-20210912235606551"></p>
<span id="more"></span>

<h3 id="交叉类型"><a href="#交叉类型" class="headerlink" title="交叉类型"></a>交叉类型</h3><blockquote>
<p>交叉类型可以理解为类型合并，将多个类型合并为一个类型，它包含了所需所有类型的特性</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface A &#123;</span><br><span class="line">	a: string</span><br><span class="line">	b: number</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface B &#123;</span><br><span class="line">	c: boolean</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type TAAndB = A &amp; B</span><br><span class="line">// TAAndB 为</span><br><span class="line">&#123;</span><br><span class="line">	a: string</span><br><span class="line">	b: number</span><br><span class="line">	c: boolean</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="ReturnType"><a href="#ReturnType" class="headerlink" title="ReturnType"></a>ReturnType</h3><blockquote>
</blockquote>
<h3 id="Omit"><a href="#Omit" class="headerlink" title="Omit"></a>Omit</h3><blockquote>
<p>Omit&lt;K,T&gt; 可以让我们从另一个对象类型中剔除某些属性，创建一个新的对象类型，K：是对象类型名称，T：是剔除K类型中的属性名称</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type User = &#123;</span><br><span class="line">	name: string</span><br><span class="line">	age: number</span><br><span class="line">	address: string</span><br><span class="line">&#125;</span><br><span class="line">type UserOmit = Omit&lt;User, &#x27;address&#x27;&gt;</span><br><span class="line">// 等价于</span><br><span class="line">type UserOmit = &#123;</span><br><span class="line">	name: string</span><br><span class="line">	age: number</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>剔除多个</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type User = &#123;</span><br><span class="line">	name: string</span><br><span class="line">	age: number</span><br><span class="line">	address: string</span><br><span class="line">&#125;</span><br><span class="line">type UserOmit = Omit&lt;User, &#x27;name&#x27;|&#x27;age&#x27;&gt;</span><br><span class="line">// 等价于</span><br><span class="line">type UserOmit = &#123;</span><br><span class="line">	address: string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>typeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Redux ToolKit 改造项目</title>
    <url>/2021/08/04/frontEnd/ReduxToolKit%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p><img src="/2021/08/04/frontEnd/ReduxToolKit%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/image-20210808153827937.png" alt="image-20210808153827937"></p>
<blockquote>
<p>React 做状态管理用的是 react-redux，通过 RTK 可以优化你的项目结构，让项目看起来清爽很多</p>
</blockquote>
<span id="more"></span>

<h3 id="RTK-提供的-API"><a href="#RTK-提供的-API" class="headerlink" title="RTK 提供的 API"></a>RTK 提供的 API</h3><p>RTK 提供了以下 API</p>
<ul>
<li><code>configureStore()</code> 包裹 <code>createStore</code>，并集成了<code>redux-thunk</code>、<code>Redux DevTools Extension</code>，默认开启</li>
<li><code>createReducer()</code> 创建一个 <code>reducer</code>，<code>action type</code> 映射到 <code>case reducer</code> 函数中，不用写 <code>switch-case</code>，并集成<code>immer</code></li>
<li><code>createAction()</code> 创建一个 <code>action</code>，传入动作类型字符串，返回动作函数</li>
<li><code>createSlice()</code> 创建一个 <code>slice</code>，包含 <code>createReducer</code>、<code>createAction</code> 的所有功能</li>
</ul>
<p>以上是 <code>RTK</code> 的部分 <code>API</code> ，只用重点关注这几个，其他的请自行看官网 <a href="https://redux-toolkit.js.org/">Redux toolKit</a></p>
<p><code>redux</code> 中是分几个概念的，<code>store</code>，<code>reducer</code>，<code>middleware</code>，<code>action</code>，<code>RTK</code> 也不例外，我们分几个部分去改造</p>
<h3 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h3><p>在 <code>redux</code> 中 <code>store</code> 是通过 <code>createStore</code> 创建的，创建出来的对象注入到项目的最顶层，</p>
<p><code>RTK</code> 也是一样的需要创建出 <code>store</code> 对象，注入到最顶层，只不过换了个 API</p>
<p><code>redux</code> 中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const initialState = &#123;</span><br><span class="line">	slice1: &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">const store = createStore(reducer, initialState, enhance)</span><br></pre></td></tr></table></figure>

<p>我们看看 <code>createStore</code> 源码做了什么</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 摘至createStore</span><br><span class="line">export function createStore(reducer, rootState, enhance) &#123;</span><br><span class="line">    ...</span><br><span class="line">    if (typeof enhancer !== &#x27;undefined&#x27;) &#123;</span><br><span class="line">        if (typeof enhancer !== &#x27;function&#x27;) &#123;</span><br><span class="line">          throw new Error(&#x27;Expected the enhancer to be a function.&#x27;)</span><br><span class="line">        &#125;</span><br><span class="line">    /*</span><br><span class="line">        若使用中间件，这里 enhancer 即为 applyMiddleware()</span><br><span class="line">        若有enhance，直接返回一个增强的createStore方法，可以类比成react的高阶函数</span><br><span class="line">    */</span><br><span class="line">    return enhancer(createStore)(reducer, preloadedState)</span><br><span class="line">  &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>RTK</code> 中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const store = configureStore(&#123;</span><br><span class="line">  reducer: rootReducer,</span><br><span class="line">  middleware,</span><br><span class="line">  enhancers,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>两者都有 <code>enhance</code>，<code>enhance</code> 可以翻译成 <code>store</code> 的增强器，就是增强 <code>store</code> 的功能。一个 <code>store enhancer</code>，实际上就是一个高阶函数，它的参数是创建 <code>store</code> 的函数（<code>store creator</code>），返回值是一个可以创建功能更加强大的 <code>store</code> 的函数(<code>enhanced store creator</code>)，这和 <code>React</code> 中的高阶组件的概念很相似。</p>
<p>再说说 <code>reducer</code>，两者都是一样的，通过 <code>combineReducers</code> 可以将多个独立的 <code>reducer</code>  合并成一个大的 <code>reducer</code> ，<strong>该函数根据 <code>state</code>的 <code>key</code> 去执行相应的子 <code>Reducer</code>，并将结果合并到最终的 <code>state</code> 对象里。</strong>记住，这里是根据 <code>state</code> 中的 <code>key</code> 去识别的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const rootReducer = combineReducers(&#123;</span><br><span class="line">  slice1: slice1Reducer</span><br><span class="line">  ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<p>唯一区别在于，<code>RTK</code> 中没有 <code>initialState</code> 的概念。</p>
<p>那这部分去哪里了呢？</p>
<h3 id="Reducer"><a href="#Reducer" class="headerlink" title="Reducer"></a>Reducer</h3><p><code>redux</code> 中的 <code>reducer</code>  就是只是对 <code>state</code> 数据进行了修改，也就是说，<code>redux</code> 中 <code>reducer</code> 包含了 <code>initialState</code> 和 <code>reducer</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export const MULTIPLY_ONE = &#x27;MULTIPLY_ONE&#x27;;</span><br><span class="line"></span><br><span class="line">const initialState = &#123;</span><br><span class="line">	val_one: 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const OnoReducer = (state = initialState, action) =&gt; &#123;</span><br><span class="line">	switch(action.type)&#123;</span><br><span class="line">		case MULTIPLY_ONE: return &#123;</span><br><span class="line">			...state,</span><br><span class="line">			val_one: state.val_one * 2</span><br><span class="line">		&#125;</span><br><span class="line">		default: return state</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">export default OneReducer;</span><br></pre></td></tr></table></figure>

<p><code>RTK</code> 中的 <code>reducer</code></p>
<p><code>RTK</code> 中的 <code>reducer</code> 提供了切片 <code>slice</code> 的思想，<code>no picture no say</code>，随便画了下图，简述下 <code>slice</code> 的思想，一个切片包括 <code>reducer</code> 和 <code>initialState</code>，它让项目看起来更加工整，维护性更好。</p>
<p><img src="/2021/08/04/frontEnd/ReduxToolKit%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/image-20210806114402746.png" alt="image-20210806114402746"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; createSlice &#125; from &#x27;@reduxjs/toolkit&#x27;</span><br><span class="line">import &#123; set &#125; from &#x27;lodash-es&#x27;</span><br><span class="line"></span><br><span class="line">const initialState = &#123;</span><br><span class="line">  lists: [],</span><br><span class="line">  total: 0,</span><br><span class="line">  isLoading: false,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const Slice1 = createSlice(&#123;</span><br><span class="line">  name: &#x27;slice1&#x27;,</span><br><span class="line">  initialState,</span><br><span class="line">  reducers: &#123;</span><br><span class="line">    setMyState(state, &#123; payload &#125;) &#123;</span><br><span class="line">      const &#123; path, data &#125; = payload</span><br><span class="line">      set(state, path, data)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const &#123; actions &#125; = Slice1</span><br><span class="line"></span><br><span class="line">export default Slice1.reducer</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这就是一个 <code>slice</code>，<code>reducers</code> 中的是同步操作，异步的放后面说，它如果要调用同步方法，只需要</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dispatch(action.setMyState())</span><br></pre></td></tr></table></figure>

<p><code>slice</code> 最后输出的是 <code>reducer</code>，这个 reducer 要注入到 <code>configureStore</code> 的 <code>reducer</code> 中。</p>
<p>使用 <code>RTK</code> 改造 <code>Redux</code> 会有更好的维护性，它将 <code>action</code> 和 <code>reducer</code>  整合在一起，在 <code>slice</code> 中还提供了 <code>name</code> 属性，可以防止 <code>reducer</code> 污染。</p>
<p><strong>有没有发现，我们由始至终都没有提到 <code>action</code> 这是因为 <code>RTK</code> 帮我们把 <code>reducer</code> 和 <code>action</code> 整合在了一起</strong></p>
<p>如果你只是同步的话，我们就改造完了，后面就可以用 <code>useDispatch</code> 和 <code>useSelector</code> 去调用了。</p>
<p>我们再说说异步</p>
<h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>无论是同步还是异步，触发逻辑都是不会变的，<code>dispacth -&gt; action -&gt; reducer -&gt; state</code></p>
<p><code>RTK</code> 中，同步的 <code>action</code> ，通过 <code>createSlice</code> 帮我们实现，异步的需要自己编写。</p>
<p><code>RTK</code> 使用 <code>createAction</code> 函数来创建 <code>action</code>，该函数接受一个字符串，字符串的路径就是我们 <code>saga</code> 的路径。</p>
<p>有点懵，没关系，下面会一一解释。</p>
<p><code>redux</code> 的异步中间件有几种，这里说下 <code>react-saga</code>，它提供了绑定函数 <code>takeLatest</code> 或 <code>takeEvery</code> ，该函数用于关联 <code>action</code> 和异步函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const getLists = createAction&lt;any&gt;(&#x27;slice1/getLists&#x27;)</span><br></pre></td></tr></table></figure>

<p>这句话可以理解为，创建了一个名为<code>getLists </code> 的 <code>action</code> ，它会在 <code>name</code> 为 <code>slice1</code> 的 <code>reducer</code> 中寻找名为 <code>getLists</code> 的 <code>action</code></p>
<p>用  <code>takeLatest</code> 关联 <code>action</code> 和 <code>saga</code>，注意 <code>saga</code> 中用到的都是生成器函数 <code>function *</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function* watchGetLists() &#123;</span><br><span class="line">  yield takeLatest(getLists, getListsSaga)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Saga 里面再编写异步方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function* getLists(&#123; payload &#125;: PayloadAction&lt;IReq&gt;) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    const &#123; data = &#123;&#125; &#125; = yield call&lt;IRequestFn&gt;(request, &#123;</span><br><span class="line">      url,</span><br><span class="line">      method: &#x27;get&#x27;,</span><br><span class="line">      params: &#123;</span><br><span class="line">        ...payload,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">    console.log(data)</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">    console.error(&#x27;getLists&#x27;, e)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就完成了异步函数的开发。</p>
<p>最后我们梳理下 React Redux 整体实现。</p>
<h3 id="Redux-整体实现"><a href="#Redux-整体实现" class="headerlink" title="Redux 整体实现"></a>Redux 整体实现</h3><p>通过 <code>RTK</code> 改造</p>
<ul>
<li><p>store</p>
<p>同步</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// store.js</span><br><span class="line">import reducer from &#x27;./reducer&#x27;</span><br><span class="line">const store = configureStore(&#123;</span><br><span class="line">  reducer,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>异步，需要在 <code>configureStore</code> 加入中间件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// store.js</span><br><span class="line">import reducer from &#x27;./reducer&#x27;</span><br><span class="line">import createSagaMiddleware from &#x27;redux-saga&#x27;</span><br><span class="line">import rootSaga from &#x27;./sagas&#x27;</span><br><span class="line">import &#123; createLogger &#125; from &#x27;redux-logger&#x27;</span><br><span class="line"></span><br><span class="line">const sagaMiddleware = createSagaMiddleware() // 创建一个中间件</span><br><span class="line">const middleware = [sagaMiddleware] // 插入中间件</span><br><span class="line"></span><br><span class="line">// 丰富中间件</span><br><span class="line">if (process.env.NODE_ENV === &#x27;development&#x27;) &#123;</span><br><span class="line">  const logger = createLogger(&#123;</span><br><span class="line">    collapsed: true,</span><br><span class="line">    stateTransformer: (state) =&gt; &#123;</span><br><span class="line">      if (state.toJS) &#123;</span><br><span class="line">        return state.toJS()</span><br><span class="line">      &#125;</span><br><span class="line">      const entries = Object.entries(state)</span><br><span class="line">      return entries.reduce((obj, entry) =&gt; &#123;</span><br><span class="line">        (entry[1]).toJS</span><br><span class="line">          ? (obj[entry[0]] = (entry[1]).toJS())</span><br><span class="line">          : ([, obj[entry[0]]] = entry)</span><br><span class="line">        return obj</span><br><span class="line">      &#125;, &#123;&#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">  middlewares.push(logger)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const store = configureStore(&#123;</span><br><span class="line">  reducer,</span><br><span class="line">  middleware //</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 启动 Generators，参数必须是 Generator function</span><br><span class="line">sagaMiddleware.run(rootSaga)</span><br></pre></td></tr></table></figure>
<p>注入到 app 最顶层</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// App.js</span><br><span class="line">import store from &#x27;./store&#x27;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  (</span><br><span class="line">    &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">      &lt;App /&gt;</span><br><span class="line">    &lt;/Provider&gt;</span><br><span class="line">  ),</span><br><span class="line">  document.getElementById(&#x27;root&#x27;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
<li><p>reducer</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// reducer.js</span><br><span class="line">// 这里是 reducer 的集合</span><br><span class="line">import &#123; combineReducers &#125; from &#x27;redux-immutable&#x27; // 用 redux 中 combineReducers 也可以</span><br><span class="line">const rootReducer = combineReducers(&#123;</span><br><span class="line">	sliceName1: reducer1,</span><br><span class="line">	sliceName2: reducer2,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这里的 <code>sliceName</code> 是 <code> createSlice</code> 中的 <code>name</code> 属性值</p>
<p>下面我们要写真正的 <code>reducer</code> 了，<strong>这个是同步 reducers</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// silce.js</span><br><span class="line">import &#123; createSlice &#125; from &#x27;@reduxjs/toolkit&#x27;</span><br><span class="line">import &#123; set &#125; from &#x27;lodash-es&#x27;</span><br><span class="line">// 这里写每个 reducer 的初始值</span><br><span class="line">const initialState = &#123;</span><br><span class="line">  lists: [],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const Slice1 = createSlice(&#123;</span><br><span class="line">  name: &#x27;slice1&#x27;,</span><br><span class="line">  initialState,</span><br><span class="line">  reducers: &#123;</span><br><span class="line">    setMyState(state, &#123; payload &#125;) &#123;</span><br><span class="line">      const &#123; path, data &#125; = payload</span><br><span class="line">      set(state, path, data)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 通过 createSlice 每个 reducer 都有一个 action</span><br><span class="line">const &#123; action &#125; = Slice1</span><br><span class="line">export default Slice1.reducer</span><br></pre></td></tr></table></figure>

<p>如果是同步的话，这就完成了，一个 <code>store</code>，一个 <code>reducer</code> </p>
</li>
<li><p>sagas</p>
<p>要写异步，就需要用到 <code>redux-saga</code>，和 <code>reducer</code> 一样，我们需要建一个 saga 总入口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// sagas.js</span><br><span class="line">import &#123; all &#125; from &#x27;redux-saga/effects&#x27;</span><br><span class="line">export default function* rootSaga() &#123;</span><br><span class="line">	yield all([</span><br><span class="line">		...slice1Saga.map(i =&gt; i())</span><br><span class="line">	])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>action</p>
<p>异步，需要自己写 <code>action</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; createAction &#125; from &#x27;@reduxjs/toolkit&#x27;</span><br><span class="line">const getLists = createAction(&#x27;slice1/getLists&#x27;)</span><br><span class="line">export default &#123;</span><br><span class="line">	getLists,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>operations</p>
<p>我们在 <code>operation</code> 中写异步操作，譬如说 <code>API</code> 请求，<code>Saga</code> 接收 <code>type</code> 和 <code>payload</code> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; call, put &#125; from &#x27;redux-saga/effects&#x27;</span><br><span class="line">import request from &#x27;./request&#x27;</span><br><span class="line"></span><br><span class="line">function* getListsSaga(&#123; payload &#125;) &#123;</span><br><span class="line">	try &#123;</span><br><span class="line">    const &#123; data = &#123;&#125; &#125; = yield call(request, &#123;</span><br><span class="line">      url: &#x27;API_URL&#x27;,</span><br><span class="line">      method: &#x27;get&#x27;,</span><br><span class="line">      params: &#123;</span><br><span class="line">        ...payload,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">    yield put(setMyState(&#123; path: [&#x27;lists&#x27;], data &#125;))</span><br><span class="line">    console.log(data)</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">    console.error(&#x27;lists&#x27;, e)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>saga</p>
<p>编写子 <code>saga</code>， 这个 <code>saga</code>  要放在上面那个 <code>sagas</code> 中的，子 <code>saga</code> 的主要作用是合并异步的 <code>action</code> 和 <code>operation</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123;</span><br><span class="line">	getLists,</span><br><span class="line">&#125; from &#x27;./action&#x27;</span><br><span class="line"></span><br><span class="line">import &#123;</span><br><span class="line">	getListsSaga</span><br><span class="line">&#125; from &#x27;./opteration&#x27;</span><br><span class="line"></span><br><span class="line">function* watchGetLists() &#123;</span><br><span class="line">  yield takeLatest(getLists, getListsSaga)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default [</span><br><span class="line">	watchGetLists,</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li>
</ul>
<p>上面我们就完成了 redux 异步的开发工作了</p>
<p>我们整理下思路</p>
<p><img src="/2021/08/04/frontEnd/ReduxToolKit%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/image-20210807115358365.png" alt="image-20210807115358365"></p>
<p><img src="/2021/08/04/frontEnd/ReduxToolKit%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/image-20210808104325538.png" alt="image-20210808104325538"></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://javascript.plainenglish.io/simple-application-of-redux-combinereducers-in-react-6ac3bbeabc4a">How to use combineReducers() In Redux and React</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>redux</tag>
        <tag>RTK</tag>
      </tags>
  </entry>
  <entry>
    <title>一天一个hooks - useCallback</title>
    <url>/2021/07/30/hooks/useCallback/</url>
    <content><![CDATA[<blockquote>
<p>React 逐步使用 hooks 开发了，这是 React 原生的钩子函数</p>
</blockquote>
<span id="more"></span>

<ul>
<li>useCallback 优化针对于子组件渲染</li>
</ul>
<h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p>该钩子和 <code>useMemo</code> 一样，是做性能优化的，只有在依赖列表 <code>deps</code> 发生变化时候，才会进行渲染，它可以保证依赖的值未发生改变的时候，不触发函数引用的改变，区别于 <code>useMemo</code> 它返回的是一个函数（也就是未执行的），相当于 <code>bind</code>，<code>useCallback</code> 主要用于优化针对子组件的渲染。</p>
<h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p><code>useCallback</code> 有别于 <code>useMemo</code> 它返回的是一个未执行的函数，从源码中可以看出，下面源码第 <code>6</code> 行，它把 <code>callback</code> 原封不动的返回了，而 <code>useMemo</code> 会执行这条语句。</p>
<p><strong><code>useCallback</code> 计算结果是 <code>函数</code>, 主要用于缓存函数，应用场景如: 需要缓存的函数，因为函数式组件每次任何一个 <code>state</code> 的变化整个组件都会被重新刷新，一些函数是没有必要被重新刷新的，此时就应该缓存起来，提高性能，和减少资源浪费。</strong></p>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><h4 id="挂载阶段"><a href="#挂载阶段" class="headerlink" title="挂载阶段"></a>挂载阶段</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function mountCallback&lt;T&gt;(callback: T, deps: Array&lt;mixed&gt; | void | null): T &#123;</span><br><span class="line">  // 添加到Fiber节点上的Hooks链表</span><br><span class="line">  const hook = mountWorkInProgressHook();</span><br><span class="line">  const nextDeps = deps === undefined ? null : deps;</span><br><span class="line">  // memoizedState存的值是callback</span><br><span class="line">  hook.memoizedState = [callback, nextDeps];</span><br><span class="line">  return callback;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="更新阶段"><a href="#更新阶段" class="headerlink" title="更新阶段"></a>更新阶段</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function updateCallback&lt;T&gt;(callback: T, deps: Array&lt;mixed&gt; | void | null): T &#123;</span><br><span class="line">  // 找到该useMemo对应的hook数据对象</span><br><span class="line">  const hook = updateWorkInProgressHook();</span><br><span class="line">  const nextDeps = deps === undefined ? null : deps;</span><br><span class="line">  const prevState = hook.memoizedState;</span><br><span class="line">  if (prevState !== null) &#123;</span><br><span class="line">    if (nextDeps !== null) &#123;</span><br><span class="line">      const prevDeps: Array&lt;mixed&gt; | null = prevState[1];</span><br><span class="line">      if (areHookInputsEqual(nextDeps, prevDeps)) &#123;</span><br><span class="line">        return prevState[0];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  hook.memoizedState = [callback, nextDeps];</span><br><span class="line">  return callback;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>没有使用 <code>useCallback</code> 下的场景</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const Child = (props) =&gt; &#123;</span><br><span class="line">  console.log(&#x27;渲染了子组件&#x27;);</span><br><span class="line">  const &#123; onClick &#125; = props;</span><br><span class="line">  return (</span><br><span class="line">    &lt;button onClick=&#123;onClick&#125;&gt;点击按钮获取值&lt;/button&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const ChildMemo = React.memo(Child)</span><br><span class="line"></span><br><span class="line">const Parent = () =&gt; &#123;</span><br><span class="line">  const [text, updateText] = useState(&#x27;&#x27;);</span><br><span class="line">  const textRef = useRef();</span><br><span class="line"></span><br><span class="line">  const handleSubmit = () =&gt; &#123;</span><br><span class="line">    console.log(&#x27;当前输入框的值:&#x27;, textRef.current);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 当text的值变化的时候就会给textRef的current重新赋值</span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    textRef.current = text;</span><br><span class="line">  &#125;, [text]);</span><br><span class="line">  </span><br><span class="line">  return(</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      我是父组件</span><br><span class="line">      &lt;input type=&quot;text&quot; value=&#123;text&#125; onChange=&#123;(e) =&gt; updateText(e.target.value)&#125;/&gt;</span><br><span class="line">      &lt;ChildMemo onClick=&#123;handleSubmit&#125;/&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没有使用 <code>useCallback</code> 情况下，在<strong>输入框中输入内容</strong>，都会渲染子组件 <code>Child</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const Child = (props) =&gt; &#123;</span><br><span class="line">  console.log(&#x27;渲染了子组件&#x27;);</span><br><span class="line">  const &#123; onClick &#125; = props;</span><br><span class="line">  return (</span><br><span class="line">    &lt;button onClick=&#123;onClick&#125;&gt;点击按钮获取值&lt;/button&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const ChildMemo = React.memo(Child)</span><br><span class="line"></span><br><span class="line">const Parent = () =&gt; &#123;</span><br><span class="line">  const [text, updateText] = useState(&#x27;&#x27;);</span><br><span class="line">  const textRef = useRef();</span><br><span class="line"></span><br><span class="line">  const handleSubmit = useCallback(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;当前输入框的值:&#x27;, textRef.current);</span><br><span class="line">  &#125;, [textRef])</span><br><span class="line"></span><br><span class="line">  // 当text的值变化的时候就会给textRef的current重新赋值</span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    textRef.current = text;</span><br><span class="line">  &#125;, [text]);</span><br><span class="line">  </span><br><span class="line">  return(</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      我是父组件</span><br><span class="line">      &lt;input type=&quot;text&quot; value=&#123;text&#125; onChange=&#123;(e) =&gt; updateText(e.target.value)&#125;/&gt;</span><br><span class="line">      &lt;ChildMemo onClick=&#123;handleSubmit&#125;/&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有 <code>useCallback</code> 情况下，<code>Child</code> 只会渲染一次，优化性能。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>hooks</tag>
      </tags>
  </entry>
  <entry>
    <title>一天一个hooks - useMemo</title>
    <url>/2021/07/29/hooks/useMemo/</url>
    <content><![CDATA[<p><img src="/2021/07/29/hooks/useMemo/image-20210729215900044.png" alt="image-20210729215900044"></p>
<blockquote>
<p>React 逐步使用 hooks 开发了，这是 React 原生的钩子函数</p>
</blockquote>
<span id="more"></span>



<h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p>该钩子做性能优化的，相当于 <code>shouldComponentUpdate</code>，防止相同组件重复渲染，只有在依赖列表 <code>deps</code> 发生变化时候，才会进行渲染，它可以确保依赖的值未发生改变的时候，不触发值改变。</p>
<p>第二参数含义：</p>
<ul>
<li>不传数组，每次更新都会重新计算</li>
<li>空数组，只会计算一次</li>
<li>依赖对应的值，当对应的值发生变化时，才会重新计算</li>
</ul>
<h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p><code>useMemo</code> 这个钩子是做性能优化的，我们在写类组件时候，每次性能优化，都会涉及到 <code>shouldComponentUpdate</code> 钩子，如果每次都写，不好维护，现在这个钩子，它的第二个参数，里面放着依赖列表，只有当依赖列表中的值发生了变化，才会渲染。</p>
<p>我们知道 <code>React</code> 的渲染逻辑是父组件 -&gt; 子组件，没做性能优化前，父组件发生了渲染，就算子组件值没变化，也会进行渲染，这样就造成了额外的开销，通过 <code>useMemo</code> 钩子，我们可以给定子组件渲染的依赖列表，防止过度渲染。</p>
<p>我们从源码中可以发现，在 <code>useMemo</code> 钩子中，会执行 <code>nextCreate</code> 函数，该函数返回了一个值，这里的值可不是我们理解的基本数据类型，如果是个计算函数，值可能是基本数据类型，如果是个渲染函数，值可能是一个组件，一开始看时候总和 <code>useCallback</code> 搞晕，说他们的区别在于 <code>useMemo</code> 返回的是值，<code>useCallback</code> 返回的是回调函数，<code>useCallback</code> 的回调函数是指，<code>useCallback</code> 钩子内部是不会执行 <code>nextCreate</code> 函数的，也可以这样理解 <code>useMemo</code> 相当于 <code>apply</code>，<code>useCallback</code> 相当于 bind。</p>
<p>一般来说 <code>useMemo</code> 优化针对于当前组件高开销的计算，也就是说它常用于返回一个基本类型</p>
<p><strong><code>useMemo</code> 计算结果是 <code>return</code> 回来的值, 主要用于 缓存计算结果的值 ，应用场景如： 需要计算的状态</strong></p>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><h4 id="挂载阶段"><a href="#挂载阶段" class="headerlink" title="挂载阶段"></a>挂载阶段</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const HooksDispatcherOnMount: Dispatcher = &#123;</span><br><span class="line">  ...</span><br><span class="line">  useMemo: mountMemo,</span><br><span class="line"> 	...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function mountMemo&lt;T&gt;(</span><br><span class="line">  nextCreate: () =&gt; T, // 执行函数</span><br><span class="line">  deps: Array&lt;mixed&gt; | void | null, // 监听变化</span><br><span class="line">): T &#123;</span><br><span class="line">  // 创建一个新的Hook实例</span><br><span class="line">  const hook = mountWorkInProgressHook();</span><br><span class="line">  const nextDeps = deps === undefined ? null : deps;</span><br><span class="line">  // 计算传入 useMemo 回调函数的值</span><br><span class="line">  const nextValue = nextCreate();</span><br><span class="line">  hook.memoizedState = [nextValue, nextDeps];</span><br><span class="line">  return nextValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个阶段做了以下事情</p>
<ul>
<li>创建一个新的 <code>Hook</code> 实例</li>
<li>计算传入 <code>useMemo</code> 回调函数的值</li>
<li>将计算结果以及结果的依赖记录到 <code>Hook</code> 实例对象的 <code>memoizedState</code> 属性</li>
<li>返回回调函数的值</li>
</ul>
<h4 id="更新阶段"><a href="#更新阶段" class="headerlink" title="更新阶段"></a>更新阶段</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const HooksDispatcherOnUpdate: Dispatcher = &#123;</span><br><span class="line">  ...</span><br><span class="line">  useMemo: updateMemo,</span><br><span class="line"> 	...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function updateMemo&lt;T&gt;(</span><br><span class="line">  nextCreate: () =&gt; T,</span><br><span class="line">  deps: Array&lt;mixed&gt; | void | null,</span><br><span class="line">): T &#123;</span><br><span class="line">  // 获取Mount阶段创建的Hook实例</span><br><span class="line">  const hook = updateWorkInProgressHook();</span><br><span class="line">  const nextDeps = deps === undefined ? null : deps;</span><br><span class="line">  const prevState = hook.memoizedState;</span><br><span class="line">  if (prevState !== null) &#123;</span><br><span class="line">    // Assume these are defined. If they&#x27;re not, areHookInputsEqual will warn.</span><br><span class="line">    if (nextDeps !== null) &#123;</span><br><span class="line">      const prevDeps: Array&lt;mixed&gt; | null = prevState[1];</span><br><span class="line">      // 比较前后两次依赖是否相同</span><br><span class="line">      if (areHookInputsEqual(nextDeps, prevDeps)) &#123;</span><br><span class="line">        // 两次依赖的值相同，直接返回上一次的计算的结果</span><br><span class="line">        return prevState[0];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 再次进行计算，并记录结果，返回新的结果</span><br><span class="line">  const nextValue = nextCreate();</span><br><span class="line">  hook.memoizedState = [nextValue, nextDeps];</span><br><span class="line">  return nextValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这一阶段和上面的挂载阶段不太一样</p>
<ul>
<li><p>获取 <code>mount</code> 阶段创建的 <code>Hook</code> 实例</p>
</li>
<li><p>比较两次依赖的值是否相同</p>
</li>
<li><p>如果两次依赖的值相同，直接返回上一次的计算的结果</p>
</li>
<li><p>如果两次依赖的值不相同，则再次进行计算，并记录结果，返回新的结果。</p>
</li>
</ul>
<h4 id="渲染阶段"><a href="#渲染阶段" class="headerlink" title="渲染阶段"></a>渲染阶段</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const HooksDispatcherOnRerender: Dispatcher = &#123;</span><br><span class="line">  ...</span><br><span class="line">  useMemo: updateMemo,</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Rerender阶段中的逻辑与Update阶段一样。</p>
<h4 id="areHookInputsEqual"><a href="#areHookInputsEqual" class="headerlink" title="areHookInputsEqual"></a>areHookInputsEqual</h4><p>这里用到了一个对比函数 <code>areHookInputsEqual</code>，它的实现也很简单，看似很长，说白了就是一个 <code>is</code> 函数，该函数作用就是比较两个值是否相等。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function areHookInputsEqual(</span><br><span class="line">  nextDeps: Array&lt;mixed&gt;,</span><br><span class="line">  prevDeps: Array&lt;mixed&gt; | null,</span><br><span class="line">) &#123;</span><br><span class="line">  if (__DEV__) &#123;</span><br><span class="line">    if (ignorePreviousDependencies) &#123;</span><br><span class="line">      // Only true when this component is being hot reloaded.</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (prevDeps === null) &#123;</span><br><span class="line">    if (__DEV__) &#123;</span><br><span class="line">      console.error(</span><br><span class="line">        &#x27;%s received a final argument during this render, but not during &#x27; +</span><br><span class="line">          &#x27;the previous render. Even though the final argument is optional, &#x27; +</span><br><span class="line">          &#x27;its type cannot change between renders.&#x27;,</span><br><span class="line">        currentHookNameInDev,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (__DEV__) &#123;</span><br><span class="line">    // Don&#x27;t bother comparing lengths in prod because these arrays should be</span><br><span class="line">    // passed inline.</span><br><span class="line">    if (nextDeps.length !== prevDeps.length) &#123;</span><br><span class="line">      console.error(</span><br><span class="line">        &#x27;The final argument passed to %s changed size between renders. The &#x27; +</span><br><span class="line">          &#x27;order and size of this array must remain constant.\n\n&#x27; +</span><br><span class="line">          &#x27;Previous: %s\n&#x27; +</span><br><span class="line">          &#x27;Incoming: %s&#x27;,</span><br><span class="line">        currentHookNameInDev,</span><br><span class="line">        `[$&#123;prevDeps.join(&#x27;, &#x27;)&#125;]`,</span><br><span class="line">        `[$&#123;nextDeps.join(&#x27;, &#x27;)&#125;]`,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 依次比较前后两个依赖中的值</span><br><span class="line">  for (let i = 0; i &lt; prevDeps.length &amp;&amp; i &lt; nextDeps.length; i++) &#123;</span><br><span class="line">    if (is(nextDeps[i], prevDeps[i])) &#123;</span><br><span class="line">      continue;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个 <code>is</code> 函数，如果支持 Object.is 的情况下直接调用，否则 React 自己实现了一个 is 函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function is(x: any, y: any) &#123;</span><br><span class="line">  return (</span><br><span class="line">    (x === y &amp;&amp; (x !== 0 || 1 / x === 1 / y)) || (x !== x &amp;&amp; y !== y) // eslint-disable-line no-self-compare</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const objectIs: (x: any, y: any) =&gt; boolean =</span><br><span class="line">  typeof Object.is === &#x27;function&#x27; ? Object.is : is;</span><br></pre></td></tr></table></figure>



<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p><strong>返回是基本数据类型值</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// count 发生变化时，sum 的值会改变</span><br><span class="line">const sum = useMemo(() =&gt; &#123;</span><br><span class="line">  return count + 1;</span><br><span class="line">&#125;, [count]);</span><br></pre></td></tr></table></figure>



<p><strong>返回一个组件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// </span><br><span class="line">const Child = useMemo((&#123; clickChild, count &#125;) =&gt; &#123;</span><br><span class="line">    console.log(&#x27;Child render &gt;&gt;&#x27; + count)</span><br><span class="line">    return &lt;button onClick=&#123;clickChild&#125;&gt;clickChild&lt;/button&gt;</span><br><span class="line">&#125;, [count])</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>hooks</tag>
      </tags>
  </entry>
  <entry>
    <title>一天一个hooks - useBoolean</title>
    <url>/2021/07/28/hooks/useBoolean/</url>
    <content><![CDATA[<blockquote>
<p>React 逐步使用 hooks 开发了，原生的 hooks 不能满足开发需求，ahooks 是个优秀的库，每天学一个 hooks 理解其原理和内部实现</p>
</blockquote>
<h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; useMemo &#125; = from &#x27;react&#x27;</span><br><span class="line">const useBoolean = (initValue) =&gt; &#123;</span><br><span class="line">	const [state, setState] = useStatus(initValue)</span><br><span class="line">	const action = &#123;</span><br><span class="line">		toggle: () =&gt; setState(!state),</span><br><span class="line">		setTrue: () =&gt; setState(true),</span><br><span class="line">		setFalse: () =&gt; setState(false),</span><br><span class="line">	&#125;</span><br><span class="line">	return [state, action]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



































]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>hooks</tag>
      </tags>
  </entry>
  <entry>
    <title>一天一个hooks - useToggle</title>
    <url>/2021/07/28/hooks/useToggle/</url>
    <content><![CDATA[<p><img src="/2021/07/28/hooks/useToggle/image-20210730102915516.png" alt="image-20210730102915516"></p>
<h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p>该钩子用于两个状态值之间的切换，它接收两个参数，默认值<code>defaultValue</code>，取反值 <code>reverseValue</code>，如果不传参，默认为 <code>false</code>， 提供三个方法，toggle，setLeft，setRight。</p>
<ul>
<li>toggle：用于切换两个传入参数的值</li>
<li>setLeft：设置为 defaultValue 值</li>
<li>setRight：设置为 reverseValue 值</li>
</ul>
<span id="more"></span>

<h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p>这个钩子是用于两个值之间的切换，可用在弹出层 <code>open</code>，<code>close</code> 等。源码其实蛮好理解的，<code>useMemo</code> 是个性能优化，防止父组件在渲染时候，也渲染了子组件，<code>useToggle</code> 的唯一渲染条件是 <code>defaultValue</code>  或 <code>reverseValue</code> 发生了变化。</p>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; useState, useMemo &#125; from &quot;react&quot;</span><br><span class="line">type IState = string | number | boolean | undefined</span><br><span class="line"></span><br><span class="line">export interface Actions&lt;T = IState&gt; &#123; //  函数接口泛型</span><br><span class="line">  toggle: (state?: T) =&gt; void</span><br><span class="line">  setLeft: () =&gt; void</span><br><span class="line">  setRight: () =&gt; void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 泛型函数，多个说明函数可能存在多种情况</span><br><span class="line">function useToggle&lt;T = boolean | undefined&gt;(): [boolean, Actions&lt;T&gt;]</span><br><span class="line">function useToggle&lt;T = IState&gt;(defaultValue: T): [T, Actions&lt;T&gt;]</span><br><span class="line">function useToggle&lt;T = IState, U = IState&gt;(</span><br><span class="line">  defaultValue: T,</span><br><span class="line">  reverseValue: U,</span><br><span class="line">): [T | U, Actions&lt;T | U&gt;]</span><br><span class="line"></span><br><span class="line">function useToggle&lt;D extends IState = IState, R extends IState = IState&gt;(</span><br><span class="line">  defaultValue: D = false as D,</span><br><span class="line">  reverseValue?: R,</span><br><span class="line">) &#123;</span><br><span class="line">  const [state, setState] = useState&lt;D | R&gt;(defaultValue)</span><br><span class="line">  const actions = useMemo(() =&gt; &#123;</span><br><span class="line">    const reverseValueOrigin = (reverseValue === undefined ? !defaultValue : reverseValue) as D | R</span><br><span class="line">    // 切换返回值</span><br><span class="line">    const toggle = (value?: D | R) =&gt; &#123;</span><br><span class="line">    	// 强制返回状态值，适用于点击操作</span><br><span class="line">      if (value !== undefined) &#123;</span><br><span class="line">        setState(value)</span><br><span class="line">        return</span><br><span class="line">      &#125;</span><br><span class="line">      setState((s) =&gt; (s === defaultValue ? reverseValueOrigin : defaultValue))</span><br><span class="line">    &#125;</span><br><span class="line">    // 设置默认值</span><br><span class="line">    const setLeft = () =&gt; setState(defaultValue)</span><br><span class="line">    // 设置取反值</span><br><span class="line">    const setRight = () =&gt; setState(reverseValueOrigin)</span><br><span class="line">    return &#123;</span><br><span class="line">      toggle,</span><br><span class="line">      setLeft,</span><br><span class="line">      setRight,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [defaultValue, reverseValue])</span><br><span class="line">  return [state, actions]</span><br><span class="line">&#125;</span><br><span class="line">export default useToggle</span><br></pre></td></tr></table></figure>

<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export default () =&gt; &#123;</span><br><span class="line">  const [state, &#123; toggle, setTrue, setFalse &#125;] = useToggle();</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;Effects：&#123;`$&#123;state&#125;`&#125;&lt;/p&gt;</span><br><span class="line">      &lt;p&gt;</span><br><span class="line">        &lt;button type=&quot;button&quot; onClick=&#123;() =&gt; toggle()&#125;&gt;</span><br><span class="line">          Toggle</span><br><span class="line">        &lt;/button&gt;</span><br><span class="line">        &lt;button type=&quot;button&quot; onClick=&#123;() =&gt; setTrue()&#125;&gt;</span><br><span class="line">          setTrue</span><br><span class="line">        &lt;/button&gt;</span><br><span class="line">        &lt;button type=&quot;button&quot; onClick=&#123;() =&gt; setFalse()&#125;&gt;</span><br><span class="line">          setFalse</span><br><span class="line">        &lt;/button&gt;</span><br><span class="line">      &lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>hooks</tag>
      </tags>
  </entry>
  <entry>
    <title>一天一个hooks - useUrlState</title>
    <url>/2021/07/28/hooks/useUrlState/</url>
    <content><![CDATA[<blockquote>
<p>React 逐步使用 Hooks</p>
</blockquote>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>hooks</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式实战</title>
    <url>/2021/07/27/frontEnd/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p><img src="/2021/07/27/frontEnd/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/image-20210727164143669.png" alt="image-20210727164143669"></p>
<span id="more"></span>



<p><strong>写正则表达式第一步，要先匹配，匹配的出来，再去执行的提取，替换，搜索等操作</strong></p>
<p>在前端中，正则表达式有几种表现形式</p>
<p>对于 string 而言，提供了 match，matchAll，search，replace，split</p>
<p>对于 regExp 而言，提供了exec，test，</p>
<p>正则表达式在工作中有几种使用场景，提取，测试，替换，搜索</p>
<h2 id="提取"><a href="#提取" class="headerlink" title="提取"></a>提取</h2><blockquote>
<p>指在一个字符串中，提取用户想要的数据，譬如说，<code>abcde12345</code> 中提取英文字母 <code>abcde</code></p>
</blockquote>
<p>提取涉及的方法是 match 和 exec，提取是对标志位敏感的，也就是 <code>g</code></p>
<p><strong>返回值</strong></p>
<ul>
<li><p>如果使用g标志，则将返回与完整正则表达式匹配的所有结果，但不会返回<strong>捕获组</strong>。</p>
</li>
<li><p>如果未使用g标志，则仅返回第一个完整匹配及其相关的捕获组（<code>Array</code>）。 在这种情况下，返回的项目将具有如下所述的其他属性。</p>
</li>
<li><p>其他属性</p>
<ul>
<li><code>groups</code>: 一个捕获组数组 或 <code>undefined</code>（如果没有定义命名捕获组）</li>
<li><code>index</code>: 匹配的结果的开始位置</li>
<li><code>input</code>: 搜索的字符串</li>
</ul>
</li>
</ul>
<p>一个 <code>Array</code>，其内容取决于global（<code>g</code>）标志的存在与否，如果未找到匹配则为 <code>null</code></p>
<p>正则表达式分组分为捕获组和非捕获组</p>
<h3 id="捕获组"><a href="#捕获组" class="headerlink" title="捕获组"></a>捕获组</h3><p>正则里面是用成对的小括号来表示<strong>分组（捕获组）</strong>的，如<code>(\d)</code>表示一个分组，<code>(\d)(\d)</code>表示有两个分组，<code>(\d)(\d)(\d)</code>表示有三个分组，有几对小括号元字符组成，就表示有几个分组，以此类推。</p>
<p><strong>想提取信息，要用捕获组，也就是<code>()</code>，由于要用到捕获组，这里不能带 g</strong></p>
<p>分组的意义在于：</p>
<ul>
<li><p>提取数据，或者说用于拆分匹配到的数据，也就是说，匹配到的数据可能很多，不好拆，这时候，就可以用捕获组了。</p>
<p>不使用捕获组情况，我们想提取数字，但它返回的是一个整体，达不到我们的预期</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; &#x27;abcde12345a12312312&#x27;.match(/[a-z]+\d+[a-z]+\d+/)</span><br><span class="line">&lt; [&quot;abcde12345a12312312&quot;, index: 0, input: &quot;abcde12345a12312312&quot;, groups: undefined]</span><br></pre></td></tr></table></figure>

<p>捕获组的数据从返回数组的第二个下标开始</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; &#x27;abcde12345a12312312&#x27;.match(/[a-z]+(\d+)[a-z]+(\d+)/)</span><br><span class="line">&lt; [&quot;abcde12345a12312312&quot;, &quot;12345&quot;, &quot;12312312&quot;, index: 0, input: &quot;abcde12345a12312312&quot;, groups: undefined]</span><br></pre></td></tr></table></figure></li>
<li><p>简写重复模式</p>
<blockquote>
<p>也就是说，重复的你不必要写多次，这里的重复是指强重复，不只是格式要相等，值也必须相等。</p>
</blockquote>
<p>譬如说重复数字</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; &#x27;1212aa1212&#x27;.match(/(\d&#123;4&#125;aa\1)/)</span><br><span class="line">&lt; [&quot;1212aa&quot;, &quot;1212aa&quot;, index: 0, input: &quot;1212aa1212&quot;, groups: undefined]</span><br><span class="line">// 前面捕获了1212，因此 \1 代表识别的 1212，也就是说他是用于相同值的</span><br><span class="line"></span><br><span class="line">&gt; &#x27;1212aa1313&#x27;.match(/(\d&#123;4&#125;)aa\1/)</span><br><span class="line">&lt; null</span><br><span class="line">// 因为 1313 不等于 1212，虽然格式还有类型都一样，但是也不行，反向引用可以理解为全匹配</span><br></pre></td></tr></table></figure>

<blockquote>
<p>正则里面，引用捕获组的语法是这样的number，其中number是大于等于1的正整数（PS：，group0表示整个正则表达式匹配到的内容，而捕获组的编号是从1开始的，也就是1，大多数正则引擎最大支持99个捕获组，也就是99）。我们知道，正则表达式是从字符串的左边开始往右匹配的，且一般都是消耗掉已经被匹配的字符串的（环视语法不需要消耗字符串）。因此，当前面已经出现了捕获组1、2、3等等的捕获组，我们就可以在后面的正则里面用1、2、3等来进行相应的引用了。</p>
</blockquote>
</li>
</ul>
<h4 id="命名捕获组"><a href="#命名捕获组" class="headerlink" title="命名捕获组"></a>命名捕获组</h4><p>捕获组分为编号捕获组和命名捕获组，上面的例子是编号捕获组，默认也是指编号捕获组。</p>
<p>命名捕获组的语法如下</p>
<blockquote>
<p><code>(?&lt;name&gt;group)</code> 或 <code>(?&#39;name&#39;group)</code>，其中<code>name</code>表示捕获组的名称，<code>group</code>表示捕获组里面的正则。</p>
</blockquote>
<p>命名捕获租和编号捕获组的区别在于前者更加直观，就好比域名和 IP 地址的关系一样，可以用名称描述捕获到的内容的含义。</p>
<p>譬如年月日</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 编号捕获组</span><br><span class="line">(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 命名捕获组</span><br><span class="line">(?&#x27;year&#x27;\d&#123;4&#125;)-(?&#x27;month&#x27;\d&#123;2&#125;)-(?&#x27;day&#x27;\d&#123;2&#125;)</span><br><span class="line">或</span><br><span class="line">(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)</span><br></pre></td></tr></table></figure>

<p>例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; &#x27;1992-01-01&#x27;.match(/(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/)</span><br><span class="line">&lt; [&quot;1992-01-01&quot;, &quot;1992&quot;, &quot;01&quot;, &quot;01&quot;,</span><br><span class="line">  	groups: &#123;</span><br><span class="line">     year: &quot;1992&quot;,</span><br><span class="line">     month: &quot;01&quot;,</span><br><span class="line">     day: &quot;01&quot;</span><br><span class="line">  &#125;]</span><br><span class="line">  </span><br><span class="line">&gt; &#x27;1992-01-01&#x27;.match(/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/)</span><br><span class="line">&lt; [&quot;1992-01-01&quot;, &quot;1992&quot;, &quot;01&quot;, &quot;01&quot;, groups: undefined]</span><br></pre></td></tr></table></figure>

<p>可以看出，用了命名捕获组，groups 里面才有值</p>
<blockquote>
<p>Q：命名捕获组能用?:改为非捕获组吗？</p>
<p>A：不行的，原因很简单，命名捕获组的作用本来就是为了更明确地给捕获组捕获到的内容命名的，如果能用?:改为非捕获组，那就失去了它本来的价值了。</p>
</blockquote>
<blockquote>
<p>Q：命名捕获组是怎么反向引用的？</p>
<p>A：可以用<code>\k&lt;name&gt;</code> 或 <code>\k&#39;name&#39;</code>的形式来对前面的命名捕获组捕获到的值进行引用。</p>
<p>​    <code>(\d&#123;2&#125;)\1</code><br>​    可以改写为<br>​    <code>(?&lt;key&gt;\d&#123;2&#125;)\k&lt;key&gt;</code><br>​    其中，<code>key</code>是我们对捕获组的命名，而<code>\k&lt;key&gt;</code>是对<code>key</code>这个分组捕获到的内容进行引用，所谓的引用，就是利用它前面匹配到的字符串的值</p>
</blockquote>
<h5 id="正则里面，怎么计算捕获组的个数"><a href="#正则里面，怎么计算捕获组的个数" class="headerlink" title="正则里面，怎么计算捕获组的个数?"></a>正则里面，怎么计算捕获组的个数?</h5><p>从左到右，计算 <code>(</code> 的个数，有几个 <code>(</code> 就有几个捕获组，编号的顺序也是按出现的先后顺序去排序的，但是有几个情况除外</p>
<ul>
<li><code>\(</code> 被转义过的括号不算</li>
<li><code>(?:)</code> 非捕获组不算</li>
<li><code>[(]</code> 放在方括号中的也不算，因为在方括号中也表示转义过，方括号表示<code>或</code>。</li>
</ul>
<p>该正则表达式有几个捕获组呢？</p>
<ul>
<li><p><code>(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)</code> </p>
<p>从左到右，可以发现有三个<code>(</code>，且没有除外的情况，因此有三个捕获组</p>
</li>
<li><p><code>(?:\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;1,2&#125;)</code></p>
<p>从左到右，有三个 <code>(</code>，第一个 <code>(</code> 是非捕获组，在除外情况中，因此，有两个捕获组</p>
</li>
<li><p> <code>(\d)|(\d)</code></p>
</li>
</ul>
<p>  这个情况呢？中间有个 <code>|</code> 表示或，也就是说前面那个正则匹配了，就不匹配后面，否则，就匹配后面的</p>
<p>  按照之前的讨论，从左到右，有两个 <code>(</code> ，且没有除外的情况，因此有两个捕获组，这时候小伙伴就问了，只捕获了一个呀，是的，只捕获了一个，不过捕获组还是两个，另外一个不参与匹配罢了。</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; &#x27;1992-01&#x27;.match(/(?&lt;month&gt;\d&#123;2&#125;)|(?&lt;day&gt;\d&#123;2&#125;)/)</span><br><span class="line">&lt; [&quot;19&quot;, &quot;19&quot;, undefined,</span><br><span class="line">		groups: &#123;</span><br><span class="line">			month: &quot;19&quot;,</span><br><span class="line">			day: undefined</span><br><span class="line">		&#125;</span><br><span class="line">	]</span><br></pre></td></tr></table></figure>

<p>  从打印信息可以看出，<code>month</code> 已经满足匹配条件了，因此 <code>day</code> 就不用参与匹配了 </p>
<h3 id="非捕获组"><a href="#非捕获组" class="headerlink" title="非捕获组"></a>非捕获组</h3><blockquote>
<p>非捕获组的语法是在捕获组的基础上，在左括号的右侧加上<code>?:</code>就可以了，那就是<code>(?:)</code></p>
<p>例如，<code>(\d)</code>表示捕获组，而<code>(?:\d)</code>表示非捕获组。</p>
<p>既然是非捕获组，那它就<strong>不会</strong>把正则匹配到的内容保存到分组里面。</p>
</blockquote>
<p>所以<code>(?:\d&#123;4&#125;)-(?:\d&#123;2&#125;)-(?:\d&#123;2&#125;)</code>和<code>\d&#123;4&#125;-\d&#123;2&#125;-\d&#123;2&#125;</code>匹配到的内容其实是一样的。</p>
<p>什么时候用到非捕获组呢？</p>
<ul>
<li><p>不需要用到分组里面的内容的时候，用非捕获组，主要是为了<code>提升效率</code>，因为捕获组多了一步保存数据的步骤，所以一般会多耗费一些时间，虽然时间很短。</p>
<p><code>(?:\d&#123;4&#125;)-(?:\d&#123;2&#125;)-(?:\d&#123;2&#125;)</code>和<code>\d&#123;4&#125;-\d&#123;2&#125;-\d&#123;2&#125;</code>虽然这两个是一样的，但一般情况下，为了提高些许的性能，还是推荐用非捕获组。</p>
</li>
<li><p>用在可选分支的时候，当我们<code>不需要分组里面的数据的时候</code>，也可以用非捕获组，如果需要的话，则用捕获组。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;123,234,345,657,789&#x27;.match(/^\d+(?:,\d+)*$/)</span><br></pre></td></tr></table></figure>

<p>通过 <code>^</code> 可以限制<strong>字符串</strong>以数字开头，<code>$</code>限制<strong>字符串</strong>以数字结尾，<code>()</code>用于分组，量词 <code>+</code>，<code>*</code> 用来对它前面的分组进行 0 次或多次的重复匹配。</p>
<blockquote>
<p><code>^</code>表示匹配开头位置，而<code>$</code>表示匹配结尾的位置。但我们需要对一个字符串模式进行校验的时候，一般需要在前后加上这两个限制符号，以保证是从开始位置开始匹配的，到某处结尾，不然校验的结果往往是不对的。比如校验手机号码、身份证号码、密码等等，就需要加上 <code>^</code> 和 <code>$</code> ；而如果只是<strong>匹配数据</strong>的话，一般是不需要加上的，因为我们要匹配的数据往往有可能在一大串字文本的任何位置上，加上了反而会适得其反。</p>
</blockquote>
</li>
</ul>
<p><strong>exec 和 match 用法是一样的，只不过 exec 用在 RegExp 类型中，而 match 用在 string 类型中</strong></p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><blockquote>
<p>用于校验正则表达式是否符合这一类的字符串</p>
</blockquote>
<p>测试涉及到的方法是 <code>test</code>，它对标志位敏感，也就是 <code>g</code></p>
<p><code>test</code> 比较简单，就是判断字符串中是否包含匹配结果，包含返回 <code>true</code>，不包含返回 <code>false</code>，常用于 <code>if</code> 语句中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/正则表达式/.test(str)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>没有 <code>g</code> 情况</p>
<p>这也是最常用的，它会根据你的字符串，进行匹配，若存在，就返回 <code>true</code>，否则返回 <code>false</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; /hello/.test(&#x27;hello hello world&#x27;)</span><br><span class="line">&lt; true</span><br></pre></td></tr></table></figure></li>
<li><p>有 <code>g</code> 情况</p>
<p>如果设置了全局标志位，<code>test</code> 的执行会改变正则表达式 <code>lastIndex</code> 属性，连续的执行 <code>test</code> 方法，后续的执行会从 <code>lastIndex</code> 处开始匹配字符串。</p>
<p>是不是很绕，下面用个例子来解释这句话</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; let reg = /hello/g</span><br><span class="line">	reg.test(&#x27;hello hello world&#x27;) // lastIndex 0</span><br><span class="line">	reg.test(&#x27;hello hello world&#x27;) // lastIndex 1</span><br><span class="line">	reg.test(&#x27;hello hello world&#x27;) // lastIndex 2 第三次从 world 开始匹配，不等于 hello 因此打印 false</span><br><span class="line">	</span><br><span class="line">&lt; true</span><br><span class="line">	true</span><br><span class="line">	false</span><br></pre></td></tr></table></figure>

<p>第三次为什么打印出了 false 呢？</p>
<p>就是因为这个 <code>g</code>， 它的出现，会将缓存下一次匹配的开始位置，注意，这里的 test 内容是可以动态改变的，但位置不变。也就是说</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; let reg = /hello/g</span><br><span class="line">	reg.test(&#x27;hello&#x27;)</span><br><span class="line">	reg.test(&#x27;hello hello&#x27;)</span><br><span class="line">	reg.test(&#x27;hello hello hello&#x27;)</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">&lt; true</span><br><span class="line">	true</span><br><span class="line">	true</span><br></pre></td></tr></table></figure>

<p>如果每次执行，都在字符串后增加字符，且这个字符满足正则表达式，则会一直匹配下去，永远为 <code>true</code>，<code>lastIndex</code> 只有匹配到 <code>false</code> 后，才会将 <code>lastIndex</code> 置为 <code>0</code>。</p>
</li>
</ul>
<h2 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h2><blockquote>
<p>将字符串的某一部分替换成另一部分</p>
</blockquote>
<p>在 JS 世界中，<code>String</code> 类型提供了 <code>replace</code> 方法，它用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。</p>
<p>它对标志位敏感，也就是 <code>g</code></p>
<p><code>replace</code> 接受两个参数</p>
<ul>
<li><code>pattern</code> 这个参数可以是字符串或是RegExp对象</li>
<li><code>replacement</code> 替换匹配项的字符串或处理函数的返回值</li>
</ul>
<p>返回值</p>
<ul>
<li><p>当未找到匹配项时，返回原始字符串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; &#x27;abcde&#x27;.replace(&#x27;zz&#x27;, &#x27;bb&#x27;)</span><br><span class="line">&lt; &#x27;abcde&#x27;</span><br></pre></td></tr></table></figure></li>
<li><p>当 <code>pattern</code> 为字符串或者为<strong>非全局</strong>的 <code>RegExp</code> 对象的时候，只替换找到的第一项匹配项。</p>
<p>为<strong>全局</strong> <code>RegExp</code> 对象的时候，全部替换</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; &#x27;aaaa&#x27;.replace(&#x27;a&#x27;, &#x27;c&#x27;)</span><br><span class="line">	&#x27;aaaa&#x27;.replace(/\w/, &#x27;c&#x27;)</span><br><span class="line">	&#x27;aaaa&#x27;.replace(/\w&#123;2&#125;/, &#x27;cc&#x27;)  // 这里是因为有两个 \w，替换成两个 cc</span><br><span class="line">	&#x27;aaaa&#x27;.replace(/\w/g, &#x27;c&#x27;)  // 有 g 说明全局 RegExp，全部替换</span><br><span class="line">&lt; &#x27;caaa&#x27;</span><br><span class="line">	&#x27;caaa&#x27;</span><br><span class="line">	&#x27;ccaa&#x27;</span><br><span class="line">	&#x27;cccc&#x27;</span><br></pre></td></tr></table></figure></li>
<li><p>当 <code>replacement</code> 为函数时</p>
<blockquote>
<p>函数的返回值将作为替换字符串</p>
<p>函数的参数对应匹配项，第一个参数是匹配的值，第二个参数是原字符串中匹配项的 index，第三个参数是输入值</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; &#x27;abcd&#x27;.replace(/\w/g, (v) =&gt; &#123; console.log(v) return &#x27;b&#x27; &#125;)</span><br><span class="line">&lt; </span><br><span class="line">	&#x27;a&#x27;</span><br><span class="line">	&#x27;b&#x27;</span><br><span class="line">	&#x27;c&#x27;</span><br><span class="line">	&#x27;d&#x27;</span><br><span class="line">	&#x27;bbbb&#x27;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; &#x27;a11bcd&#x27;.replace(/[a-z]/g, (...r) =&gt; &#123;console.log(r); return &#x27;ttt&#x27;&#125;)</span><br><span class="line">&lt; [&#x27;a&#x27;, 0, &#x27;a11bcd&#x27;]</span><br><span class="line">	[&#x27;b&#x27;, 3, &#x27;a11bcd&#x27;]</span><br><span class="line">	[&#x27;c&#x27;, 4, &#x27;a11bcd&#x27;]</span><br><span class="line">	[&#x27;d&#x27;, 5, &#x27;a11bcd&#x27;]</span><br><span class="line">	&#x27;ttt11ttttttttt&#x27;</span><br></pre></td></tr></table></figure></li>
<li><p>特殊的 <code>$</code></p>
<p><code>replacement</code> 中的 <code>$</code> 字符具有特定的含义。如下表所示，它说明从模式匹配得到的字符串将用于替换。</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>$1、$2、…、$99</td>
<td>表示在 <code>regexp</code> 中的第 1 到第 99 个分组</td>
</tr>
<tr>
<td>$&amp;</td>
<td>与 <code>regexp</code> 相匹配的子串</td>
</tr>
<tr>
<td>$`</td>
<td>位于匹配子串左侧的文本</td>
</tr>
<tr>
<td>$’</td>
<td>位于匹配子串右侧的文本</td>
</tr>
<tr>
<td>$$</td>
<td>直接量符号</td>
</tr>
</tbody></table>
<p><strong>替换的逻辑规则，首先要匹配上，然后才能替换，没有匹配上的保留原样</strong></p>
<ul>
<li><p>第一种情况</p>
<p>分组数据通过 <code>$</code> 表示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; &#x27;aas11AA&#x27;.replace(/([a-z]+)(\d+)/, &#x27;$1&#x27;);</span><br><span class="line">&lt; &#x27;aasAA&#x27;</span><br></pre></td></tr></table></figure>

<p>正则表达式匹配 <code>aas11</code>，$1 对应的是第一个分组 <code>([a-z]+)</code>，该分组对应的是 <code>aas</code>，因此 <code>aas11</code> 替换为 <code>aas</code></p>
<p>如果我们将第一个分组取消，同理得到结果是 <code>11AA</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; &#x27;aas11AA&#x27;.replace(/[a-z]+(\d+)/, &#x27;$1&#x27;)</span><br><span class="line">&lt; &#x27;11AA&#x27;</span><br></pre></td></tr></table></figure>

<p>如果 <code>$</code> 溢出怎么办?</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; &#x27;aas11AA&#x27;.replace(/([a-z]+)(\d+)/, &#x27;$9&#x27;)</span><br><span class="line">&lt; &#x27;$9AA&#x27;</span><br></pre></td></tr></table></figure>

<p>在这里 <code>$9</code> 是没有的，溢出了，只有 <code>$1</code> ，<code>$2</code>，那么它会当成普通字符处理</p>
</li>
</ul>
<ul>
<li><p>第二种情况</p>
<p><code>$&amp;</code> 就是将识别到的分组，替换，感觉是原封不动输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; &#x27;aas11AA11&#x27;.replace(/[a-z]+(\d+)/, &#x27;$&amp;&#x27;)</span><br><span class="line">&lt; &#x27;aas11AA11&#x27;</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>第三种情况</p>
<p>$` 分组左侧部分替换到分组中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; &#x27;aa11AA&#x27;.replace(/(\d+)/g, &#x27;$`&#x27;);</span><br><span class="line">&lt; &#x27;aaaaAA&#x27;</span><br></pre></td></tr></table></figure></li>
<li><p>第四种情况</p>
<p> <code>$&#39;</code> 分组右侧部分替换到分组中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; &#x27;aa11AA&#x27;.replace(/(\d+)/g, &#x27;$`&#x27;);</span><br><span class="line">&lt; &#x27;aaAAAA&#x27;</span><br></pre></td></tr></table></figure></li>
<li><p>第五种情况</p>
<p>将分组内容匹配成 <code>$</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; &#x27;aa11AA&#x27;.replace(/(\d+)/g, &#x27;$$&#x27;);</span><br><span class="line">&lt; &#x27;aa$AA&#x27;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>RegExp</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo Next8.6 美化指北</title>
    <url>/2021/07/20/hexo/HexoNext%E7%BE%8E%E5%8C%96%E6%8C%87%E5%8C%97/</url>
    <content><![CDATA[<p><img src="/2021/07/20/hexo/HexoNext%E7%BE%8E%E5%8C%96%E6%8C%87%E5%8C%97/image-20210720145832886.png" alt="image-20210720145832886"></p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// next info</span><br><span class="line">&#123;</span><br><span class="line">	&quot;name&quot;: &quot;hexo-theme-next&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;8.6.1&quot;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="自定义样式"><a href="#自定义样式" class="headerlink" title="自定义样式"></a>自定义样式</h3><blockquote>
<p>我们需要修改 next 的样式，譬如说增加背景色，圆角等，怎么改呢？</p>
</blockquote>
<p>到找到<code>主题配置</code>下的  <code>themes/next/_config.yml</code> 文件，搜索 <code>custom_file_path</code> 属性里面全是 style 配置，我们开启 <code>style</code> 自定义配置，我们可以找到很关键的一个词 <code>site directory</code> 也就是 <code>根配置</code> 下创建。</p>
<p><img src="/2021/07/20/hexo/HexoNext%E7%BE%8E%E5%8C%96%E6%8C%87%E5%8C%97/image-20210720150306885.png" alt="image-20210720150306885"></p>
<p>在 <code>source</code> 下创建了<code>_data</code> 目录，创建 styles.styl 文件，大功告成！可以自由修改博客样式了</p>
<p><img src="/2021/07/20/hexo/HexoNext%E7%BE%8E%E5%8C%96%E6%8C%87%E5%8C%97/image-20210720150539070.png" alt="image-20210720150539070"></p>
<p>效果，修改了圆角</p>
<p><img src="/2021/07/20/hexo/HexoNext%E7%BE%8E%E5%8C%96%E6%8C%87%E5%8C%97/image-20210720150834959.png" alt="image-20210720150834959"></p>
<h3 id="关闭加载动画"><a href="#关闭加载动画" class="headerlink" title="关闭加载动画"></a>关闭加载动画</h3><blockquote>
<p>next 动画感觉太慢了，不喜欢怎么办呢？</p>
</blockquote>
<p>全局搜索 <code>motion</code> 关键词， 在<code>_config.yml</code>中的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">motion:</span><br><span class="line">	enable: false # 关闭动画</span><br><span class="line">	# enable: true # 开启动画</span><br></pre></td></tr></table></figure>

<p>有的小伙伴说了，有没有办法调整动画速度呢？必须有的!</p>
<p>全局搜索，找到<code>motion.js</code> 文件，它是动画的加载执行脚本，我这个版本是在<code>themes/next/source/js/motion.js</code>里面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const DEFAULT_DURATION = 30 // 我在这里加个全局变量用于统一动画速度，值越大动画时间越长</span><br><span class="line">...</span><br><span class="line">bootstrap: function() &#123;</span><br><span class="line">  if (!CONFIG.motion.async) this.queue = [this.queue];</span><br><span class="line">  this.queue.forEach(sequence =&gt; &#123;</span><br><span class="line">    const timeline = window.anime.timeline(&#123;</span><br><span class="line">      duration: DEFAULT_DURATION,</span><br><span class="line">      easing  : &#x27;linear&#x27;</span><br><span class="line">    &#125;);</span><br><span class="line">    sequence.forEach(item =&gt; &#123;</span><br><span class="line">      if (item.deltaT) timeline.add(item, item.deltaT);</span><br><span class="line">      else timeline.add(item);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">function getMistLineSettings(targets) &#123;</span><br><span class="line">  sequence.push(&#123;</span><br><span class="line">    targets,</span><br><span class="line">    scaleX  : [0, 1],</span><br><span class="line">    duration: DEFAULT_DURATION,</span><br><span class="line">    deltaT  : &#x27;-=200&#x27;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>这里只显示核心代码，每个版本不太一样，搜索<code>duration</code>，修改后面的值即可。在这里，我喜欢快点，<code>30</code>感觉不错</p>
<h3 id="点击全文显示后从头开始"><a href="#点击全文显示后从头开始" class="headerlink" title="点击全文显示后从头开始"></a>点击全文显示后从头开始</h3><blockquote>
<p>8.0 以前版本有 scroll_to_more 属性去控制，8.0 后这个属性移除了</p>
</blockquote>
<p>官方认为 scroll_to_more 对任何 hexo 主题而言都是默认行为，要取消只能强制修改</p>
<p>找到<code>post.njk</code>文件，我这边的路径是<code>themes/next/layout/_macro/post.njk</code>，搜索<code>#more</code>，它是通过锚点定位去实现的，因此把<code>#more</code> 删除即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;post-button&quot;&gt;</span><br><span class="line">	&lt;a class=&quot;btn&quot; href=&quot;&#123;&#123; url_for(post.path) &#125;&#125;#more&quot; rel=&quot;contents&quot;&gt;</span><br><span class="line">		&#123;&#123; __(&#x27;post.read_more&#x27;) &#125;&#125; &amp;raquo;</span><br><span class="line">	&lt;/a&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>修改为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;post-button&quot;&gt;</span><br><span class="line">	&lt;a class=&quot;btn&quot; href=&quot;&#123;&#123; url_for(post.path) &#125;&#125;&quot; rel=&quot;contents&quot;&gt; // 删除了 #more</span><br><span class="line">		&#123;&#123; __(&#x27;post.read_more&#x27;) &#125;&#125; &amp;raquo;</span><br><span class="line">	&lt;/a&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>



<h3 id="开启人数统计"><a href="#开启人数统计" class="headerlink" title="开启人数统计"></a>开启人数统计</h3><p>搜索 <code>busuanzi_count</code> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Show Views / Visitors of the website / page with busuanzi.</span><br><span class="line"># For more information: http://ibruce.info/2015/04/04/busuanzi/</span><br><span class="line">busuanzi_count:</span><br><span class="line">  enable: true 										# 设true 开启</span><br><span class="line">  total_visitors: false						# 总阅读人数（uv数）底部显示</span><br><span class="line">  total_visitors_icon: fa fa-user # 阅读总人数的图标</span><br><span class="line">  total_views: false              # 总阅读次数（pv数）底部显示</span><br><span class="line">  total_views_icon: fa fa-eye			# 阅读总次数的图标</span><br><span class="line">  post_views: true								# 开启内容阅读次数 统计的是这篇文章的阅读次数</span><br><span class="line">  post_views_icon: far fa-eye			# 内容页阅读数的图标</span><br></pre></td></tr></table></figure>



<h3 id="开启阅读时长"><a href="#开启阅读时长" class="headerlink" title="开启阅读时长"></a>开启阅读时长</h3><blockquote>
<p>可以大概估算读完这篇文章需要多长时间</p>
</blockquote>
<p>我们需要用到 <code>hexo-word-counter</code>，在根目录(hexo)下<code>npm</code>这个包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-word-counter</span><br><span class="line">hexo clean</span><br></pre></td></tr></table></figure>

<p>并在<code>根目录</code>的<code>_config.yml</code>尾部添加如下配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">symbols_count_time:</span><br><span class="line">  symbols: true</span><br><span class="line">  time: true</span><br><span class="line">  total_symbols: false # 是否显示底部的统计字数</span><br><span class="line">  total_time: false # 是否显示底部的统计时间</span><br><span class="line">  exclude_codeblock: false</span><br><span class="line">  awl: 4</span><br><span class="line">  wpm: 275</span><br><span class="line">  suffix: &quot;mins.&quot;</span><br></pre></td></tr></table></figure>

<p>然后在<code>主题目录</code>下添加<code>_config.yml</code>修改如下配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Post wordcount display settings</span><br><span class="line"># Dependencies: https://github.com/next-theme/hexo-word-counter</span><br><span class="line">symbols_count_time:</span><br><span class="line">  separated_meta: true # 是否换行显示</span><br><span class="line">  item_text_total: false</span><br></pre></td></tr></table></figure>



<p>参数</p>
<ul>
<li>awl 平均字节长度（Average Word Length）默认为4<ul>
<li><code>CN ≈ 2</code></li>
<li><code>EN ≈ 5</code></li>
<li><code>RU ≈ 6</code></li>
</ul>
</li>
<li>wpm 每分钟阅读字数（Words Per Minute）默认为275<ul>
<li><code>Slow ≈ 200</code></li>
<li><code>Normal ≈ 275</code></li>
<li><code>Fast ≈ 350</code></li>
</ul>
</li>
</ul>
<p><em>如果文章中大多中文，那么设置<code>awl</code>为<code>2</code>，<code>wpm</code>为<code>300</code>比较合适</em></p>
<p><img src="/2021/07/20/hexo/HexoNext%E7%BE%8E%E5%8C%96%E6%8C%87%E5%8C%97/image-20210720191842299.png" alt="image-20210720191842299"></p>
<h3 id="增加相关文章功能"><a href="#增加相关文章功能" class="headerlink" title="增加相关文章功能"></a>增加相关文章功能</h3><blockquote>
<p>可以更方便，去引流</p>
</blockquote>
<p>在<code>根站点</code>安装<code>hexo-related-popular-posts</code>插件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-related-popular-posts --save</span><br></pre></td></tr></table></figure>

<p>在<code>主题配置文件</code>中开启相关功能</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">related_posts:</span><br><span class="line">  enable: true</span><br><span class="line">  title: 相关文章推荐      # 属性的命名</span><br><span class="line">  display_in_home: false # false代表首页不显示</span><br><span class="line">params:</span><br><span class="line">  maxCount: 5          # 最多5条</span><br><span class="line">  #PPMixingRate: 0.0    # 相关度</span><br><span class="line">  #isDate: true         # 是否显示日期</span><br><span class="line">  #isImage: false       # 是否显示配图</span><br><span class="line">  #isExcerpt: false     # 是否显示摘要</span><br></pre></td></tr></table></figure>



<p><img src="/2021/07/20/hexo/HexoNext%E7%BE%8E%E5%8C%96%E6%8C%87%E5%8C%97/image-20210720191909925.png" alt="image-20210720191909925"></p>
<h3 id="添加标签云"><a href="#添加标签云" class="headerlink" title="添加标签云"></a>添加标签云</h3><blockquote>
<p>在浏览文章时候可以将你的标签显示出来</p>
</blockquote>
<p>在<code>根目录</code>安装<code>hexo-tag-cloud</code> 插件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-tag-cloud --save</span><br></pre></td></tr></table></figure>

<p>在 <code>sidebar.njk</code> 中最下面添加如下代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% if theme.tag_cloud.enable and site.tags.length &gt; 1 %&#125;</span><br><span class="line">   &lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=&quot;/js/tagcloud.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">   &lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=&quot;/js/tagcanvas.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">   &lt;div class=&quot;widget-wrap&quot; id=&quot;tag-cloud&quot;&gt;</span><br><span class="line">       &lt;h3 class=&quot;widget-title&quot;&gt;标签云&lt;/h3&gt;</span><br><span class="line">       &lt;div id=&quot;myCanvasContainer&quot; class=&quot;widget tagcloud&quot;&gt;</span><br><span class="line">           &lt;canvas height=&quot;250&quot; id=&quot;resCanvas&quot; style=&quot;width=70%&quot;&gt;</span><br><span class="line">               &#123;&#123; list_tags() &#125;&#125;</span><br><span class="line">           &lt;/canvas&gt;</span><br><span class="line">       &lt;/div&gt;</span><br><span class="line">   &lt;/div&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<p><strong>图片和代码不一定对的上，以代码为主，因为改代码容易，没太大变化懒得修图了，图片只是告诉你修改地方的上下文罢了</strong></p>
<p><img src="/2021/07/20/hexo/HexoNext%E7%BE%8E%E5%8C%96%E6%8C%87%E5%8C%97/image-20210720200524161.png" alt="image-20210720200524161"></p>
<p>在<code>主题配置</code>中新增</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># hexo-tag-cloud</span><br><span class="line">tag_cloud:</span><br><span class="line">  enable: true # 这是我自己加的开关功能，感觉标签云蛮吃资源的，</span><br><span class="line">  textFont: Trebuchet MS, Helvetica</span><br><span class="line">  textColor: &#x27;#333&#x27;</span><br><span class="line">  textHeight: 25</span><br><span class="line">  outlineColor: &#x27;#E2E1D1&#x27;</span><br><span class="line">  maxSpeed: 0.5</span><br></pre></td></tr></table></figure>

<p>完成标签云配置</p>
<p>不过我发现一个问题，这个标签云不会自适应宽度，导致显示有问题，于是在任意一个 js 中注入次此代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const tagCloudBlock = document.getElementById(&#x27;tag-cloud&#x27;)</span><br><span class="line">const tagCloud = document.getElementById(&#x27;resCanvas&#x27;)</span><br><span class="line">tagCloud.setAttribute(&#x27;width&#x27;, tagCloudBlock.clientWidth)</span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/20/hexo/HexoNext%E7%BE%8E%E5%8C%96%E6%8C%87%E5%8C%97/image-20210720200725464.png" alt="image-20210720200725464"></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>[译] Google JavaScript 风格指南中 13 个值得注意的细节</title>
    <url>/2021/07/19/English/technicalTranslator/%5B%E8%AF%91%5DGoogleJavaScript%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97%E4%B8%AD13%E4%B8%AA%E5%80%BC%E5%BE%97%E6%B3%A8%E6%84%8F%E7%9A%84%E7%BB%86%E8%8A%82/</url>
    <content><![CDATA[<p><img src="/2021/07/19/English/technicalTranslator/[%E8%AF%91]GoogleJavaScript%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97%E4%B8%AD13%E4%B8%AA%E5%80%BC%E5%BE%97%E6%B3%A8%E6%84%8F%E7%9A%84%E7%BB%86%E8%8A%82/1.jpeg" alt="img"></p>
<blockquote>
<p>原文地址：<a href="https://medium.freecodecamp.org/google-publishes-a-javascript-style-guide-here-are-some-key-lessons-1810b8ad050b">13 Noteworthy Points from Google’s JavaScript Style Guide</a><br>原文作者：<a href="https://medium.freecodecamp.org/@dsimmons_23530">Daniel Simmons</a></p>
</blockquote>
<span id="more"></span>

<p>对编码风格不熟悉的人而言，<a href="https://google.github.io/styleguide/jsguide.html">Google 推出一套用于编写 JavaScript 代码的样式指南</a>， 并指出（谷歌认为）编写清晰易懂的代码最佳风格。</p>
<p>首先声明一点，以下规则并不是编写 Javascript 代码的硬性要求，仅是为了维持项目代码的一致性，Javascript 是一种灵活而宽松的语言，它允许各种风格。</p>
<p>Google 和 <a href="https://github.com/airbnb/javascript">Airbnb</a> 都推出了各自的编码风格指南，且是比较受欢迎的，如果你的项目中需要编写大量的JS代码，我绝对建议你阅读。</p>
<p>以下列出了在 Google JS 风格指南中我认为比较有趣且实用的 13 条规则</p>
<p>Google对编码中的每个细节点都进行了争议(标签, 空格,以及分号的使用)还有一些模糊的规范, 无疑, 这套风格肯定会改变我写JS的方式。</p>
<p>对每一条规则，我都会列出规范的摘要部分，然后是样式指南中的支持引用和详细描述规则，在恰当的情况下，我将举例说明，并与之和不遵循规则的代码进行对比。</p>
<p><strong>推荐使用空格, 而不是tab键</strong></p>
<blockquote>
<p>除了行终止符以外，ASCII 中的水平空格字符 (0x20) 是唯一一个表示空格的空白字符，这意味着 Tab 键并不适用于缩进。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">  function foo() &#123;</span><br><span class="line">  ∙∙∙∙let name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // bad</span><br><span class="line">  function bar() &#123;</span><br><span class="line">  ∙let name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // good</span><br><span class="line">  function baz() &#123;</span><br><span class="line">  ∙∙let name;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>推荐使用分号, 而不是将其省略</strong></p>
<blockquote>
<p>每条语句结束后必须带有分号，严禁依赖编译器自动插入分号。<br>虽然我无法想象为什么有人会反对这个想法，但是 JS 中一贯使用分号将成为新 “spaces versus tabs” 争论，Google 表示坚持分号的使用。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">let luke = &#123;&#125;</span><br><span class="line">let leia = &#123;&#125;</span><br><span class="line">[luke, leia].forEach(jedi =&gt; jedi.father = &#x27;vader&#x27;)</span><br><span class="line">// good</span><br><span class="line">let luke = &#123;&#125;;</span><br><span class="line">let leia = &#123;&#125;;</span><br><span class="line">[luke, leia].forEach((jedi) =&gt; &#123;</span><br><span class="line">  jedi.father = &#x27;vader&#x27;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>不要使用 ES6 模块</strong></p>
<blockquote>
<p>不要使用 ES6 模块（即 export 和 import 关键词），因为它们的语义尚未最终确定，注意，一旦语义完全标准化，将重新审视这条规则。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 现在先不要这样用:</span><br><span class="line">//------ lib.js ------</span><br><span class="line">export function square(x) &#123;</span><br><span class="line">    return x * x;</span><br><span class="line">&#125;</span><br><span class="line">export function diag(x, y) &#123;</span><br><span class="line">    return sqrt(square(x) + square(y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//------ main.js ------</span><br><span class="line">import &#123; square, diag &#125; from &#x27;lib&#x27;;</span><br></pre></td></tr></table></figure>

<p><strong>不推荐水平对齐（但不禁止）</strong></p>
<blockquote>
<p>首先水平对齐这种做法是允许的，但是在 Google 风格中并不推荐这种用法。甚至不需要在已使用过的地方保持水平对齐。<br>水平对齐即在代码中添加空格，使每一列对齐。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">&#123;</span><br><span class="line">  tiny:   42,  </span><br><span class="line">  longer: 435, </span><br><span class="line">&#125;;</span><br><span class="line">// good</span><br><span class="line">&#123;</span><br><span class="line">  tiny: 42, </span><br><span class="line">  longer: 435,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>不要再使用var</strong></p>
<blockquote>
<p>使用 const 或 let 声明所有局部变量，除非需要重新分配变量，否则默认使用 const，不推荐使用 var 关键词。<br>我仍然看见人们在 StackOverflow 和其他地方使用 var 代码示例。可能有人会为此反对，或者说这是一种旧习惯，要改变，比较困难。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">var example = 42;</span><br><span class="line">// good</span><br><span class="line">let example = 42;</span><br></pre></td></tr></table></figure>

<p><strong>首选箭头函数</strong><br>箭头函数提供一个简洁的句法，并解决了许多困难，首选箭头函数而不是函数关键词，尤其是嵌套函数<br>说句真心话，我认为箭头函数非常棒，因为他们更加简洁，更好看，事实证明，他们也有很重要的作用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">[1, 2, 3].map(function (x) &#123;</span><br><span class="line">  const y = x + 1;</span><br><span class="line">  return x * y;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">[1, 2, 3].map((x) =&gt; &#123;</span><br><span class="line">  const y = x + 1;</span><br><span class="line">  return x * y;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>使用模板字符串代替连接符</strong></p>
<blockquote>
<p>在复杂字符串上使用模板字符串 （``） 而是不是连接符 （+） ，特别是涉及多个字符串文字的情况下，模板字符串可以跨行</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">function sayHi(name) &#123;</span><br><span class="line">  return &#x27;How are you, &#x27; + name + &#x27;?&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// bad</span><br><span class="line">function sayHi(name) &#123;</span><br><span class="line">  return [&#x27;How are you, &#x27;, name, &#x27;?&#x27;].join();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// bad</span><br><span class="line">function sayHi(name) &#123;</span><br><span class="line">  return `How are you, $&#123; name &#125;?`;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">function sayHi(name) &#123;</span><br><span class="line">  return `How are you, $&#123;name&#125;?`;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>对长字符串不要使用行连续符</strong></p>
<blockquote>
<p>不要在普通字符串或模板字符串中使用行连续（即, 通过反斜杠结束字符串文字内的一行）尽管 ES5 允许这样做，如果有空格尾随在后面，它将会导致棘手的错误，并且对读者来说不那么明显。</p>
</blockquote>
<p>有趣的是，Google 和 Airbnb 都不赞同这种做法<a href="https://github.com/airbnb/javascript#strings--line-length">这又Airbnb规范</a></p>
<p>谷歌的建议是通过连接符来拆分长字符串（如下所示），而 Airbnb 则建议写成一行，允许出现长字符串（如果需要的话）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad (sorry, this doesn&#x27;t show up well on mobile)</span><br><span class="line">const longString = &#x27;This is a very long string that \</span><br><span class="line">    far exceeds the 80 column limit. It unfortunately \</span><br><span class="line">    contains long stretches of spaces due to how the \</span><br><span class="line">    continued lines are indented.&#x27;;</span><br><span class="line">// good</span><br><span class="line">const longString = &#x27;This is a very long string that &#x27; + </span><br><span class="line">    &#x27;far exceeds the 80 column limit. It does not contain &#x27; + </span><br><span class="line">    &#x27;long stretches of spaces since the concatenated &#x27; +</span><br><span class="line">    &#x27;strings are cleaner.&#x27;;</span><br></pre></td></tr></table></figure>
<p><strong>for…of是for循环首选</strong></p>
<blockquote>
<p>ES6 提供了三种不同的 for 循环。三个可用情况下，如果可以， 推荐优先使用 for-of 循环</p>
</blockquote>
<p>包括我在内, 也觉得这条规则有点奇怪，但是谷歌认为它作为 for 循环的首选将会非常优雅</p>
<p>我认为，for…in 循环更适合对象，而 for…of 更适合数组</p>
<p>虽然 Google 的规范并不一定能和我们想法相吻合, 但是它依旧觉得这种做法相当优雅</p>
<p><strong>不要使用eval()</strong></p>
<blockquote>
<p>不要使用 eval 或 Function(…String) 构造函数（代码加载器除外），这些功能具有潜在风险，并且在 CSP 环境中无法正常工作。</p>
</blockquote>
<p>对于 eval() 而言，在 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval">MDN 页面</a>甚至专门有一页去呼吁不要使用 eval()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">let obj = &#123; a: 20, b: 30 &#125;;</span><br><span class="line">let propName = getPropName();  // returns &quot;a&quot; or &quot;b&quot;</span><br><span class="line">eval( &#x27;var result = obj.&#x27; + propName );</span><br><span class="line">// good</span><br><span class="line">let obj = &#123; a: 20, b: 30 &#125;;</span><br><span class="line">let propName = getPropName();  // returns &quot;a&quot; or &quot;b&quot;</span><br><span class="line">let result = obj[ propName ];  //  obj[ &quot;a&quot; ] is the same as obj.a</span><br></pre></td></tr></table></figure>

<p><strong>常量应该用大写字母和下划线表示</strong></p>
<blockquote>
<p>常量名称使用 CONSTANT_CASE: 全部为大写字母，单词用下划线分割。</p>
</blockquote>
<p>如果你能确保一个变量不会再改变，你可以通过大写常量的名称来表明这一点，这使得常量的不变性在整个代码的使用中显而易见。</p>
<p>这个规则有个值得注意的例外是，如果常量是属于函数范围的，在这种情况下，应该将其用驼峰命名法来表示。<br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> // bad</span><br><span class="line">const number = 5;</span><br><span class="line">// good</span><br><span class="line">const NUMBER = 5;</span><br></pre></td></tr></table></figure><br><strong>每次只声明一个变量</strong></p>
<blockquote>
<p>每个局部声明只声明一个变量，例如 let a = 1, b = 2 是不被允许的。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">let a = 1, b = 2, c = 3;</span><br><span class="line">// good</span><br><span class="line">let a = 1;</span><br><span class="line">let b = 2;</span><br><span class="line">let c = 3;</span><br></pre></td></tr></table></figure>
<p><strong>使用单引号而不是双引号</strong></p>
<blockquote>
<p>普通的字符文本使用单引号（’）来分割，而不是双引号（”）</p>
<p>Tip: 如果一个字符串文本中包含单引号字符，请考虑使用模板字符串，而避免使用转义符号。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">let directive = &quot;No identification of self or mission.&quot;</span><br><span class="line">// bad</span><br><span class="line">let saying = &#x27;Say it ain\u0027t so.&#x27;;</span><br><span class="line">// good</span><br><span class="line">let directive = &#x27;No identification of self or mission.&#x27;;</span><br><span class="line">// good</span><br><span class="line">let saying = `Say it ain&#x27;t so`;</span><br></pre></td></tr></table></figure>

<p><strong>最后一点</strong><br>正如我一开始说的那样，以上这些规则并不是强制性的，Google 只是众多科技巨头中的一员，这些只是建议。</p>
<p>也就是说，看看像谷歌这样的公司提出的风格建议很有意思，它聘请了许多精彩的人，他们花了很多时间去编写优秀的代码。</p>
<p>如果你想遵循 “ Google 标准源码 ” 指南，你可以遵循这些规则，当然，很多人不同意，你可以部分遵循，甚至不遵循也可以。</p>
<p>我个人认为，很多情况下 Airbnb 比 Google 的规范更具吸引力，无论在何种情况下，一定要牢记，整个项目的编码风格要保持统一。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>translation</tag>
      </tags>
  </entry>
  <entry>
    <title>[译] 5个简单的步骤去理解 JSON Web Tokens(JWT)</title>
    <url>/2021/07/19/English/technicalTranslator/%5B%E8%AF%91%5D5%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%AD%A5%E9%AA%A4%E5%8E%BB%E7%90%86%E8%A7%A3JSONWebTokens(JWT)/</url>
    <content><![CDATA[<p><img src="/2021/07/19/English/technicalTranslator/[%E8%AF%91]5%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%AD%A5%E9%AA%A4%E5%8E%BB%E7%90%86%E8%A7%A3JSONWebTokens(JWT)/1.jpeg" alt="img"></p>
<blockquote>
<p>原文作者：<a href="https://medium.freecodecamp.org/@dsimmons_23530">Mikey Stecky-Efantis</a><br>原文地址：<a href="https://medium.com/vandium-software/5-easy-steps-to-understanding-json-web-tokens-jwt-1164c0adfcec">5 Easy Steps to Understanding JSON Web Tokens(JWT)</a></p>
</blockquote>
<span id="more"></span>

<p>在本文中， 将解释JSON Web Tokens（JWT）的基本原理以及使用他们的原因。JWT 是确保你应用程序信任和安全的重要部分。JWT 允许以安全的方式来声明，例如用户数据。</p>
<p>为了解释JWT如何工作，让我们从一个抽象的定义开始。</p>
<blockquote>
<p>一个 JSON Web Token（JWT）是一个 <a href="http://www.w3schools.com/json/">JSON 对象</a>，在 <a href="https://tools.ietf.org/html/rfc7519">RFC7519</a> 中定义为表示两方之间的一组信息的安全方式。该令牌由标头，有效负载和签名组成。<br>简单来说，JWT 只是一个具有以下格式的字符串</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">header.payload.signature</span><br></pre></td></tr></table></figure>
<p>应该注意的是，双引号字符串实际上被视为有效的 JSON 对象。</p>
<p>下面将展示实际使用 JWT 的方式和原因，我们将使用一个简单的例子（如下图所示），这个例子中的实体是用户，应用服务器，和认证服务器。认证服务器将提供 JWT 给用户，通过 JWT，用户可以安全的和应用服务器间进行通讯。</p>
<p><img src="/2021/07/19/English/technicalTranslator/[%E8%AF%91]5%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%AD%A5%E9%AA%A4%E5%8E%BB%E7%90%86%E8%A7%A3JSONWebTokens(JWT)/2.png" alt="img"><br>在这个例子中，用户第一次进入认证服务器并使用认证服务器登陆系统（例：在 Facebook 和 Google 中通过用户名和密码登陆，等）。认证服务器创建JWT并且发生给用户，当用户对应用程序进行 API 调用时，JWT将随着API一并传递。在此配置中，应用程序服务器将会进行认证配置，用于验证传入的JWT是否是由身份服务器创建的（稍后将详细解释验证过程)。因此，当用户使用带有JWT的API去发起调用请求时，该应用能够使用JWT去认证这个API是否来自被认证的用户。</p>
<p>现在，将更深入地研究JWT本身及其构建和认证的方式。</p>
<p>##Step1. 创建令牌头</p>
<p>JWT 的头部包含有关如何计算 JWT 签名的信息，其标头是以下格式的 JSON 对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;typ&quot;: &quot;JWT&quot;,</span><br><span class="line">  &quot;alg&quot;: &quot;HS256&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述 JSON 中，”typ” 键值指定了 JWT 对象，”alg”键值指定使用哪种散列算法来创建 JWT 签名组件。在这个例子中，我们使用 HMAC-SHA256 算法（一种使用密钥的散列算法）来计算签名（在步骤 3 中更详细地讨论）。</p>
<p>##Step2. 创建 PayLoad</p>
<p>PayLoad是存储在 JWT 里的内部数据（该数据也称为 JWT 的 “声明”）。在这个例子中，认证服务器创建一个JWT 用于存储用户信息，特别是用户ID。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;userId&quot;: &quot;b08f86af-35da-48f2-8fab-cef3904660bd&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们只将一个声明放入 payload 中，你也可以根据需要添加任意数量的声明。JWT关键信息（payload）有几种不同的标准声明，例如 “iss” 表示 issuer，”sub” 表示 subject还有 “exp” 表示expiration time。创建 JWT 时，这些字段非常有用，但是他们是可选的，想了解更多有关 JWT 标准字段的详细信息，请参阅 JWT 上的<a href="https://en.wikipedia.org/wiki/JSON_Web_Token#Standard_fields">维基百科</a>页面。</p>
<p>请记住，数据的大小会影响 JWT 的整体大小，通常这不是问题，但是，JWT 太大可能会对性能产生负面影响并导致延迟。 </p>
<p>##Step3. 创建签名<br>签名的计算方式通过以下的伪代码进行表述</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// signature algorithm</span><br><span class="line">data = base64urlEncode( header ) + “.” + base64urlEncode( payload )</span><br><span class="line">hashedData = hash( data, secret )</span><br><span class="line">signature = base64urlEncode( hashedData )</span><br></pre></td></tr></table></figure>
<p>该算法的作用是通过 <a href="http://kjur.github.io/jsjws/tool_b64uenc.html">base64url</a> 对步骤1和步骤2中创建的头和关键信息（payload）进行编码。然后通过点（.）来连接两个编码字符串，构成数据 data 。在 JWT 头部使用指定的<a href="https://en.wikipedia.org/wiki/Hash_function">散列</a>算法对数据字符串使用密钥进行散列，并将生成的散列数据分配给 hashedData。然后对该散列数据进行 base64url 编码以产生 JWT 签名。</p>
<p>在该例子中，头部和关键信息（payload）都是 base64url 编码的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// header</span><br><span class="line">eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9</span><br><span class="line">// payload</span><br><span class="line">eyJ1c2VySWQiOiJiMDhmODZhZi0zNWRhLTQ4ZjItOGZhYi1jZWYzOTA0NjYwYmQifQ</span><br></pre></td></tr></table></figure>
<p>然后，在编码头和编码关键负载（payload）中周期的加入携带密钥的应用指定签名算法，于是，我们得到签名所需的散列数据。在该例子中，这意味着应用HS256算法，并将密钥设置为字符串 “secret”，在数据字符串上获取 hashedDate 字符串，之后，通过 base64url 编码 hashedData 字符串，我们得到以下 JWT 签名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// signature</span><br><span class="line">-xN_h82PHVTCMA9vdoHrcZxH-x5mb11y1537t3rGzcM</span><br></pre></td></tr></table></figure>

<p>##Step4. 将 JWT 的所有组件（3个）组合在一起<br>我们已经创建了所有的组件（3个），现在我们可以通过它们来创建 JWT了。请记住 JWT 的结构 header.payload.signature ，我们使用通过 base64url 编码的 header 和 payload，以及步骤 3 中签署的签名，只需要组合这些组件并通过句号（.）分隔它们。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// JWT Token</span><br><span class="line">eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VySWQiOiJiMDhmODZhZi0zNWRhLTQ4ZjItOGZhYi1jZWYzOTA0NjYwYmQifQ.-xN_h82PHVTCMA9vdoHrcZxH-x5mb11y1537t3rGzcM</span><br></pre></td></tr></table></figure>

<p>通过浏览器，在<a href="https://jwt.io/">jwt.io</a>上你可以尝试创建属于自己的 JWT。</p>
<p>回到这个例子，现在该认证服务器能够发送 JWT 给用户了。</p>
<p>###JWT 如何保护我们的数据？<br>要理解使用 JWT 的目的，并而不是通过任何的方式手段去隐藏或者模糊数据。使用 JWT 的原因是为了证明发送的数据实际上是由真实的源创建的。</p>
<p>如上述步骤所示，JWT 内的数据经过编码和签名而不是加密的。编码数据的目的是转换数据的结构。一方面签名数据允许数据接收器验证数据源的真实性。因此，编码和签名数据不会保护数据。另一方面，加密的主要目的是保护数据并防止未经授权的访问。有关编码和加密之间差异的详细说明，以及有关散列如何工作的更多信息，请<a href="https://danielmiessler.com/study/encoding-encryption-hashing-obfuscation/#encoding">参阅此文章</a></p>
<blockquote>
<p>由于 JWT 仅被签名和编码，并且由于 JWT 未加密，因此 JWT 不保证敏感数据的任何安全性。</p>
</blockquote>
<p>##Step5. JWT 验证<br>在第三个例子中，我们使用由 HS256 算法签名的 JWT，其中只有身份验证服务器和应用服务器知道密钥。当应用程序设置其身份认证的时候，应用服务器从身份验证服务器接收密钥。由于应用程序知道密钥，因此当用户对应用程序调用JWT 连接的 API 时，应用程序可以在 JWT 上执行与步骤 3 相同的签名算法。然后该应用程序能够验证自身通过哈希操作获得的签名与 JWT 本身得到的签名是否匹配（即，它与由认证服务器创建的 JWT 签名匹配）。如果签名匹配，这意味着 JWT 有效，表示 API 的调用是来自认证服务器的。除此之外，如果签名不匹配，则表示收到的 JWT 无效，这意味着你的应用程序正受到潜在的攻击。因此，通过验证 JWT ，应用程序在自身和用户之间添加了一层信任。</p>
<p>##结论<br>我们了解了 JWT 是什么，如何创建和验证它们，以及如何使用它们来确保应用程序与其用户之间的信任关系。这是了解 JWT 的基础和起点。在确保应用程序中的信任和安全性难题中，JWT 只是其中之一。</p>
<p>应该注意的是，本文中描述的 JWT 认证设置使用的是对称密钥算法（HS256），你也可以以类似的方式设置 JWT 身份验证，除非你使用非对称算法（例如：RS256）这类算法的身份验证服务器具有密钥，并且应用程序服务器具有公钥。<a href="https://stackoverflow.com/questions/39239051/rs256-vs-hs256-whats-the-difference">查看此 Stack Overflow 问题</a>了解对称和非对称算法的差异性及其详细分类。</p>
<p>还应该注意，JWT 应该通过 HTTPS（而不是 HTTP）连接。HTTPS 可以有效的防止未经授权的用户通过<a href="https://en.wikipedia.org/wiki/HTTPS#Security">拦截服务器</a>和用户之间通讯的方式来发送 JWT。</p>
<p>此外，如果你的 JWT 关键信息（payload）有一部分过期了，那么整个 JWT 将被视为无效，不能再使用了。</p>
<!-- [1]: https://cdn-images-1.medium.com/max/2600/1*LI654qGDaGGtqPMoQtIWsw.jpeg -->
<!-- [2]: https://cdn-images-1.medium.com/max/1000/1*SSXUQJ1dWjiUrDoKaaiGLA.png -->

]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>translation</tag>
        <tag>token</tag>
      </tags>
  </entry>
  <entry>
    <title>VirtualDOM, Diff算法</title>
    <url>/2021/06/22/frontEnd/VirtualDOM,Diff%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p><img src="/2021/06/22/frontEnd/VirtualDOM,Diff%E7%AE%97%E6%B3%95/image-20210727205357377.png" alt="image-20210727205357377"></p>
<span id="more"></span>

<h2 id="什么是Virtual-DOM？"><a href="#什么是Virtual-DOM？" class="headerlink" title="什么是Virtual DOM？"></a>什么是Virtual DOM？</h2><p>在 vue 和 react 框架中，我们经常会听到一个概念，Virtual DOM，diff 算法，被搞得云里雾里，比较好理解的说法是</p>
<blockquote>
<p>Virtual DOM 是相对于真实 DOM 而言的，在Virtual DOM 还没有出来之前，我们要改变页面展示的内容只能通过DOM 操作函数遍历查询 DOM 树的方式找到 DOM 节点，然后修改样式或结构，再通过 <code>innerHTML</code> ，经历了无数次的渲染，来达到更新 ui 的目的，但有了Virtual DOM 以后，就可以通过 js 的方式来修改，最终只渲染一次，效率成倍提高呀</p>
</blockquote>
<p>上面的话没理解，没关系，简要概述下就是，<strong>Virtual DOM 是对真实 DOM 的一层抽象，是通过 js 来表述的，操作Virtual DOM 就是操作 js 对象，因此Virtual DOM 在增删改查的操作上都更优于真实 DOM</strong>，渲染上，如果直接操作真实 DOM 要渲染无数次，而操作Virtual DOM 只需要在最后的时候渲染即可。</p>
<h2 id="为什么Virtual-DOM-的性能开销会小呢？"><a href="#为什么Virtual-DOM-的性能开销会小呢？" class="headerlink" title="为什么Virtual DOM 的性能开销会小呢？"></a>为什么Virtual DOM 的性能开销会小呢？</h2><p>其实最核心的原因不是查找或修改真实 DOM 上面的开销，而是将真实 DOM 转换成 js，再进行数据通信这上面的开销。DOM 树的实现模块和 js 实现模块是两个不同的模块，在不同模块上操作是要增加成本的，就好比为什么汽油车要做到几秒破百需要很高成本，而电动车则轻轻松松，几 W 块的都可以实现。<br><br></p>
<h2 id="Virtual-DOM-解决了什么问题？"><a href="#Virtual-DOM-解决了什么问题？" class="headerlink" title="Virtual DOM 解决了什么问题？"></a>Virtual DOM 解决了什么问题？</h2><p>无论是 vue 框架还是 react 框架，解决一个问题的思路都是一样的，<strong>避免我们直接去操作 DOM</strong>，而是通过<strong>数据来驱动视图的更新</strong>，一旦状态发生了变化，就用模板引擎渲染整个视图，用新的视图替换调旧的视图。</p>
<p>通过上述表达，我们知道，每个框架只是用自己方式去解决同样的问题，<strong>维护状态，更新视图</strong>。而Virtual DOM 要解决的就是<strong>避免直接操作 DOM，降低渲染次数</strong>。</p>
<p>再打个比方，没有Virtual DOM，每一个状态的改变，都会发生真实 DOM 的渲染，这会浪费很多性能，这时候有了Virtual DOM，状态改变了，先修改 js 对象，过段时间发现，状态已经修改完了，再进行渲染。<strong>前者要渲染多次，后者只要渲染一次。</strong><br><br></p>
<h2 id="diff-算法又是什么？"><a href="#diff-算法又是什么？" class="headerlink" title="diff 算法又是什么？"></a>diff 算法又是什么？</h2><p>diff 算法是用来优化Virtual DOM 操作的，你想想，每次状态改变，都要把整个 js 对象重写一次，再全部重新渲染，工程量太大了，没有变的地方其实不需要渲染的，有没有一种方法，找出修改的地方，只针对局部节点进行渲染呢？就好像 ajax 局部刷新一样。</p>
<p>没错啦，想到这点，就是 diff 算法的作用了，它就是用来<strong>找不同</strong>的，然后再配合Virtual DOM，对视图进行局部渲染。<br><br></p>
<h2 id="Virtual-DOM-和原生的区别是什么？怎么更新-DOM？"><a href="#Virtual-DOM-和原生的区别是什么？怎么更新-DOM？" class="headerlink" title="Virtual DOM 和原生的区别是什么？怎么更新 DOM？"></a>Virtual DOM 和原生的区别是什么？怎么更新 DOM？</h2><p><img src="/2021/06/22/frontEnd/VirtualDOM,Diff%E7%AE%97%E6%B3%95/104177142-4a3d3780-5443-11eb-87cf-588a7b5606f2.png" alt="img"></p>
<p>我们看看一个真实 DOM 携带的属性，仅仅一层就超级庞大了</p>
<p>我们再看看Virtual DOM 如何描述一个节点的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var element = &#123;</span><br><span class="line">	tagName: &#x27;div&#x27;, // 节点名称</span><br><span class="line">	props: &#123;</span><br><span class="line">		id: &#x27;box&#x27;</span><br><span class="line">	&#125;</span><br><span class="line">	children: [</span><br><span class="line">		&#123;tagName: &#x27;span&#x27;, props: &#123; class: &#x27;item&#x27; &#125;, children: [&quot;1&quot;]&#125;,</span><br><span class="line">		&#123;tagName: &#x27;span&#x27;, props: &#123; class: &#x27;item&#x27; &#125;, children: [&quot;2&quot;]&#125;,</span><br><span class="line">		&#123;tagName: &#x27;span&#x27;, props: &#123; class: &#x27;item&#x27; &#125;, children: [&quot;3&quot;]&#125;,</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面对应的 HTML 写法是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">	&lt;span&gt;1&lt;/span&gt;</span><br><span class="line">	&lt;span&gt;2&lt;/span&gt;</span><br><span class="line">	&lt;span&gt;3&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>看吧，用Virtual DOM 表示是不是超级简单。</p>
<p>这样我们就可以通过 js 来抽象真实 DOM，我们把这个叫做 js 对象树。</p>
<p><em>好了，万事俱备，我们有了Virtual DOM 和 diff 算法怎么更新 DOM</em></p>
<p><strong>我们先将真实 DOM 抽象出来，形成一个 js 对象树，状态变化后，生成新的 js 对象树，通过 diff 算法对比新旧树的差异，将不同点记录下来，这就是我们需要对页面真正的 DOM 操作，然后再把它们应用在真正的 DOM 树上，页面就变更了，这样就可以做到，视图的结构确实是整个全新渲染了，但最后操作 DOM 的时候确实只变更有不同的地方。</strong></p>
<p>这就是Virtual DOM 算法，主体分为三部</p>
<ul>
<li>1、用 js 描述新旧树</li>
<li>2、用 diff 算法对比新旧树，找出修改点，并记录下来</li>
<li>3、将修改点应用到旧树所构建的真实 DOM 上，进行局部修改，视图就更新了</li>
</ul>
<p>Virtual DOM 本质就是在 js 和 真实 DOM 之间做了一层缓存，js 进行快处理，等确定最后数据了，再来修改真实 DOM<br><br></p>
<h2 id="diff-算法改变史"><a href="#diff-算法改变史" class="headerlink" title="diff 算法改变史"></a>diff 算法改变史</h2><p>计算一棵树形结构转换成另一棵树形结构的最少操作，是一个复杂且值得研究的问题。<strong>传统 diff 算法</strong>通过<strong>循环递归</strong>对节点进行依次对比，效率低下，算法复杂度达到 O(n^3)，其中 n 是树中节点的总数。O(n^3) 到底有多可怕，这意味着如果要展示1000个节点，就要依次执行上十亿次的比较。这种指数型的性能消耗对于前端渲染场景来说代价太高了！CPU 按每秒钟执行大约30亿条指令来计算，即便是最高效的实现，也不可能在一秒内计算出差异情况。</p>
<p>如果 React 只是单纯的引入 diff 算法而没有任何的优化改进，那么其效率是远远无法满足前端渲染所要求的性能。</p>
<p>因此，想要将 diff 思想引入 Virtual DOM，就需要设计一种稳定高效的 diff 算法，而 React 做到了！</p>
<p>React 怎么实现的呢？<br><br></p>
<h2 id="Virtual-DOM-算法实现"><a href="#Virtual-DOM-算法实现" class="headerlink" title="Virtual DOM 算法实现"></a>Virtual DOM 算法实现</h2><h3 id="1、用-js-抽象真实-DOM"><a href="#1、用-js-抽象真实-DOM" class="headerlink" title="1、用 js 抽象真实 DOM"></a>1、用 js 抽象真实 DOM</h3><p>js 来描述真实 DOM 结构只需要三个属性，tagName，props，children，我们封装一个构造函数来表示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Element(tagName, props, children) &#123;</span><br><span class="line">	this.tagName = tagName</span><br><span class="line">	this.props = props</span><br><span class="line">	this.children = children</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 渲染函数，用于构建真实 DOM</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Element.prototype.render = function () &#123;</span><br><span class="line">    const el = document.createElement(this.tagName) // 创建 DOM 节点</span><br><span class="line">    const props = this.props</span><br><span class="line"></span><br><span class="line">    for (let propName in props) &#123; // 为节点添加属性</span><br><span class="line">        const propValue = props[propName]</span><br><span class="line">        el.setAttribute(propName, propValue)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const children = this.children || []</span><br><span class="line">    children.forEach(child =&gt; &#123;</span><br><span class="line">        let childEl = (child instanceof Element) ?</span><br><span class="line">            child.render() : // 通过递归方式构建子节点</span><br><span class="line">            document.createTextNode(child)</span><br><span class="line">        el.appendChild(childEl)</span><br><span class="line">    &#125;)</span><br><span class="line">    return el</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构建Virtual DOM</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var div = Element(&#x27;div&#x27;, &#123; id: &#x27;box &#x27; &#125;, [</span><br><span class="line">    Element(&#x27;span&#x27;, &#123;class: &#x27;item&#x27;&#125;, [&#x27;Index 1&#x27;]),</span><br><span class="line">    Element(&#x27;span&#x27;, &#123;class: &#x27;item&#x27;&#125;, [&#x27;Index 2&#x27;]),</span><br><span class="line">    Element(&#x27;span&#x27;, &#123;class: &#x27;item&#x27;&#125;, [&#x27;Index 3&#x27;]),</span><br><span class="line">])</span><br></pre></td></tr></table></figure>

<p> 将真实 DOM 挂载到 body 中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var root = div.render()</span><br><span class="line">document.body.appendChild(root)</span><br></pre></td></tr></table></figure>

<p>如果只讲Virtual DOM，那么以上代码就描绘出基本思路了，但是，我们还有个 diff 算法，下面看看我们如何将 <strong>diff 算法</strong>融入到里面</p>
<h3 id="2、比较两棵树的差异-——-Diff-算法"><a href="#2、比较两棵树的差异-——-Diff-算法" class="headerlink" title="2、比较两棵树的差异 —— Diff 算法"></a>2、比较两棵树的差异 —— Diff 算法</h3><p>diff 算法是用于比较两棵 DOM 树<strong>差异</strong>的，也是Virtual DOM 最核心的算法，两颗树完全的 diff 算法是一个时间复杂度为 O(n ^ 3) 的问题，但是在前端中我们分析了可能存在的场景</p>
<ul>
<li>跨层级移动 DOM 元素操作特别少。</li>
<li>拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构。</li>
<li>对于同一层级的一组子节点，它们可以通过唯一 id 进行区分。</li>
</ul>
<p>因此做了些牺牲，提升了性能，它<strong>只会对同一个层级的元素进行对比</strong>。</p>
<p><img src="/2021/06/22/frontEnd/VirtualDOM,Diff%E7%AE%97%E6%B3%95/104267805-5f5ea880-54cd-11eb-8793-94ce6e09c8bb.png" alt="img"></p>
<p>这样上面的 div 只会和同一层级的 div 对比，第二层级的只会跟第二层级对比，这样算法的复杂度就可以达到 O(n)</p>
<p><strong>差异</strong></p>
<p>在前端中，对于 DOM 的差异可能会</p>
<ul>
<li>替换掉原来的节点，例如把上面的 div 换成 p</li>
<li>新增，删除，移动子节点</li>
<li>修改节点属性</li>
<li>修改文本节点内容</li>
</ul>
<p>因此根据差异，我们定义了几种差异类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var REPLACE = 0  // 节点替换</span><br><span class="line">var REORDER = 1  // 子节点操作</span><br><span class="line">var PROPS = 2  	 // 属性修改</span><br><span class="line">var TEXT = 3     // 修改文本</span><br></pre></td></tr></table></figure>

<p>对于节点替换，判断新旧节点的 tagName 是不是一样的，如果不一样，说明需要替换</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">patches[0] = [&#123;</span><br><span class="line">	type: REPALCE,</span><br><span class="line">	node: newNode // el(&#x27;section&#x27;, props. children)</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>

<p>给子节点增加新的属性 id，就记录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">patches[0] = [&#123;</span><br><span class="line">	type: REPLACE,</span><br><span class="line">	node: newNode // el(&#x27;selection&#x27;, props, children)</span><br><span class="line">&#125;, &#123;</span><br><span class="line">	type: PROPS,</span><br><span class="line">	props: &#123;</span><br><span class="line">		id: &#x27;container&#x27;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>

<p>如果是修改了文本节点，就记录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">patches[2] = [&#123;</span><br><span class="line">	type: TEXT,</span><br><span class="line">	content: &#x27;Virtual Dom&#x27;</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>

<p>如果是子节点替换呢？例如 <code>p，span，div</code>  替换成了 <code>div，p，span</code> 该如何对比呢？这就有两种情况了，同层级和非同层级，无论是那种情况，三种节点都会被替换掉，这样是不可取的，因为只是简单的移动就可以达到效果，没必要<strong>全部推倒重来</strong>，这样对 DOM 的开销也会非常的大。下面就会用到<strong>列表对比算法</strong>来优化节点替换操作</p>
<h4 id="列表对比算法"><a href="#列表对比算法" class="headerlink" title="列表对比算法"></a>列表对比算法</h4><p>假设现在可以英文字母唯一地标识每个子节点</p>
<p>旧的顺序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a b c d e f g h i</span><br></pre></td></tr></table></figure>

<p>现在对节点进行删除，插入，移动的操作，新增 j 节点，删除 e 节点，移动 h 节点</p>
<p>新的顺序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a b c h d f g i j</span><br></pre></td></tr></table></figure>

<p>现在知道了新旧节点的顺序，求最小的插入、删除操作（移动可以看成是删除和插入操作的结合）。这个问题抽象出来其实是字符串的最小编辑距离问题，最常见的解决算法是通过动态规划求解，时间复杂度为 O(M * N)。但是我们并不需要真的达到最小的操作，我们只需要优化一些比较常见的移动情况，牺牲一定 DOM 操作，让算法时间复杂度达到线性的 O(max(M, N))。</p>
<p>我们能够获取到某个父节点的子节点的操作，并记录下来</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">patches[0] = [&#123;</span><br><span class="line">	type: REORDER,</span><br><span class="line">	move: [&#123; remove or insert &#125;, &#123; remove or insert &#125;, ...]</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>

<p>但是要注意，因为 tagName 是可重复的，不能用这个来进行对比，所以需要给子节点加上唯一标识 key，列表对比的时候，使用 key 进行对比，这样才能复用老的 DOM 树上的节点。</p>
<p>这样，我们就可以通过深度优先遍历两棵树，每层的节点进行对比，记录下每个节点的差异了。</p>
<h4 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h4><p>diff 算法采用的是深度遍历，对新旧两棵树进行一个深度优先的遍历，这样每个节点都会有一个唯一的标记</p>
<p><img src="/2021/06/22/frontEnd/VirtualDOM,Diff%E7%AE%97%E6%B3%95/104269194-a7cb9580-54d0-11eb-8172-db4e6724361a.png" alt="img"></p>
<p>深度优先遍历的时候，每遍历到一个节点，就把该节点和新的树进行对比，如果有差异的话，就记录到一个对象里面。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// diff 函数，对比两棵树</span><br><span class="line">function diff(oldTree, newTree) &#123;</span><br><span class="line">	var index = 0 // 当前节点的标志</span><br><span class="line">  	var patches = &#123;&#125; // 用来记录每个节点差异的对象</span><br><span class="line">  	dfsWalk(oldTree, newTree, index, patches)</span><br><span class="line">  	return patches</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 对两棵树进行深度优先遍历</span><br><span class="line">function dfsWalk (oldNode, newNode, index, patches) &#123;</span><br><span class="line">  // 对比oldNode和newNode的不同，记录下来</span><br><span class="line">  patches[index] = [...]</span><br><span class="line"></span><br><span class="line">  diffChildren(oldNode.children, newNode.children, index, patches)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 遍历子节点</span><br><span class="line">function diffChildren (oldChildren, newChildren, index, patches) &#123;</span><br><span class="line">  var leftNode = null</span><br><span class="line">  var currentNodeIndex = index</span><br><span class="line">  oldChildren.forEach(function (child, i) &#123;</span><br><span class="line">    var newChild = newChildren[i]</span><br><span class="line">    currentNodeIndex = (leftNode &amp;&amp; leftNode.count) // 计算节点的标识</span><br><span class="line">      ? currentNodeIndex + leftNode.count + 1</span><br><span class="line">      : currentNodeIndex + 1</span><br><span class="line">    dfsWalk(child, newChild, currentNodeIndex, patches) // 深度遍历子节点</span><br><span class="line">    leftNode = child</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>譬如说上面的旧 div 和新 div 有差异，当前标记为 0，那么：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">patches[0] = [&#123;difference&#125;, &#123;difference&#125;, ...] // 用数组存储新旧节点的不同</span><br></pre></td></tr></table></figure>



<h3 id="3、把差异应用到真正的-DOM-树上"><a href="#3、把差异应用到真正的-DOM-树上" class="headerlink" title="3、把差异应用到真正的 DOM 树上"></a>3、把差异应用到真正的 DOM 树上</h3><p>对 DOM 树进行深度优先遍历后，通过 diff 算法（步骤2）获取到差异点，然后进行 DOM 操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function patch(node, patches) &#123;</span><br><span class="line">	var walker = &#123;index: 0&#125;</span><br><span class="line">	dfsWalk(node, walker, patches)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function dfsWalk(node, walker, patcher) &#123;</span><br><span class="line">	var currentPatches = patches[walker.index] // 从 patches 拿出当前节点的差异</span><br><span class="line">	var len = node.childNodes ? node.childNodes.length : 0</span><br><span class="line">	for(let i = 0; i &lt; len; i++) &#123;</span><br><span class="line">		var child = node.childNodes[i]</span><br><span class="line">		walker.index ++</span><br><span class="line">		dfsWalk(child, walker, patches)</span><br><span class="line">	&#125;</span><br><span class="line">	if(currentPatches) &#123;</span><br><span class="line">		applyPatches(node, currentPatches) // 对当前节点进行 DOM 操作</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>applyPatches，根据不同类型的差异对当前节点进行 DOM 操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function applyPatches(node, currentPatches) &#123;</span><br><span class="line">	currentPatches.forEach(function(currentPatch) &#123;</span><br><span class="line">		switch(currentPatch.type) &#123;</span><br><span class="line">			case REPLACE:</span><br><span class="line">				node.parentNode.replaceChild(currentPatch.node.render(), node)</span><br><span class="line">				break;</span><br><span class="line">			case REORDER:</span><br><span class="line">				reorderChildren(node, currentPatch.moves)</span><br><span class="line">				break;</span><br><span class="line">			case PROPS:</span><br><span class="line">				setProps(node, currentPatch.props)</span><br><span class="line">				break;</span><br><span class="line">			case TEXT:</span><br><span class="line">				node.textContent = currentPatch.content</span><br><span class="line">				break;</span><br><span class="line">			default:</span><br><span class="line">				throw new Error(&#x27;Unknown patch type &#x27; + currentPatch.type)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Virtual DOM 主要是实现了三个函数，分为 5 个步骤</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 1.构建Virtual DOM</span><br><span class="line">var tree = el(&#x27;div&#x27;, &#123;&#x27;id&#x27;: &#x27;container&#x27;&#125;, [</span><br><span class="line">	el(&#x27;h1&#x27;, &#123;style: &#x27;color: blue&#x27;&#125;, [&#x27;simple virtal dom&#x27;]),</span><br><span class="line">	el(&#x27;p&#x27;, [&#x27;Hello, virtual-dom&#x27;]),</span><br><span class="line">	el(&#x27;ul&#x27;, [el(&#x27;li&#x27;)])</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">// 2.通过Virtual DOM 构建真正的 DOM</span><br><span class="line">var root = tree.render()</span><br><span class="line">document.body.appendChild(root)</span><br><span class="line"></span><br><span class="line">// 3.生成新的Virtual DOM</span><br><span class="line">var newTree = el(&#x27;div&#x27;, &#123;&#x27;id&#x27;:  &#x27;container&#x27;&#125;, [</span><br><span class="line">	el(&#x27;h1&#x27;, &#123; style: &#x27;color: red&#x27; &#125;, [&#x27;simple virtal dom&#x27;]),</span><br><span class="line">	el(&#x27;p&#x27;, [&#x27;Hello, virtual-dom&#x27;]),</span><br><span class="line">	el(&#x27;ul&#x27;, [el(&#x27;li&#x27;), el(&#x27;li&#x27;)])</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">// 4.比较两颗Virtual DOM 树的不同</span><br><span class="line">var patches = diff(tree, newTree)</span><br><span class="line"></span><br><span class="line">// 5.在真正的 DOM 元素上应用变更</span><br><span class="line">patch(root, patches)</span><br></pre></td></tr></table></figure>

<p>这只是大致的思想，实践使用中还需要加入事件监听等。</p>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p><strong>优点</strong></p>
<ul>
<li>对 DOM 进行集中化操作：无需手动操作 DOM ，虚拟 DOM 的 diff 和 patch 都是在一次更新中自动进行的，在数据改变时先对 Virtual DOM 进行修改，再反应到真实 DOM 中，用最小的代价来更新 DOM，提高效率</li>
<li>跨平台：可以渲染到 DOM 以外的端，因为虚拟 DOM 本质是 JS 对象，而 DOM 和平台具有强关联，相比之下虚拟 DOM 可以更好的跨平台，比如移动端开发，React VR，服务端渲染等</li>
<li>保证了性能的下限：虚拟 DOM 可以通过 diff 算法找出最小差异，然后批量进行 patch，比起粗暴的 DOM 来说还说性能还是好很多的</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>首次渲染大量 DOM 时，由于多了一层虚拟 DOM 的计算，比 innerHTML 插入慢。</li>
<li>虚拟 DOM 需要在内存中的维护一份 DOM 的副本，多占用了部分内存。</li>
<li>如果虚拟 DOM 大量更改，这是合适的。但是单一的、频繁的更新的话，虚拟 DOM 将会花费更多的时间处理计算的工作。所以如果你有一个 DOM 节点相对较少页面，用虚拟 DOM，它实际上有可能会更慢，但对于大多数单页面应用，这应该都会更快。</li>
</ul>
<blockquote>
<p>参考 <a href="https://github.com/livoras/blog/issues/13">深度剖析如何实现一个 Virtual DOM 算法</a></p>
</blockquote>
<p>// diff.js 完整算法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var _ = require(&#x27;./util&#x27;)</span><br><span class="line">var patch = require(&#x27;./patch&#x27;)</span><br><span class="line">var listDiff = require(&#x27;list-diff2&#x27;)</span><br><span class="line"></span><br><span class="line">function diff (oldTree, newTree) &#123;</span><br><span class="line">  var index = 0</span><br><span class="line">  var patches = &#123;&#125;</span><br><span class="line">  dfsWalk(oldTree, newTree, index, patches)</span><br><span class="line">  return patches</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function dfsWalk (oldNode, newNode, index, patches) &#123;</span><br><span class="line">  var currentPatch = []</span><br><span class="line"></span><br><span class="line">  // Node is removed.</span><br><span class="line">  if (newNode === null) &#123;</span><br><span class="line">    // Real DOM node will be removed when perform reordering, so has no needs to do anything in here</span><br><span class="line">  // TextNode content replacing</span><br><span class="line">  &#125; else if (_.isString(oldNode) &amp;&amp; _.isString(newNode)) &#123;</span><br><span class="line">    if (newNode !== oldNode) &#123;</span><br><span class="line">      currentPatch.push(&#123; type: patch.TEXT, content: newNode &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  // Nodes are the same, diff old node&#x27;s props and children</span><br><span class="line">  &#125; else if (</span><br><span class="line">      oldNode.tagName === newNode.tagName &amp;&amp;</span><br><span class="line">      oldNode.key === newNode.key</span><br><span class="line">    ) &#123;</span><br><span class="line">    // Diff props</span><br><span class="line">    var propsPatches = diffProps(oldNode, newNode)</span><br><span class="line">    if (propsPatches) &#123;</span><br><span class="line">      currentPatch.push(&#123; type: patch.PROPS, props: propsPatches &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    // Diff children. If the node has a `ignore` property, do not diff children</span><br><span class="line">    if (!isIgnoreChildren(newNode)) &#123;</span><br><span class="line">      diffChildren(</span><br><span class="line">        oldNode.children,</span><br><span class="line">        newNode.children,</span><br><span class="line">        index,</span><br><span class="line">        patches,</span><br><span class="line">        currentPatch</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  // Nodes are not the same, replace the old node with new node</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    currentPatch.push(&#123; type: patch.REPLACE, node: newNode &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (currentPatch.length) &#123;</span><br><span class="line">    patches[index] = currentPatch</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function diffChildren (oldChildren, newChildren, index, patches, currentPatch) &#123;</span><br><span class="line">  var diffs = listDiff(oldChildren, newChildren, &#x27;key&#x27;)</span><br><span class="line">  newChildren = diffs.children</span><br><span class="line"></span><br><span class="line">  if (diffs.moves.length) &#123;</span><br><span class="line">    var reorderPatch = &#123; type: patch.REORDER, moves: diffs.moves &#125;</span><br><span class="line">    currentPatch.push(reorderPatch)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var leftNode = null</span><br><span class="line">  var currentNodeIndex = index</span><br><span class="line">  _.each(oldChildren, function (child, i) &#123;</span><br><span class="line">    var newChild = newChildren[i]</span><br><span class="line">    currentNodeIndex = (leftNode &amp;&amp; leftNode.count)</span><br><span class="line">      ? currentNodeIndex + leftNode.count + 1</span><br><span class="line">      : currentNodeIndex + 1</span><br><span class="line">    dfsWalk(child, newChild, currentNodeIndex, patches)</span><br><span class="line">    leftNode = child</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function diffProps (oldNode, newNode) &#123;</span><br><span class="line">  var count = 0</span><br><span class="line">  var oldProps = oldNode.props</span><br><span class="line">  var newProps = newNode.props</span><br><span class="line"></span><br><span class="line">  var key, value</span><br><span class="line">  var propsPatches = &#123;&#125;</span><br><span class="line"></span><br><span class="line">  // Find out different properties</span><br><span class="line">  for (key in oldProps) &#123;</span><br><span class="line">    value = oldProps[key]</span><br><span class="line">    if (newProps[key] !== value) &#123;</span><br><span class="line">      count++</span><br><span class="line">      propsPatches[key] = newProps[key]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Find out new property</span><br><span class="line">  for (key in newProps) &#123;</span><br><span class="line">    value = newProps[key]</span><br><span class="line">    if (!oldProps.hasOwnProperty(key)) &#123;</span><br><span class="line">      count++</span><br><span class="line">      propsPatches[key] = newProps[key]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // If properties all are identical</span><br><span class="line">  if (count === 0) &#123;</span><br><span class="line">    return null</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return propsPatches</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function isIgnoreChildren (node) &#123;</span><br><span class="line">  return (node.props &amp;&amp; node.props.hasOwnProperty(&#x27;ignore&#x27;))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = diff</span><br></pre></td></tr></table></figure>

<p>// element.js</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@george-es</span><br><span class="line"> </span><br><span class="line">Owner</span><br><span class="line">Author</span><br><span class="line">george-es commented on 12 Jan</span><br><span class="line">// element.js</span><br><span class="line"></span><br><span class="line">var _ = require(&#x27;./util&#x27;)</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Virtual-dom Element.</span><br><span class="line"> * @param &#123;String&#125; tagName</span><br><span class="line"> * @param &#123;Object&#125; props - Element&#x27;s properties,</span><br><span class="line"> *                       - using object to store key-value pair</span><br><span class="line"> * @param &#123;Array&lt;Element|String&gt;&#125; - This element&#x27;s children elements.</span><br><span class="line"> *                                - Can be Element instance or just a piece plain text.</span><br><span class="line"> */</span><br><span class="line">function Element (tagName, props, children) &#123;</span><br><span class="line">  if (!(this instanceof Element)) &#123;</span><br><span class="line">    if (!_.isArray(children) &amp;&amp; children != null) &#123;</span><br><span class="line">      children = _.slice(arguments, 2).filter(_.truthy)</span><br><span class="line">    &#125;</span><br><span class="line">    return new Element(tagName, props, children)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (_.isArray(props)) &#123;</span><br><span class="line">    children = props</span><br><span class="line">    props = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  this.tagName = tagName</span><br><span class="line">  this.props = props || &#123;&#125;</span><br><span class="line">  this.children = children || []</span><br><span class="line">  this.key = props</span><br><span class="line">    ? props.key</span><br><span class="line">    : void 666</span><br><span class="line"></span><br><span class="line">  var count = 0</span><br><span class="line"></span><br><span class="line">  _.each(this.children, function (child, i) &#123;</span><br><span class="line">    if (child instanceof Element) &#123;</span><br><span class="line">      count += child.count</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      children[i] = &#x27;&#x27; + child</span><br><span class="line">    &#125;</span><br><span class="line">    count++</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  this.count = count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Render the hold element tree.</span><br><span class="line"> */</span><br><span class="line">Element.prototype.render = function () &#123;</span><br><span class="line">  var el = document.createElement(this.tagName)</span><br><span class="line">  var props = this.props</span><br><span class="line"></span><br><span class="line">  for (var propName in props) &#123;</span><br><span class="line">    var propValue = props[propName]</span><br><span class="line">    _.setAttr(el, propName, propValue)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _.each(this.children, function (child) &#123;</span><br><span class="line">    var childEl = (child instanceof Element)</span><br><span class="line">      ? child.render()</span><br><span class="line">      : document.createTextNode(child)</span><br><span class="line">    el.appendChild(childEl)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  return el</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = Element</span><br></pre></td></tr></table></figure>

<p>// patch.js</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var _ = require(&#x27;./util&#x27;)</span><br><span class="line"></span><br><span class="line">var REPLACE = 0</span><br><span class="line">var REORDER = 1</span><br><span class="line">var PROPS = 2</span><br><span class="line">var TEXT = 3</span><br><span class="line"></span><br><span class="line">function patch (node, patches) &#123;</span><br><span class="line">  var walker = &#123;index: 0&#125;</span><br><span class="line">  dfsWalk(node, walker, patches)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function dfsWalk (node, walker, patches) &#123;</span><br><span class="line">  var currentPatches = patches[walker.index]</span><br><span class="line"></span><br><span class="line">  var len = node.childNodes</span><br><span class="line">    ? node.childNodes.length</span><br><span class="line">    : 0</span><br><span class="line">  for (var i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    var child = node.childNodes[i]</span><br><span class="line">    walker.index++</span><br><span class="line">    dfsWalk(child, walker, patches)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (currentPatches) &#123;</span><br><span class="line">    applyPatches(node, currentPatches)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function applyPatches (node, currentPatches) &#123;</span><br><span class="line">  _.each(currentPatches, function (currentPatch) &#123;</span><br><span class="line">    switch (currentPatch.type) &#123;</span><br><span class="line">      case REPLACE:</span><br><span class="line">        var newNode = (typeof currentPatch.node === &#x27;string&#x27;)</span><br><span class="line">          ? document.createTextNode(currentPatch.node)</span><br><span class="line">          : currentPatch.node.render()</span><br><span class="line">        node.parentNode.replaceChild(newNode, node)</span><br><span class="line">        break</span><br><span class="line">      case REORDER:</span><br><span class="line">        reorderChildren(node, currentPatch.moves)</span><br><span class="line">        break</span><br><span class="line">      case PROPS:</span><br><span class="line">        setProps(node, currentPatch.props)</span><br><span class="line">        break</span><br><span class="line">      case TEXT:</span><br><span class="line">        if (node.textContent) &#123;</span><br><span class="line">          node.textContent = currentPatch.content</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          // fuck ie</span><br><span class="line">          node.nodeValue = currentPatch.content</span><br><span class="line">        &#125;</span><br><span class="line">        break</span><br><span class="line">      default:</span><br><span class="line">        throw new Error(&#x27;Unknown patch type &#x27; + currentPatch.type)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function setProps (node, props) &#123;</span><br><span class="line">  for (var key in props) &#123;</span><br><span class="line">    if (props[key] === void 666) &#123;</span><br><span class="line">      node.removeAttribute(key)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      var value = props[key]</span><br><span class="line">      _.setAttr(node, key, value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function reorderChildren (node, moves) &#123;</span><br><span class="line">  var staticNodeList = _.toArray(node.childNodes)</span><br><span class="line">  var maps = &#123;&#125;</span><br><span class="line"></span><br><span class="line">  _.each(staticNodeList, function (node) &#123;</span><br><span class="line">    if (node.nodeType === 1) &#123;</span><br><span class="line">      var key = node.getAttribute(&#x27;key&#x27;)</span><br><span class="line">      if (key) &#123;</span><br><span class="line">        maps[key] = node</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  _.each(moves, function (move) &#123;</span><br><span class="line">    var index = move.index</span><br><span class="line">    if (move.type === 0) &#123; // remove item</span><br><span class="line">      if (staticNodeList[index] === node.childNodes[index]) &#123; // maybe have been removed for inserting</span><br><span class="line">        node.removeChild(node.childNodes[index])</span><br><span class="line">      &#125;</span><br><span class="line">      staticNodeList.splice(index, 1)</span><br><span class="line">    &#125; else if (move.type === 1) &#123; // insert item</span><br><span class="line">      var insertNode = maps[move.item.key]</span><br><span class="line">        ? maps[move.item.key].cloneNode(true) // reuse old item</span><br><span class="line">        : (typeof move.item === &#x27;object&#x27;)</span><br><span class="line">            ? move.item.render()</span><br><span class="line">            : document.createTextNode(move.item)</span><br><span class="line">      staticNodeList.splice(index, 0, insertNode)</span><br><span class="line">      node.insertBefore(insertNode, node.childNodes[index] || null)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">patch.REPLACE = REPLACE</span><br><span class="line">patch.REORDER = REORDER</span><br><span class="line">patch.PROPS = PROPS</span><br><span class="line">patch.TEXT = TEXT</span><br><span class="line"></span><br><span class="line">module.exports = patch</span><br></pre></td></tr></table></figure>

<p>// util.js</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var _ = exports</span><br><span class="line"></span><br><span class="line">_.type = function (obj) &#123;</span><br><span class="line">  return Object.prototype.toString.call(obj).replace(/\[object\s|\]/g, &#x27;&#x27;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_.isArray = function isArray (list) &#123;</span><br><span class="line">  return _.type(list) === &#x27;Array&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_.slice = function slice (arrayLike, index) &#123;</span><br><span class="line">  return Array.prototype.slice.call(arrayLike, index)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_.truthy = function truthy (value) &#123;</span><br><span class="line">  return !!value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_.isString = function isString (list) &#123;</span><br><span class="line">  return _.type(list) === &#x27;String&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_.each = function each (array, fn) &#123;</span><br><span class="line">  for (var i = 0, len = array.length; i &lt; len; i++) &#123;</span><br><span class="line">    fn(array[i], i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_.toArray = function toArray (listLike) &#123;</span><br><span class="line">  if (!listLike) &#123;</span><br><span class="line">    return []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var list = []</span><br><span class="line"></span><br><span class="line">  for (var i = 0, len = listLike.length; i &lt; len; i++) &#123;</span><br><span class="line">    list.push(listLike[i])</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return list</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_.setAttr = function setAttr (node, key, value) &#123;</span><br><span class="line">  switch (key) &#123;</span><br><span class="line">    case &#x27;style&#x27;:</span><br><span class="line">      node.style.cssText = value</span><br><span class="line">      break</span><br><span class="line">    case &#x27;value&#x27;:</span><br><span class="line">      var tagName = node.tagName || &#x27;&#x27;</span><br><span class="line">      tagName = tagName.toLowerCase()</span><br><span class="line">      if (</span><br><span class="line">        tagName === &#x27;input&#x27; || tagName === &#x27;textarea&#x27;</span><br><span class="line">      ) &#123;</span><br><span class="line">        node.value = value</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        // if it is not a input or textarea, use `setAttribute` to set</span><br><span class="line">        node.setAttribute(key, value)</span><br><span class="line">      &#125;</span><br><span class="line">      break</span><br><span class="line">    default:</span><br><span class="line">      node.setAttribute(key, value)</span><br><span class="line">      break</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>js 设计模式</title>
    <url>/2021/05/26/frontEnd/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>object</tag>
      </tags>
  </entry>
  <entry>
    <title>即时通讯技术 —— webSocket</title>
    <url>/2021/05/18/network/websocket/</url>
    <content><![CDATA[<p><img src="/2021/05/18/network/websocket/image-20210727203524611.png" alt="image-20210727203524611"></p>
<span id="more"></span>

<h2 id="WS介绍-—-未来的解决方案之一"><a href="#WS介绍-—-未来的解决方案之一" class="headerlink" title="WS介绍 — 未来的解决方案之一"></a>WS介绍 — 未来的解决方案之一</h2><p>如果说Ajax的出现是互联网发展的必然，那么Comet技术的出现则更多透露出一种无奈，仅仅作为一种hack技术，因为没有更好的解决方案。此时，W3C 给出全新的解决方案，在新一代 html 标准 html5 中提供了一种浏览器和服务器间进行全双工通讯的网络技术 Websocket。</p>
<p>Websocket是一个全新的、独立的协议，基于TCP协议，与http协议兼容、却不会融入http协议，仅仅作为html5的一部分。</p>
<p>与http协议不同的请求/响应模式不同，Websocket在建立连接之前有一个Handshake（Opening Handshake）过程，在关闭连接前也有一个Handshake（Closing Handshake）过程，建立连接之后，双方即可双向通信。</p>
<h2 id="什么是-Socket，什么是-WebSocket？"><a href="#什么是-Socket，什么是-WebSocket？" class="headerlink" title="什么是 Socket，什么是 WebSocket？"></a>什么是 Socket，什么是 WebSocket？</h2><p>我们直到，在网络中两个应用程序（进程）需要全双工相互通信（全双工即双方可同时向对方发送消息），需要用到的就是 socket，它能够提供端对端通信。</p>
<p>对于程序员而言，他只需要在某个应用程序的一端（客户端），创建一个 socket 实例，并且提供它所要连接的一端（服务器）的 IP 地址和端口，而另一端（服务器）创建另一个 socket 并绑定本地端口进行监听。然后客户端进行连接服务端，服务端接受连接之后双方建立了一个端对端的TCP连接，在该连接上就可以双向通讯了，而且一旦建立这个连接之后，通信双方就没有客户端服务端之分了，这就是端对端通信了。</p>
<p>而 WebSocket 是 HTML5 规范中的一部分，它借鉴了 socket 这种思想，为web应用程序客户端和服务端之间（注意是客户端服务端）提供了一种全双工通信机制。同时，它又是一种新的应用层协议，websocket协议是为了提供web应用程序和服务端全双工通信而专门制定的一种应用层协议，通常它表示为：<strong>ws://echo.websocket.org/?encoding=text HTTP/1.1</strong>，可以看到除了前面的协议名和http不同之外，它的表示地址就是传统的url地址。</p>
<h2 id="为什么要用-WebSocket-来替代-HTTP"><a href="#为什么要用-WebSocket-来替代-HTTP" class="headerlink" title="为什么要用 WebSocket 来替代 HTTP"></a>为什么要用 WebSocket 来替代 HTTP</h2><p>WebSocket 的目的就是解决传统 Web 网络传输中的双向通信问题，HTTP1.1 默认使用持久连接，在一个 TCP 连接上也可以传输多个 Request/Response 消息对，但是 HTTP 基本模型还是一个 Request 对应一个 Response。</p>
<h2 id="协议基础"><a href="#协议基础" class="headerlink" title="协议基础"></a>协议基础</h2><p>WebSocket 的目的是取代 HTTP 在双向通信场景下的使用，而且它的实现方式是基于 HTTP 的（WS默认端口80和443）。</p>
<p>一般来说 WS 协议有两部分组成：握手和数据传输</p>
<h3 id="握手"><a href="#握手" class="headerlink" title="握手"></a>握手</h3><p>WS 的握手是通过 HTTP 实现的，客户端的握手消息就是一个，普通的，带有 Upgrade 头的，HTTP Request 消息。当客户端连接服务器时候，会向服务端发送一个类似下面的 http 报文</p>
<p><strong>消息示例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /char HTTP/1.1                                        // 1</span><br><span class="line">Host: server.example.com                                  // 2</span><br><span class="line">Upgrade: websocket                                        // 3</span><br><span class="line">Connection: Upgrade                                       // 4</span><br><span class="line">Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==               // 5</span><br><span class="line">Origin: [url=http://example.com]http://example.com[/url]  // 6</span><br><span class="line">Sec-WebSocket-Protocol: chat, superchat                   // 7</span><br><span class="line">Sec-WebSocket-Version: 13                                 // 8</span><br></pre></td></tr></table></figure>

<p>真正在 WS 握手阶段起作用的是以下几个 header</p>
<ul>
<li><p>Upgrade：它是 HTTP1.1 定义的 header 头，表示服务器支持的话，切换到对应的协议，此处是 websocket 协议</p>
</li>
<li><p>Connection：HTTP1.1 规定 Upgrade 只能应用在<strong>直连</strong>中，带有 Upgrade 头的 HTTP1.1 消息必须包含 Connection 头，因为 Connection 头的意义在于，任何接收到此消息的人（往往是代理服务器）都要在转发此消息之前处理掉 Connection 中指定的域（不转发 Upgrade 域）。如果客户端和服务器之间是通过代理连接的，那么在发送这个握手消息之前首先要发送 CONNECT 消息来建立直接连接</p>
</li>
<li><p>Sec-WebSocket-＊：第7行标识了客户端支持的子协议的列表（关于子协议会在下面介绍），第8行标识了客户端支持的WS协议的版本列表，第5行用来发送给服务器使用（服务器会使用此字段组装成另一个 key 值放在握手返回信息里发送客户端）</p>
<p>如果服务端支持 websocket 协议，那么它就会将自己的通信协议切换到 websocket。“Sec-WebSocket-Key”是 WebSocket 客户端发送的一个 base64 编码的密文，要求服务端必须返回一个对应加密的 “Sec-WebSocket-Accept” 应答，否则客户端会抛出 “Error during WebSocket handshake” 错误，并关闭连接。</p>
</li>
<li><p>Origin：作安全使用，防止跨站攻击，浏览器一般会使用这个来标识原始域。</p>
</li>
</ul>
<p>如果服务器接受了这个请求，可能会发送如下这样的返回信息，这是一个标准的 HTTP 的 Response 消息。101表示服务器收到了客户端切换协议的请求，并且同意切换到此协议。👇</p>
<p><strong><a href="https://www.baidu.com/link?url=p_a8ya429Xspc34EGRjkcgLFs8I0PWp10Wfase9Cd_C1xjPcYRDvNG3VBA66o7YL&wd=&eqid=f7d823b30004da99000000055a308e05">RFC2616</a>规定只有切换到的协议「比HTTP1.1更好」的时候才能同意切换：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 101 Switching Protocols //1</span><br><span class="line">Upgrade: websocket. //2</span><br><span class="line">Connection: Upgrade. //3</span><br><span class="line">Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=  //4</span><br><span class="line">Sec-WebSocket-Protocol: chat. //5</span><br></pre></td></tr></table></figure>

<p>“Sec-WebSocket-Accept”的值是服务端采用与客户端一致的密钥计算出来后返回客户端的,“HTTP/1.1 101 Switching Protocols”表示服务端接受 WebSocket 协议的客户端连接。以上过程都是利用 http 通信完成的，称之为 **websocket 协议握手(websocket Protocol handshake)**，进过这握手之后，客户端和服务端就建立了websocket连接，以后的通信走的都是websocket协议了。 </p>
<p>websocket提供两种数据传输：<strong>文本数据和二进制数据</strong>。</p>
<p>websocket能够提供低延迟，高性能的客户端与服务端的双向数据通信。</p>
<h3 id="协议-URI"><a href="#协议-URI" class="headerlink" title="协议 URI"></a>协议 URI</h3><p><strong>ws协议默认使用80端口，wss协议默认使用443端口：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ws-URI = &quot;ws:&quot; &quot;//&quot; host [ &quot;:&quot; port ] path [ &quot;?&quot; query ]</span><br><span class="line">wss-URI = &quot;wss:&quot; &quot;//&quot; host [ &quot;:&quot; port ] path [ &quot;?&quot; query ]</span><br><span class="line"> </span><br><span class="line">host = &lt;host, defined in [RFC3986], Section 3.2.2&gt;</span><br><span class="line">port = &lt;port, defined in [RFC3986], Section 3.2.3&gt;</span><br><span class="line">path = &lt;path-abempty, defined in [RFC3986], Section 3.3&gt;</span><br><span class="line">query = &lt;query, defined in [RFC3986], Section 3.4&gt;</span><br></pre></td></tr></table></figure>

<p><strong>注：</strong>wss协议是WebSocket使用SSL/TLS加密后的协议，类似天HTTP和HTTPS的关系。</p>
<h3 id="客户端发送握手之前要做的事情"><a href="#客户端发送握手之前要做的事情" class="headerlink" title="客户端发送握手之前要做的事情"></a>客户端发送握手之前要做的事情</h3><p>在握手前，客户端要先建立连接，一个客户端对于一个相同的目标地址（通常是域名或者IP地址，不是资源地址）同一时刻只能有一个处于 CONNECTING （正在建立连接）状态</p>
<p><strong>从建立连接到发送握手消息这个过程大致是这样的：</strong></p>
<ul>
<li><p>客户端检查输入的 URI 是否合法</p>
</li>
<li><p>客户端判断，如果当前已有指向此目标地址（IP地址）的连接（A）仍处于 CONNECTING 状态，需要等待这个（A）建立成功，或者建立失败之后才能继续建立新的连接：</p>
<p> - PS：如果当前连接是处于代理的网络环境中，无法判断IP地址是否相同，则认为每一个Host地址为一个单独的目标地址，同时客户端应当限制同时处于CONNECTING状态的连接数；<br> - PPS：这样可以防止一部分的DDOS攻击；<br> - PPPS：客户端并不限制同时处于「已成功」状态的连接数，但是如果一个客户端「持有大量已成功状态的连接的」，服务器或许会拒绝此客户端请求的新连接。</p>
</li>
<li><p>如果客户端处于一个代理环境中，它首先要请求它的代理来建立一个到达目标地址的TCP连接：</p>
<p>例如，如果客户端处于代理环境中，它想要连接某目标地址的80端口，它可能要收现发送以下消息：</p>
<pre><code>CONNECT example.com:80 HTTP/1.1
Host: example.com
</code></pre>
<p>如果客户端没有处于代理环境中，它就要首先建立一个到达目标地址的直接的TCP连接。</p>
</li>
</ul>
<p>如果上一步中的TCP连接建立失败，则此WebSocket连接失败。如果协议是wss，则在上一步建立的TCP连接之上，使用TSL发送握手信息。如果失败，则此WebSocket连接失败；如果成功，则以后的所有数据都要通过此TSL通道进行发送。</p>
<h3 id="客户端握手消息的需求"><a href="#客户端握手消息的需求" class="headerlink" title="客户端握手消息的需求"></a>客户端握手消息的需求</h3><ul>
<li>握手必须是 RFC2616 中定义的 Request 消息</li>
<li>此 Request 消息的方法必须是 GET，HTTP 版本必须大于 1.1 ：<br> - 以下是某 WS 的 Uri 对应的 Request 消息：<br> - ws://example.com/chat<br> - GET /chat HTTP/1.1</li>
<li>此 Request 消息中 Request-URI 部分（RFC2616中的概念）所定义的资型必须和 WS 协议的 Uri 中定义的资源相同。</li>
<li>此 Request 消息中必须含有 Host 头域，其内容必须和 WS 的 Uri 中定义的相同。</li>
<li>此 Request 消息必须包含 Upgrade 头域，其内容必须包含 websocket 关键字。</li>
<li>此 Request 消息必须包含 Connection 头域，其内容必须包含 Upgrade 指令。</li>
<li>此 Request 消息必须包含 Sec-WebSocket-Key 头域，其内容是一个 Base64 编码的 16 位随机字符。</li>
<li>如果客户端是浏览器，此 Request 消息必须包含 Origin 头域，其内容是参考 RFC6454。</li>
<li>此 Request 消息必须包含 Sec-WebSocket-Version 头域，在此协议中定义的版本号是 13。</li>
<li>此 Request 消息可能包含 Sec-WebSocket-Protocol 头域，其意义如上文中所述。</li>
<li>此 Request 消息可能包含 Sec-WebSocket-Extensions 头域，客户端和服务器可以使用此 header 来进行一些功能的扩展。</li>
<li>此 Request 消息可能包含任何合法的头域。如 RFC2616 中定义的那些。</li>
</ul>
<h3 id="客户端收到-Response-握手消息后要做的事情"><a href="#客户端收到-Response-握手消息后要做的事情" class="headerlink" title="客户端收到 Response 握手消息后要做的事情"></a>客户端收到 Response 握手消息后要做的事情</h3><p><strong>接收到Response握手消息之后：</strong></p>
<ul>
<li>如果返回的返回码不是101，则按照RFC2616进行处理。如果是101，进行下一步，开始解析header域，所有header域的值不区分大小写；</li>
<li>判断是否含有Upgrade头，且内容包含websocket；</li>
<li>判断是否含有Connection头，且内容包含Upgrade；</li>
<li>判断是否含有Sec-WebSocket-Accept头；</li>
<li>如果含有Sec-WebSocket-Extensions头，要判断是否之前的Request握手带有此内容，如果没有，则连接失败；</li>
<li>如果含有Sec-WebSocket-Protocol头，要判断是否之前的Request握手带有此协议，如果没有，则连接失败。</li>
</ul>
<h3 id="机制"><a href="#机制" class="headerlink" title="机制"></a>机制</h3><p>WebSocket 是 HTML5 一种新的协议。它实现了浏览器与服务器全双工通信，能更好的节省服务器资源和带宽并达到实时通讯，它建立在 TCP 之上，同 HTTP 一样通过 TCP 来传输数据，但是它和 HTTP 最大不同是：</p>
<ul>
<li>WebSocket 是一种双向通信协议，在建立连接后，WebSocket 服务器和 Browser/Client Agent 都能主动的向对方发送或接收数据，就像 Socket 一样；</li>
<li>WebSocket 需要类似 TCP 的客户端和服务器端通过握手连接，连接成功后才能相互通信。</li>
</ul>
<p><strong>非 WebSocket 模式传统 HTTP 客户端与服务器的交互</strong></p>
<p><img src="/2021/05/18/network/websocket/106229185-fd6da500-6227-11eb-8b1d-8b0ef067758a.png" alt="img"></p>
<p><strong>使用 WebSocket 模式客户端与服务器的交互</strong></p>
<p><img src="/2021/05/18/network/websocket/106229275-3574e800-6228-11eb-816f-6d37c0e44221.png" alt="img"></p>
<h2 id="服务端概念"><a href="#服务端概念" class="headerlink" title="服务端概念"></a>服务端概念</h2><p>服务端指的是所有参与处理WebSocket消息的基础设施，比如如果某服务器使用Nginx（A）来处理WebSocket，然后把处理后的消息传给响应的服务器（B），那么A和B都是这里要讨论的服务端的范畴。</p>
<h3 id="接受了客户端的连接请求，服务端要做的一些事情"><a href="#接受了客户端的连接请求，服务端要做的一些事情" class="headerlink" title="接受了客户端的连接请求，服务端要做的一些事情"></a>接受了客户端的连接请求，服务端要做的一些事情</h3><p>如果请求是HTTPS，则首先要使用TLS进行握手，如果失败，则关闭连接，如果成功，则之后的数据都通过此通道进行发送。</p>
<p>之后服务端可以进行一些客户端验证步骤（包括对客户端header域的验证），如果需要，则按照RFC2616来进行错误码的返回。</p>
<p>如果一切都成功，则返回成功的Response握手消息。</p>
<h3 id="服务端发送的成功的-Response-握手"><a href="#服务端发送的成功的-Response-握手" class="headerlink" title="服务端发送的成功的 Response 握手"></a>服务端发送的成功的 Response 握手</h3><p><strong>此握手消息是一个标准的HTTP Response消息，同时它包含了以下几个部分：</strong></p>
<ul>
<li>状态行</li>
<li>Upgrade头域，内容为 websocket</li>
<li>Connection头域，内容为 Upgrade</li>
<li>Sec-WebSocket-Accept头域，其内容的生成步骤：<br> - a. 首先将Sec-WebSocket-Key的内容加上字符串258EAFA5-E914-47DA-95CA-C5AB0DC85B11（一个UUID）<br> - b. 将#1中生成的字符串进行SHA1编码<br> - c. 将#2中生成的字符串进行Base64编码</li>
<li>Sec-WebSocket-Protocol头域（可选）</li>
<li>Sec-WebSocket-Extensions头域（可选）</li>
</ul>
<p>一旦这个握手发出去，服务端就认为此WebSocket连接已经建立成功，处于OPEN状态。它就可以开始发送数据了。</p>
<h2 id="与-HTTP-比较"><a href="#与-HTTP-比较" class="headerlink" title="与 HTTP 比较"></a>与 HTTP 比较</h2><p><strong>相同点</strong></p>
<ul>
<li>都是基于TCP的应用层协议；</li>
<li>都使用Request/Response模型进行连接的建立；</li>
<li>在连接的建立过程中对错误的处理方式相同，在这个阶段WS可能返回和HTTP相同的返回码；</li>
<li>都可以在网络中传输数据。</li>
</ul>
<p><strong>不同点</strong></p>
<ul>
<li>WS使用HTTP来建立连接，但是定义了一系列新的header域，这些域在HTTP中并不会使用；</li>
<li>WS的连接不能通过中间人来转发，它必须是一个直接连接；</li>
<li>WS连接建立之后，通信双方都可以在任何时刻向另一方发送数据；</li>
<li>WS连接建立之后，数据的传输使用帧来传递，不再需要Request消息；</li>
<li>WS的数据帧有序。</li>
</ul>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>network</tag>
        <tag>websocket</tag>
      </tags>
  </entry>
  <entry>
    <title>空中碰撞</title>
    <url>/2021/05/02/network/%E7%A9%BA%E4%B8%AD%E7%A2%B0%E6%92%9E/</url>
    <content><![CDATA[<blockquote>
<p>空中碰撞也叫编辑冲突，指很多人在同一时间编辑同一页上内容, 当我们点击保存的时候, 如果这时候其他人和你一样, 编辑了同一份源文件, 但是比你提前保存了, 此时你编辑的文件相较于服务器却是旧的。 因此, 你在点击保存的时候, 修改的内容就会与最新的内容发生冲突。</p>
</blockquote>
<p>空中碰撞讲的是一类场景，这里谈谈解决思路。</p>
<p>举两个空中碰撞场景——多人编辑和文件上传</p>
<span id="more"></span>


<h3 id="多人编辑下的空中碰撞解决方法"><a href="#多人编辑下的空中碰撞解决方法" class="headerlink" title="多人编辑下的空中碰撞解决方法"></a>多人编辑下的空中碰撞解决方法</h3><p>正如开头的故事所描述的，解决的关键点，在于如何正确识别客户端和服务器的资源是否相同，我们要怎么识别呢？</p>
<p>编辑冲突有两种情况</p>
<ul>
<li><p>文件不存在，创建</p>
<ul>
<li><p>文件不存在，一切都顺顺利利</p>
<p>我们在处理这种有可能会产生多人编辑情况下，点击 submit 按钮后，在 PUT 方法前，要先发 HEAD 方法对文件的存在性进行校验，<strong>HEAD 方法只返回 header 头信息</strong>，</p>
<p>若 response 返回状态码为 404，说明文件不存在，可以提交。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 404 Not Found.</span><br></pre></td></tr></table></figure>

<p>我们再执行 PUT 方法</p>
<p>注意，要在 request 的头部要带上这个，<code>If-None-Match: *</code>可以检测文件是否存在，如果存在，返回状态码 412(Precondition Failed)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">If-None-Match: *</span><br></pre></td></tr></table></figure>

<p>反之返回状态码 201 Created.</p>
</li>
<li><p>我们在网页上新建一篇文章，花了一个小时完成，提交后准备下班了，想着新建嘛，列表上也没看到类似标题，肯定没问题啦，没想到页面上突然弹出，该名字已经有了，纳尼！原来前两分钟，有个哥们不按常规出牌，写了标题就提交了，传说中的占着茅坑不拉屎。</p>
<p>同理，我们在 PUT 方法前，也要发 HEAD 方法对文件进行校验，若返回状态码 200，说明文件存在，不能提交，具体怎么操作要交给用户去选择</p>
</li>
</ul>
</li>
<li><p>文件存在，编辑</p>
<ul>
<li>我们在网页上对文章进行编辑，改了点内容后，点提交，此时页面弹出，你的文章不是最新的，请刷新后重新编辑，纳尼！原来前三分钟，那个哥们又过来跟你作对，你们打开的是同一篇文章，他比你先提交了。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title>React 逻辑复用</title>
    <url>/2021/04/28/frontEnd/react%E9%80%BB%E8%BE%91%E5%A4%8D%E7%94%A8/</url>
    <content><![CDATA[<p><img src="/2021/04/28/frontEnd/react%E9%80%BB%E8%BE%91%E5%A4%8D%E7%94%A8/image-20210727202635729.png" alt="image-20210727202635729"></p>
<p>React 中逻辑状态复用（共享一些维护 state 的逻辑）的方式有个 HOC，Hooks，render props<br>那么什么是逻辑状态复用呢？封装一个公共函数不也能够实现逻辑状态复用么？<br>没错，问题就出在<strong>共享一些维护 state 的逻辑</strong>，普通的逻辑的和维护 state 的逻辑的区别就是，维护一个 state 的逻辑，当 <strong>state 发生变化时，用到这个 state 的组件是要重新渲染的</strong>，显然用普通的函数做不了这个事情。</p>
<span id="more"></span>

<p>维护 state 逻辑的方式有两种</p>
<ul>
<li>一个状态组件维护 state 的逻辑</li>
<li>一个非组件维护 state 的逻辑</li>
</ul>
<p>其实一个状态组件本身就是在维护一个 state，当用户操作它所渲染的 UI 的时候，state 发生响应的变化。组件的逻辑负责维护 state 的变化。</p>
<p>那么非组件指什么呢？<br>我理解是没有渲染出 UI 的，只是一个状态，时不时获取最新状态罢了</p>
<ul>
<li>比如说我维护一个user的登录状态，这个登录状态需要发送请求给后台去拿。那么这个登录状态就会有3个值｛fetching，online，offline｝，而且可能会从fetching到online，或者从fetching到offline，就是会变化的。</li>
<li>比如说我需要记录用户鼠标的位置（x，y坐标），这个是随用户移动鼠标而变化的。</li>
<li>比如说我做一个定时器，每隔一段时间切换一下我维护的一个state。</li>
</ul>
<p>之所以分为这两类，是因为我们不能用 hooks 来共享状态组件。这是因为我们用hooks的时候是需要用它的返回值的，这个返回值通常是这个 hooks 所维护的 state 或者 state 的计算值，那么这个 hooks 就不可能返回一个 dom 元素了，也就是 hooks 不能包含组件。</p>
<p>这样听起来好像又回到了上面那个问题，既然 hooks 返回的不是组件是个值，那我们用普通函数也可以实现呀，还是那句话，<strong>普通函数状态的改变无法触发页面的更新</strong><br>下面举个栗子说明 hooks，HOC，Render props 在共享状态上的不同<br>A，B，C 需要共享状态 S</p>
<h3 id="Hooks"><a href="#Hooks" class="headerlink" title="Hooks"></a>Hooks</h3><p>hooks 是通过<strong>自定义 hooks</strong> 把 S 封装成 useS，在 A，B，C 中使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const useS = () =&gt; &#123;</span><br><span class="line">    const [state, setState] = useState(&#x27;someValue&#x27;)</span><br><span class="line">    useEffect(() =&gt; &#123;</span><br><span class="line">        ...some code...</span><br><span class="line">        setState(&#x27;anotherValue&#x27;)</span><br><span class="line">    &#125;)</span><br><span class="line">    return state;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const A = () =&gt; &#123;</span><br><span class="line">    const s = useS();</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;div&gt;&#123;s&#125;&lt;/div&gt;</span><br><span class="line">            &lt;div&gt;A&lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<h3 id="Render-props"><a href="#Render-props" class="headerlink" title="Render props"></a>Render props</h3><p>什么是 render props 呢？<br>通俗来讲</p>
<ul>
<li>首先它本质上是一个prop，是用来父子组件之间传递数据用的</li>
<li>其次这个prop传递的值是一个函数</li>
<li>最后它取名render props，是因为它通常是用来render(渲染)某个元素或组件<br>这就是 render props</li>
</ul>
<p>下面实现一个 render props</p>
<p>这个子组件传递了一个叫 <code>render</code> 的prop，这个prop的值是一个函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;DataProvider render=&#123;data =&gt; (</span><br><span class="line">  &lt;h1&gt;Hello &#123;data.target&#125;&lt;/h1&gt;</span><br><span class="line">)&#125;/&gt;</span><br></pre></td></tr></table></figure>
<p>再实现 DataProvider</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class DataProvider extends React.Component &#123;</span><br><span class="line">    state = &#123;</span><br><span class="line">        data: &#123;</span><br><span class="line">            target: &#x27;World&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return this.props.render(this.state)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以最终渲染结果是 <code>&lt;h1&gt;Hello World&lt;/h1&gt;</code> </p>
<p>我们有必要那么大费周章的写组件再封装吗？直接把<code>h1</code>元素写在<code>DataProvider</code>组件里不也可以吗？答案是为了复用性</p>
<p>假如下次我们希望<code>DataProvider</code>组件渲染的结果就是<code>&lt;span&gt;Hello World&lt;/span&gt;</code>呢？难道又去修改<code>DataProvider</code>组件吗？有了render props，我们就可以动态地决定<code>DataProvider</code>组件内部要渲染的元素，同时这个元素还可以使用到<code>DataProvider</code>组件内部的数据。</p>
<p><strong>言归正传，刚刚补习了下 render props 的概念</strong>，在这里</p>
<p>Render props 是把 S 封装成一个 component，同时这个 component 留了一个 props 用来接收需要渲染的组件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const S = (&#123;render&#125;) =&gt; &#123;</span><br><span class="line">	onst [state, setState] = useState(&#x27;someValue&#x27;)</span><br><span class="line">    useEffect(() =&gt; &#123;</span><br><span class="line">        ...some code...</span><br><span class="line">        setState(&#x27;anotherValue&#x27;)</span><br><span class="line">    &#125;)</span><br><span class="line">    return render(state)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是个组件，里面维护自己的逻辑状态，此时返回一个 render</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const A = (&#123;s&#125;) =&gt; &#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;div&gt;&#123;s&#125;&lt;/div&gt;</span><br><span class="line">            &lt;div&gt;A&lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line">const App = () =&gt; &#123;</span><br><span class="line">    return &lt;S render = &#123;(s) =&gt; &lt;A s=&#123;s&#125; /&gt;&#125; /&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 render props 相对于hooks有明显的区别，它在被调用的时候需要知道两个 component。Render props 的两种写法的区别就是第一种是调用的时候 render 设置为一个函数，返回值为 component 实例。第二种是 render 设置为 component 本身。</p>
<h3 id="HOC"><a href="#HOC" class="headerlink" title="HOC"></a>HOC</h3><p>HOC 就是把 S 封装成一个函数 withS，这个函数返回一个新的 component。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const withS =(WrappedComponent) =&gt; &#123;</span><br><span class="line">    return () =&gt; &#123;</span><br><span class="line">        const [state, setState] = useState(&#x27;someValue&#x27;)</span><br><span class="line">        useEffect(() =&gt; &#123;</span><br><span class="line">            ...some code...</span><br><span class="line">            setState(&#x27;anotherValue&#x27;)</span><br><span class="line">        &#125;)</span><br><span class="line">        return &lt;WrappedComponent s=&#123;state&#125; /&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">const A = (&#123;s&#125;) =&gt; &#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;div&gt;&#123;s&#125;&lt;/div&gt;</span><br><span class="line">            &lt;div&gt;A&lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line">const AWithS = withS(A);</span><br><span class="line">const App = () =&gt; &#123; return &lt;AWithS /&gt;; &#125;</span><br></pre></td></tr></table></figure>

<p> 对比一下 HOC 和 render props，你会发现其实 HOC 返回的 component 使用的技术和 render props 很相似，只不过 render props 的例子中需要 render 的component 来自 props，而 HOC 中需要 render 的 component 来自 HOC 的参数。</p>
<p>HOC不光是有共享维护state的逻辑的能力，还可以做一切封装能做的事情，比如说偷偷改下上层component传过来的props的值。</p>
<h3 id="Hooks-能替代-HOC，render-props么？"><a href="#Hooks-能替代-HOC，render-props么？" class="headerlink" title="Hooks 能替代 HOC，render props么？"></a>Hooks 能替代 HOC，render props么？</h3><p>hooks是无法实现共享状态组件逻辑的，当然就无法在这方面代替HOC和render props。而共享非组件逻辑的功能，基本都可以用hooks来替代，而且最好用hooks来实现，因为我们看到了，hooks的逻辑最直接，最容易理解。当然第一原则仍然是根据业务实事求是，就是概念上该是什么就是什么，如果概念上就是HOC，那么就用HOC。实事求是是为了代码的更好维护。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>页面上隐藏元素的方法有那些</title>
    <url>/2021/04/13/frontEnd/%E9%A1%B5%E9%9D%A2%E4%B8%8A%E9%9A%90%E8%97%8F%E5%85%83%E7%B4%A0%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E9%82%A3%E4%BA%9B/</url>
    <content><![CDATA[<p><img src="/2021/04/13/frontEnd/%E9%A1%B5%E9%9D%A2%E4%B8%8A%E9%9A%90%E8%97%8F%E5%85%83%E7%B4%A0%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E9%82%A3%E4%BA%9B/image-20210727220347106.png" alt="image-20210727220347106"></p>
<span id="more"></span>

<p>关于隐藏元素，我们从两个维度去衡量，能隐藏是前提，隐藏后，是否占据空间，隐藏后（部分）能否触发点击事件？</p>
<ul>
<li><p>overflow: hidden</p>
<p>受 width 和 height 影响，用来隐藏元素溢出来部分，隐藏后不占据空间，隐藏部分无法触发点击事件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.hide &#123;</span><br><span class="line">	overflow: hidden; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>opacity: 0</p>
<p>该属性是用来设置元素的透明度的，虽然元素透明度为 0 了，可它依旧在那里，点击该元素是可以触发事件的。filter 同理，只不过它兼容性不好。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.hide &#123;</span><br><span class="line">	opacity: 0;</span><br><span class="line">&#125;</span><br><span class="line">.hide1 &#123;</span><br><span class="line">    filter:opacity(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>visibility: hidden</p>
<p>该属性设置后，元素存在，占据空间，点击该元素无法触发事件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.hide &#123;</span><br><span class="line">	visibility: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>display: none</p>
<p>该属性是彻底移除元素，不占空间，也无法触发元素上的事件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.hide &#123;</span><br><span class="line">	display: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>position</p>
<p>通过相对和绝对定位的方式隐藏元素的思路就是将他们移出可视范围，我们知道 absolute 是可以将元素脱离文档流的，因此值为 absolute 时候，不占据空间，由于元素也被移不见了，因此也无法点击，relative 却有所不同，它依旧占着位置，也是无法点击</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.hide &#123;</span><br><span class="line">    position：absolute;</span><br><span class="line">    left:-99999px;</span><br><span class="line">    top:-90999px;/* 不占据空间，无法点击 */</span><br><span class="line">&#125;</span><br><span class="line">.hide1 &#123;</span><br><span class="line">    position：relative;</span><br><span class="line">    left:-99999px;</span><br><span class="line">    top:-99999px;/* 占据空间，无法点击 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>z-index: -1000</p>
<p>通过绝对定位的方式，在层级维度上将其隐藏，不占空间，且无法点击。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.hide &#123;</span><br><span class="line">	position: absolute;</span><br><span class="line">	z-index: -1000;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>transform: scaleY(0)</p>
<p>通过修改元素大小（缩放）的方式隐藏元素，占据空间，无法点击。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.hide &#123;</span><br><span class="line">	transform: scale(0, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>clip(clip-path): rect()/inset()/polygon()</p>
<p>通过剪裁方式去实现，占据空间，无法点击。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.hide &#123;</span><br><span class="line">  clip-path: polygon(0px 0px,0px 0px,0px 0px,0px 0px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>小结一下，我们一共有 8 种方法去隐藏一个元素，唯一在隐藏后还能触发事件的只有一种（opacity），不占空间有四种（z-index、position：absolute、display，overflow），占据空间的有 5 种（clip、transform、position: relative、visibility、opacity）</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>你逗我吧，这叫协商缓存？</title>
    <url>/2021/03/03/network/%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%88%91%E8%AF%B4%E5%AE%83%E7%94%A8%E7%9A%84%E6%98%AF%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<p><img src="/2021/03/03/network/%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%88%91%E8%AF%B4%E5%AE%83%E7%94%A8%E7%9A%84%E6%98%AF%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98/image-20210720202108087.png" alt="image-20210720202108087"></p>
<span id="more"></span>

<blockquote>
<p><strong>前端缓存分两个部分，HTTP 缓存和浏览器缓存，这里介绍的是 HTTP 缓存</strong></p>
<p>事情是这样的，我们需要接入语言系统，由于缓存的原因，导致在语言库中加入新语言，前端总拿不到，几个回车键后，发现就是缓存搞得鬼，然后我和同事说，这是强缓存，建议改成协商缓存，他说：</p>
</blockquote>
<p><img src="/2021/03/03/network/%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%88%91%E8%AF%B4%E5%AE%83%E7%94%A8%E7%9A%84%E6%98%AF%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98/wecom-temp-6c95fe83b2c1f29be6f09b0f0b6d517b-6783234.png" alt="wecom-temp-6c95fe83b2c1f29be6f09b0f0b6d517b"></p>
<p><img src="/2021/03/03/network/%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%88%91%E8%AF%B4%E5%AE%83%E7%94%A8%E7%9A%84%E6%98%AF%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98/image-20210720214947972.png" alt="image-20210720214947972"></p>
<p><strong>你逗我吧，这叫协商缓存？</strong></p>
<p>我们知道，为了减轻服务器压力等众多好处，<code>HTTP</code> 提供了缓存机制，可以不使用缓存，也可以使用缓存，由 <code>header</code> 头中的字段去控制。</p>
<p>如果不想使用缓存</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Cache-Control: no-store</span><br></pre></td></tr></table></figure>

<p>表示完全不在客户端使用缓存</p>
<p>如果想使用缓存，针对不同需求又分为两种场景，后端数据变化不大的，如历史订单，商品信息，个人信息等，后端数据变化比较频繁的，如博客中列表，前者可以用强缓存来优化性能，后者可以用协商缓存优化性能。</p>
<p><strong>强缓存</strong>可以理解为，除非到了约定的时间，否则没人能够让我去访问服务器，它比较懒。</p>
<p><strong>协商缓存</strong>可以理解为，比较劳心，时不时会去服务器上看看数据有没有变化，如果变化了，我就更新下，它就像勤快的兔子。</p>
<p>总结一下可以这样说</p>
<blockquote>
<p>根据是否要强制向服务器发送请求，我们把缓存分成强缓存和协商缓存</p>
<p>浏览器第一次请求资源后，再次请求时会有两个步骤，浏览器会根据响应头的 <code>Expires</code> 和 <code>Cache-Control</code> 来判断是否命中强缓存，命中则从缓存中获取，若未命中就会发送请求到服务器，请求会带上 <code>If-Modified-Since</code> 和 <code>If-None-Match</code> ，他们的值分别时第一次请求返回的 <code>Last-Modified</code> 或 <code>Etag</code>，有服务器对比这一字段判断是否命中，若命中服务器，返回 304，并不返回资源，浏览器直接从缓冲获取，否则会返回实践内容，更新 <code>header</code></p>
</blockquote>
<p>说白了缓存就是由 header 头上的几个字段控制的，强缓存由 <code>Cache-Control</code>，<code>Expires</code>，协商缓存由<code>If-Modified-Since</code>，<code>If-None-Match</code>，<code>Last-Modified</code>，<code>If-None-Match</code>，强缓存返回状态是 <code>200</code>，<code>Size</code> 中可以看到是 <code>(disk cache)</code>，而协商缓存返回状态是 <code>304</code></p>
<h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h3><p>强缓存 <code>HTTP/1.1</code> 产物 <code>Cache-Control</code> 用于<strong>响应</strong>首部，除了上述的值外，还有其他的值，它对应的含义也不一样，我们汇总下</p>
<table>
<thead>
<tr>
<th>值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>public</td>
<td>所有内容都将被缓存(客户端和代理服务器都可缓存)</td>
</tr>
<tr>
<td>private</td>
<td>内容只缓存到私有缓存中(仅客户端可以缓存，代理服务器不可缓存)</td>
</tr>
<tr>
<td>max-age = xxx (单位: 秒)</td>
<td>强缓存，缓存的内容将在 xxx 秒后失效，在此之前<strong>直接</strong>使用本地缓存资源，失效后必须向服务器确认资源是否已经改变。（有这个标志一定是强缓存了）</td>
</tr>
<tr>
<td>no-store</td>
<td>不适用缓存</td>
</tr>
<tr>
<td>no-cache</td>
<td>不使用强缓存只使用协商缓存</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Cache-Control: public, max-age=7200, must-revalidate</span><br><span class="line">Date: Tue, 2 Feb 2021 12:43:53 GMT</span><br></pre></td></tr></table></figure>

<p>表示 <code>7200</code> 秒后缓存过期，它是 <code>Date</code> 在字段时间后面加上相应的秒数，由于 <code>Date</code> 字段和 <code>Cache-Control</code> 都是 header 头中的，因此不会出现 <code>Expires</code> 时间不准这个问题。</p>
<p><strong>publish 和 private 有什么区别吗？</strong></p>
<p>publish 表示谁都可以缓存，private 表示只允许私有缓存，我们知道，一条请求不是简单从从客户端到服务器，中间还可能存在代理服务器，代理服务器有代理缓存，它的好处是可以降低服务器带宽，如果此时设置了 <code>private</code>，代理服务器就不允许缓存资源了，防止资源泄漏，打比方，我们的用户名秘码，当然只能存储在本地的私有缓存中，如果存在代理服务器中，大家都可以拿到了。如果是网站的 logo 此时设置 publish ，反而可以节省带宽，大家都可以共享。</p>
<p>这时候有个问题了，你说 max-age 如果设为 0 是不是就不使用缓存了呢？</p>
<a href="#">Post not found: no-cache,max-age=0,no-store一样吗? 点击这里查看这篇文章</a>
<p>！！！ 待讨论</p>
<h3 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h3><p>强缓存 <code>HTTP/1.0</code> 产物，表示缓存有效的绝对时间，用客户端时间和它进行对比，如果超过该时间，缓存失效</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Expires: Wed, 21 Oct 2015 07:28:00 GMT</span><br></pre></td></tr></table></figure>

<p>在浏览器中，它会和 <code>new Date()</code> 进行对比，所以这有个很大的坑，如果用户修改了时间，就可以永远使用缓存数据。</p>
<p><strong>如果 Cache-Control 和 Expires 同时出现，使用 Cache-Control</strong>，你就想着版本高的会覆盖版本低的。</p>
<h3 id="Last-Modified"><a href="#Last-Modified" class="headerlink" title="Last-Modified"></a>Last-Modified</h3><p>协商缓存 <code>HTTP/1.0</code> 产物， <code>Last-Modified</code> 用于<strong>响应</strong>首部，它由服务器设定，是个缓存过期时间，这个值会带给下次请求的 <code>If-Modified-Since</code> 字段，它通常被用作一个验证器来判断接收到的或者存储的资源是否彼此一致。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Last-Modified: Wed, 21 Oct 2015 07:28:00 GMT</span><br></pre></td></tr></table></figure>





<h3 id="If-Modified-Since"><a href="#If-Modified-Since" class="headerlink" title="If-Modified-Since"></a>If-Modified-Since</h3><p>协商缓存 <code>HTTP/1.0</code> 产物，<code>If-Modified-Since</code> 用于<strong>请求</strong>首部，它会将上个响应头中的 <code>Last-Modified</code>  时间带给服务器，由服务器判断是否过期，如果过期了，会返回新数据和状态码 <code>200</code> ，反之就返回状态码 <code>304</code>。</p>
<ul>
<li>用于 <code>Get</code> 或 <code>HEAD</code> 请求中</li>
<li>当与 <code>If-None-Match</code> 一同出现时，它（<code>If-Modified-Since</code>）会被忽略掉，除非服务器不支持 <code>If-None-Match</code>。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">If-Modified-Since: Wed, 21 Oct 2015 07:28:00 GMT</span><br></pre></td></tr></table></figure>



<p><strong>协商缓存的缺点</strong></p>
<p> <code>If-Modified-Since</code> 和 <code>Last-Modified</code> 的主要缺点就是它只能精确到秒的级别，一旦在一秒的时间里出现了多次修改，那么 <code>Last-Modified</code> / <code>If-Modified-Since</code> 是无法体现的。</p>
<h3 id="ETag"><a href="#ETag" class="headerlink" title="ETag"></a>ETag</h3><p>协商缓存 <code>HTTP/1.1</code> 产物，<code>ETag</code> 用在<strong>响应</strong>头，它可以让缓存更高效，并节省带宽，因为如果内容没有改变，Web服务器不需要发送完整的响应。而如果内容发生了变化，使用 <code>ETag</code> 有助于防止资源的同时更新相互覆盖（“空中碰撞”）。</p>
<p><code>ETag</code> 有两种表现形式 <code>W/</code> 和 <code>&lt;etag_value&gt;</code>，前者表示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ETag: &quot;33a64df551425fcc55e4d42a148795d9f25f89d4&quot;</span><br><span class="line">ETag: W/&quot;0815&quot;</span><br></pre></td></tr></table></figure>

<p>值有两种表现形式</p>
<ul>
<li>W/ (大小写敏感)开头，表示使用<strong>弱验证器</strong>。 弱验证器很容易生成，但不利于比较。 强验证器是比较的理想选择，但很难有效地生成。 相同资源的两个弱<code>Etag</code>值可能语义等同，但不是每个字节都相同。</li>
<li>双引号字符串具体值，实体标签唯一地表示所请求的资源。</li>
</ul>
<p><code>ETag</code> 配合不同的头部使用场景不同，譬如说<strong>空中碰撞（状态码: 412）</strong>,<strong>请求范围无法满足（状态码:416）</strong>，这些不在本次讨论范围内，可以移步到<a href>!你又撞机了吧</a></p>
<p><strong>什么是空中碰撞？</strong></p>
<p>空中碰撞也叫编辑冲突，指很多人在同一时间编辑同一页上内容, 当我们点击保存的时候, 如果这时候其他人和你一样, 编辑了同一份源文件, 但是比你提前保存了, 此时你编辑的文件相较于服务器却是旧的。 因此, 你在点击保存的时候, 修改的内容就会与最新的内容发生冲突。</p>
<h3 id="If-None-Match"><a href="#If-None-Match" class="headerlink" title="If-None-Match"></a>If-None-Match</h3><p>协商缓存 <code>HTTP/1.1</code> 产物，<code>If-None-Match</code> 用于<strong>请求</strong>头，它将同个资源上一次响应头中的 <code>ETag</code> 值 <code>copy</code> 下来带到服务器中，由服务器进行校验，若值相同，则返回状态码 <code>304</code> ，若不同，则返回新数据和状态码 <code>200</code> ，并更新 <code>ETag</code> 值用于下次缓存校验。</p>
<ul>
<li>用着 <code>Get</code> 或 <code>HEAD</code> 请求中</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">If-None-Match: &quot;bfc13a64729c4290ef5b2c2730249c88ca92d82d&quot;</span><br><span class="line">If-None-Match: W/&quot;67ab43&quot;, &quot;54ed21&quot;, &quot;7892dd&quot;</span><br><span class="line">If-None-Match: *</span><br></pre></td></tr></table></figure>

<p>值有三种表现形式</p>
<ul>
<li>字符串的是<strong>唯一</strong>表示所请求资源的实体标签，常用于数据精度很高场景</li>
<li>包含一个 W/ 前缀，来提示应该采用<strong>弱比较算法</strong>，即两个文件除了每个比特都相同外，内容一致也可以认为是相同的。例如，如果两个页面仅仅在页脚的生成时间有所不同，就可以认为二者是相同的。</li>
<li>星号是一个特殊值，可以代表任意资源。它只用在进行资源上传时，通常用于 <code>PUT</code>方法，用来检测拥有相同识别ID的资源是否已经上传过了，换另一种说法就是，上传文件时，将这个头设置为 *，判断服务器中是否有这个资源，如果资源存在，返回<strong>状态码 412</strong>，警告，再上传就会将之前的覆盖了，可以用于上传重名提醒之类的。</li>
</ul>
<p><strong>和HTTP1.0协商缓存对比优势</strong></p>
<p><code>ETag</code> / <code>If-None-Match</code> 没有使用时间作为判断标准，而是使用一个特征串。<code>Etag</code> 把 <code>Web</code> 组件的特征串告诉客户端，客户端在下次请求此 <code>Web</code> 组件的时候，会把上次服务端响应的特征串作为 <code>If-None-Match</code> 的值发送给服务端，服务端可以通过这个值来判断是否需要从重新发送，如果不需要，就简单的发送一个 <code>304</code> 状态码，客户端将从缓存里直接读取所需的 <code>Web</code> 组件。</p>
<p><strong>当 If-None-Match 和 If-Modified-Since 一同使用的时候，If-None-Match 优先级更高（假如服务器支持的话）。</strong></p>
<h3 id="使用缓存有什么好处呢？"><a href="#使用缓存有什么好处呢？" class="headerlink" title="使用缓存有什么好处呢？"></a>使用缓存有什么好处呢？</h3><ul>
<li>减少了冗余的数据传输</li>
<li>缓解了网络瓶颈的问题</li>
<li>降低了对原始服务器的要求</li>
<li>降低了距离时延</li>
</ul>
<p>最后，我看了看返回状态，<strong>你逗我吧，这叫协商缓存？就算刷新100次都是强缓存</strong></p>
<p><img src="/2021/03/03/network/%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%88%91%E8%AF%B4%E5%AE%83%E7%94%A8%E7%9A%84%E6%98%AF%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98/image-20210720204441602.png" alt="image-20210720204441602"></p>
<h3 id="Chrome-的网络请求-Size-情况"><a href="#Chrome-的网络请求-Size-情况" class="headerlink" title="Chrome 的网络请求 Size 情况"></a>Chrome 的网络请求 Size 情况</h3><p><img src="/2021/03/03/network/%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%88%91%E8%AF%B4%E5%AE%83%E7%94%A8%E7%9A%84%E6%98%AF%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98/image-20210722172439044.png" alt="image-20210722172439044"></p>
<p>Chrome 的网络请求的Size会出现三种情况<code>from disk cache(磁盘缓存)</code>、<code>from memory cache(内存缓存)</code>、和资源大小数值。</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>200</td>
<td>from memory cache</td>
<td>不请求网络资源，资源在内存中，一般脚本，字体，图片会存在内存中</td>
</tr>
<tr>
<td>200</td>
<td>from disk cache</td>
<td>不请求网络资源，在磁盘当中，一般非脚本会在内存当中，如 css 等</td>
</tr>
<tr>
<td>200</td>
<td>资源大小数值</td>
<td>从服务器下载最新资源</td>
</tr>
<tr>
<td>304</td>
<td>报文大小</td>
<td>请求服务器，发现资源没有更新，使用本地资源（协商缓存）</td>
</tr>
</tbody></table>
<p>至于什么时候出现 <code>from disk cache(磁盘缓存)</code> 什么时候出现 <code>from memory cache(内存缓存)</code> 这就要涉及浏览器内核了，每个浏览器还不太一样，Chrome 会有这种区分，Firefox 却没有，Chrome 用的是 Webkit 内核，<a href="https://developer.chrome.com/docs/extensions/reference/webRequest/">有兴趣同学可以戳这</a>，在 Caching 篇章有说</p>
<blockquote>
<p>Chrome employs two caches—an on-disk cache and a very fast in-memory cache. The lifetime of an in-memory cache is attached to the lifetime of a render process, which roughly corresponds to a tab. </p>
</blockquote>
<p>大致意思就是，Chrome 有两个缓存存放位置，硬盘(disk) 和内存(memory)，他们的区别在于速度，硬盘是低速的，而内存是高速的，内存缓存会随着进程的释放而释放，关闭 Tab 标签就没有了。所以有个现象是：</p>
<blockquote>
<p>访问-&gt; 200 -&gt; 退出浏览器</p>
<p>再进来-&gt; 200(from disk cache) -&gt; 刷新 -&gt; 200(from memory cache)</p>
</blockquote>
<p>当然这也不是固定的，不是说刷新后一定会存在 <code>memory cache</code> 中，还是有些会从 <code>disk cache</code> 中读取，但至少验证了<code>memory cache</code> 存储的短暂性，和读取的即时性（disk cache 读取需要时间，但 memory cache 读取是 0ms），以及使用了缓存，一次进入，一定会从 disk 中读取。</p>
<p>由此，我们知道强缓存的读取顺序是先检测 **memory cache **能否读取到，读取不到再去 <strong>disk cache</strong> 中取。</p>
<p>还有个很有意思的现象，刷新多几次浏览器，会发现同个文件，有时候会在 memory cache 中取，有时候会在 disk cache 中取。</p>
<p>那么什么时候取 memory，什么时候取 disk 呢？关于这点我也没有找到定论😭，根据后面的读取时间，这里大胆做个推测，按照同步和异步思想，<strong>读取文件是并发多线程的，时候如果能立刻，马上，像同步任务一样时，说明从内存中找到了，那就是 from memory，否则就是 from disk</strong></p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title>聊一聊，React 组件的生命周期</title>
    <url>/2021/02/26/frontEnd/React%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<p><img src="/2021/02/26/frontEnd/React%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/image-20210727213029288.png" alt="image-20210727213029288"></p>
<span id="more"></span>

<p>React 组件的生命周期有三个阶段，挂载，更新，卸载，而我们在<a href="https://zh-hans.reactjs.org/docs/react-component.html">官网</a>看到的那些是每个阶段的钩子函数 </p>
<p>要记住</p>
<p>组件的挂载是指<strong>将组件渲染并构造 DOM 元素，然后插入页面的过程</strong></p>
<p>了解了 JSX 原理，我们知道</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ReactDOM.render(</span><br><span class="line"> 	&lt;Test /&gt;,</span><br><span class="line">    document.getElementById(&#x27;root&#x27;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>会编译成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ReactDOM.render(</span><br><span class="line">	React.createElement(Test, null),</span><br><span class="line">	document.getElementById(&#x27;root&#x27;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>我们把 Test 组件传给 React.createElement，又把函数返回的结果传递给 ReactDOM.render，想下里面的原理是什么呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// React.createElement 中实例化 Test</span><br><span class="line">const test = new Test(props, children)</span><br><span class="line">// React.createElement 中调用 test.render 方法渲染组件的内容</span><br><span class="line">const testJsxObject = test.render()</span><br><span class="line"></span><br><span class="line">// ReactDOM 用渲染后的 JavaScript 对象来来构建真正的 DOM 元素</span><br><span class="line">const testDOM = createDOMFromObject(testJsxObject)</span><br><span class="line">// ReactDOM 把 DOM 元素塞到页面上</span><br><span class="line">document.getElementById(&#x27;root&#x27;).appendChild(testDOM)</span><br></pre></td></tr></table></figure>



<p>react 内部对每个组件都有这么一个过程，也就是初始化组件 -&gt; 挂载页面的过程</p>
<p>那么我们在里面注入一些函数，去掌控组件的每个阶段，这就有了所谓的生命周期钩子</p>
<p>挂载</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">constructor()</span><br><span class="line">static getDerivedStateFromProps()</span><br><span class="line">render()</span><br><span class="line">componentDidMount()</span><br></pre></td></tr></table></figure>

<p>更新</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static getDerivedStateFromProps()</span><br><span class="line">shouldComponentUpdate()</span><br><span class="line">render()</span><br><span class="line">getSnapshotBeforeUpdate()</span><br><span class="line">componentDidUpdate()</span><br></pre></td></tr></table></figure>

<p>卸载</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">componentWillUnmount()</span><br></pre></td></tr></table></figure>

<p>错误处理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static getDerivedStateFromError()</span><br><span class="line">componentDidCatch()</span><br></pre></td></tr></table></figure>



<p>一般来说，所有有关组件自身的状态初始化工作都会放在 constructor 里面</p>
<p>像组件启动动作，包括 ajax 数据拉取，定时器启动等，就会放在 componentDidMount 里面</p>
<p>清除数据，定时器清理，会放在 componentWillUnmount 里面</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>Rest 思想浅谈</title>
    <url>/2020/11/28/network/rest%E6%80%9D%E6%83%B3%E6%B5%85%E8%B0%88/</url>
    <content><![CDATA[<p><img src="/2020/11/28/network/rest%E6%80%9D%E6%83%B3%E6%B5%85%E8%B0%88/image-20210727201543680.png" alt="image-20210727201543680"></p>
<span id="more"></span>

<p>现在的大型项目的应用架构基本上都是前后端分离，后端接口基本上用到的是 restful 架构，而 restful 架构最主要的是遵循 rest 思想 —— 统一资源接口。</p>
<p>REST 全称是 Representational State Transfer，也就是“表述性状态转移”，表述的对象就是资源，在 web 的 restful 架构中是通过 uri 来一一对应资源，比如：/api/test/1</p>
<p>URL 代表的是资源，而不是操作，而操作要结合标准的 http 方法（get、post、put等）来实现的。</p>
<p>restful 的 http 方法有这几种：GET、HEAD、POST、PUT、DELETE、OPTIONS、TRACE、PATCH<br>先区分下幂等和安全这两个概念<br>幂等：HTTP 幂等方法，是指无论调用这个 url 多少次，都不会有不同的结果的 HTTP 方法（也就是说不会影响资源）。<br>安全：指是否会给服务器带来副作用，意思就是说我去发送请求会不会改变服务器的状态。</p>
<ul>
<li>GET：幂等，安全的，<strong>用于获取资源</strong>，无论调用多少次，结果都不会改变。</li>
<li>HEAD：幂等，安全的，与 GET 方法类似，但不返回消息 body 内容，仅仅是获得获取资源的部分信息（content-type、content-length）</li>
<li>POST：非幂等，不安全，用于创建子资源</li>
<li>PUT： 幂等，非安全，用于创建、更新资源</li>
<li>DELETE：幂等，非安全，删除资源</li>
<li>OPTIONS：幂等，安全， 用于url验证，验证接口服务是否正常</li>
<li>TEACE：幂等，安全，回显服务器收到的请求，这样客户端可以看到（如果有）哪一些改变或者添加已经被中间服务器实现。</li>
<li>PATCH：幂等，非安全，用于创建、更新资源，于PUT类似，区别在于PATCH代表部分更新</li>
</ul>
<p>所有安全的方法一定幂等，但是幂等方法不一定安全</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>network</tag>
        <tag>rest</tag>
      </tags>
  </entry>
  <entry>
    <title>短轮询与 Comet技术</title>
    <url>/2020/10/23/network/%E7%9F%AD%E8%BD%AE%E8%AF%A2%E4%B8%8EComet%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<p><img src="/2020/10/23/network/%E7%9F%AD%E8%BD%AE%E8%AF%A2%E4%B8%8EComet%E6%8A%80%E6%9C%AF/image-20210727203903503.png" alt="image-20210727203903503"></p>
<h2 id="传统的-Web-通信原理"><a href="#传统的-Web-通信原理" class="headerlink" title="传统的 Web 通信原理"></a>传统的 Web 通信原理</h2><p>浏览器从诞生开始就是走<strong>客户端请求服务器，服务器将结果返回</strong>这个模式，<strong>至今仍未改变</strong>，若要实现 A，B 两个客户端之间的通信，必须要 A 把信息发给服务器，服务器再根据 A 中的接收者发给 B。</p>
<span id="more"></span>


<h2 id="传统通讯方式实现即时通讯要解决的问题"><a href="#传统通讯方式实现即时通讯要解决的问题" class="headerlink" title="传统通讯方式实现即时通讯要解决的问题"></a>传统通讯方式实现即时通讯要解决的问题</h2><p>从通讯原理中我们知道， web 的通讯模式是无法改变的，那么基于该模式下，要实现即时通讯功能，有三个问题需求解决</p>
<ul>
<li><p>全双工通信</p>
<p>浏览器可以主动拉取服务器数据，服务器也可以主动推送数据到服务器。</p>
</li>
<li><p>低延迟</p>
<p>即浏览器A发送给B的信息经过服务器要快速转发给B，同理B的信息也要快速交给A，实际上就是要求任何浏览器能够快速请求服务器的数据，服务器能够快速推送数据到浏览器；</p>
</li>
<li><p>支持跨域</p>
<p>通常客户端浏览器和服务器都是处于网络的不同位置，浏览器本身不允许通过脚本直接访问不同域名下的服务器，即使IP地址相同域名不同也不行，域名相同端口不同也不行，这方面主要是为了安全考虑。</p>
</li>
</ul>
<h2 id="即时通讯解决方案"><a href="#即时通讯解决方案" class="headerlink" title="即时通讯解决方案"></a>即时通讯解决方案</h2><p>说到即时通讯，web 端的解决方案大致有 4 种，传统 Ajax 短轮询，Comet 技术，WebSocket 技术，SSE（Server-sent-Event）。</p>
<h3 id="传统-Ajax-短轮询"><a href="#传统-Ajax-短轮询" class="headerlink" title="传统 Ajax 短轮询"></a>传统 Ajax 短轮询</h3><p>这是最简单的一种解决方案，原理是在客户端通过 Ajax 的方式每隔一段时间发生一个请求到服务器，服务器根据返回的数据更新页面，这就实现了即时通讯。</p>
<p>这个已经被淘汰了，优点是简单，高效，缺点对服务器压力太大了，浪费带宽流量。</p>
<h3 id="Comet-技术"><a href="#Comet-技术" class="headerlink" title="Comet 技术"></a>Comet 技术</h3><p>传统的短轮询已经无法满足了，而且用户体验非常不好，此时，基于 HTTP 长连接的服务器推送技术应运而生，该技术被命名为 Comet。</p>
<p>Ajax 和 Comet 数据传输方式的对比，区别简单明了。典型的 Ajax 通信方式也是 http 协议的经典使用方式，要想取得数据，必须首先发送请求。在低延迟要求比较高的 web 应用中，只能增加服务器请求的频率。Comet 则不同，客户端与服务器端保持一个长连接，只有客户端需要的数据更新时，服务器才主动将数据推送给客户端</p>
<p><strong>Comet 技术应用范畴</strong></p>
<p>在解决方案中可分为两类：</p>
<ul>
<li>一类需要在浏览器安装插件，基于套接字传送信息，像通过 Flash 实现，Java Applet，这类不做讨论</li>
<li>另一类无需安装插件，基于 HTTP 长连接</li>
</ul>
<p><strong>将“服务器推”应用在 Web 程序中，首先考虑的是如何在功能有限的浏览器端接收、处理信息：</strong></p>
<ul>
<li>接收方式：客户端如何接收、处理信息，是否需要使用套接口或是使用远程调用。客户端呈现给用户的是 HTML 页面还是 Java applet 或 Flash 窗口。如果使用套接口和远程调用，怎么和 JavaScript 结合修改 HTML 的显示。</li>
<li>错误处理：客户与服务器端通信的信息格式，采取怎样的出错处理机制。</li>
<li>平台支持：客户端是否需要支持不同类型的浏览器如 IE、Firefox，是否需要同时支持 Windows 和 Linux 平台。</li>
</ul>
<p><strong>Comet 的两种实现方式</strong></p>
<p>我们只探讨 HTTP 长连接的 Web 端实时通信技术解决方案，这里有两种实现方式</p>
<ul>
<li>基于 Ajax 的长轮询（long-polling）方式</li>
<li>基于 Iframe 及 htmlfile 的流（http streaming）方式</li>
</ul>
<h4 id="基于-Ajax-的长轮询（long-polling）方式"><a href="#基于-Ajax-的长轮询（long-polling）方式" class="headerlink" title="基于 Ajax 的长轮询（long-polling）方式"></a>基于 Ajax 的长轮询（long-polling）方式</h4><p>对于传统的 Ajax 短轮询，长轮询的设计思想在于</p>
<ul>
<li>服务器端会阻塞请求直到有数据传递或超时才返回</li>
<li>客户端 JS 响应处理函数会在处理完服务器返回的信息后，再次发出请求，重新连接</li>
<li>当客户端处理接收的数据、重新建立连接时，服务器端可能有新的数据到达；这些信息会被服务器端保存直到客户端重新建立连接，客户端会一次把当前服务器端所有的信息取回。</li>
</ul>
<h4 id="基于-Iframe-及-htmlfile-的流（http-streaming）方式"><a href="#基于-Iframe-及-htmlfile-的流（http-streaming）方式" class="headerlink" title="基于 Iframe 及 htmlfile 的流（http streaming）方式"></a>基于 Iframe 及 htmlfile 的流（http streaming）方式</h4><p>iframe 是很早就存在的一种 HTML 标记， 通过在 HTML 页面里嵌入一个隐蔵帧，然后将这个隐蔵帧的 SRC 属性设为对一个长连接的请求，服务器端就能源源不断地往客户端输入数据。</p>
<p>设计思想</p>
<ul>
<li>服务器端将返回的数据作为客户端 JavaScript 函数的参数传递。</li>
<li>客户端浏览器的 Javascript 引擎在收到服务器返回的 JavaScript 调用时就会去执行代码。</li>
</ul>
<p>原因</p>
<p>上节提到的 AJAX 方案是在 JavaScript 里处理 XMLHttpRequest 从服务器取回的数据，然后 Javascript 可以很方便的去控制 HTML 页面的显示。同样的思路用在 iframe 方案的客户端，iframe 服务器端并不返回直接显示在页面的数据，而是返回对客户端 Javascript 函数的调用，如<code>&lt;script type=&quot;text/javascript&quot;&gt;js_func(“data from server ”)&lt;/script&gt;</code>。</p>
<h4 id="开发应用思考点"><a href="#开发应用思考点" class="headerlink" title="开发应用思考点"></a>开发应用思考点</h4><ul>
<li><p>不要在同一客户端同时使用超过两个的 HTTP 长连接</p>
<p>因为 HTTP 1.1 规范中规定，客户端不应该与服务器端建立超过两个的 HTTP 连接， 新的连接会被阻塞。而 IE 在实现中严格遵守了这种规定。对于 HTTP1.1 的两个长连接限制，如果客户端打开超过两个 IE 窗口去访问同一个长连接的 Web 服务器，第三个 IE 窗口的 HTTP 请求被前两个窗口的长连接阻塞。</p>
<p>所以在开发长连接的应用时， 必须注意在使用了多个 frame 的页面中，不要为每个 frame 的页面都建立一个 HTTP 长连接，这样会阻塞其它的 HTTP 请求，在设计上考虑让多个 frame 的更新共用一个长连接。</p>
</li>
<li><p>服务器端的性能和可扩展性</p>
</li>
<li><p>控制信息与数据信息使用不同的 HTTP 连接</p>
<p>使用长连接时，存在一个很常见的场景：客户端网页需要关闭，而服务器端还处在读取数据的堵塞状态，客户端需要及时通知服务器端关闭数据连接。服务器在收到关闭请求后首先要从读取数据的阻塞状态唤醒，然后释放为这个客户端分配的资源，再关闭连接。</p>
<p>所以在设计上，我们需要使客户端的控制请求和数据请求使用不同的 HTTP 连接，才能使控制请求不会被阻塞。</p>
<p>在实现上，如果是基于 iframe 流方式的长连接，客户端页面需要使用两个 iframe，一个是控制帧，用于往服务器端发送控制请求，控制请求能很快收到响应，不会被堵塞；一个是显示帧，用于往服务器端发送长连接请求。如果是基于 AJAX 的长轮询方式，客户端可以异步地发出一个 XMLHttpRequest 请求，通知服务器端关闭数据连接。</p>
</li>
<li><p>在客户和服务器之间保持“心跳”信息</p>
<p>在浏览器与服务器之间维持一个长连接会为通信带来一些不确定性：因为数据传输是随机的，客户端不知道何时服务器才有数据传送。服务器端需要确保当客户端不再工作时，释放为这个客户端分配的资源，防止内存泄漏。因此需要一种机制使双方知道大家都在正常运行。在实现上：</p>
<ul>
<li>服务器端在阻塞读时会设置一个时限，超时后阻塞读调用会返回，同时发给客户端没有新数据到达的心跳信息。此时如果客户端已经关闭，服务器往通道写数据会出现异常，服务器端就会及时释放为这个客户端分配的资源。</li>
<li>如果客户端使用的是基于 AJAX 的长轮询方式；服务器端返回数据、关闭连接后，经过某个时限没有收到客户端的再次请求，会认为客户端不能正常工作，会释放为这个客户端分配、维护的资源。</li>
<li>当服务器处理信息出现异常情况，需要发送错误信息通知客户端，同时释放资源、关闭连接。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>network</tag>
        <tag>轮询</tag>
        <tag>Comet</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP 协议</title>
    <url>/2020/10/10/network/http%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<p><img src="http%E5%8D%8F%E8%AE%AE/image-20210727203034424.png" alt="image-20210727203034424"></p>
<span id="more"></span>

<h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>HTTP 的地址格式如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http_url = &quot;http:&quot; &quot;//&quot; host [&quot;:&quot; port][abs_path [&quot;?&quot; query]]</span><br></pre></td></tr></table></figure>



<h3 id="HTTP-的消息"><a href="#HTTP-的消息" class="headerlink" title="HTTP 的消息"></a>HTTP 的消息</h3><p>HTTP 消息可能是 request 或者 response，它们的组成几乎相同，都是 4 部分构成<code>起始行</code>、<code>零个或多个header键值对</code>、<code>空行CRLF</code> 、<code>消息主体</code></p>
<p><strong>request 请求头</strong></p>
<p><a href="https://tools.ietf.org/html/rfc2616">RFC2616</a> 中这样定义的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Request = Request-Line</span><br><span class="line">          *(( general-header </span><br><span class="line">            | request-header（跟本次请求相关的一些header）</span><br><span class="line">            | entity-header ) CRLF)（跟本次请求相关的一些header）</span><br><span class="line">          CRLF</span><br><span class="line">          [ message-body ]</span><br></pre></td></tr></table></figure>

<p>请求行定义如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//请求行的定义</span><br><span class="line">Request-Line = Method SP Request-URL SP HTTP-Version CRLF</span><br><span class="line"> </span><br><span class="line">//方法的定义</span><br><span class="line">Method = &quot;OPTIONS&quot; | &quot;GET&quot; | &quot;HEAD&quot;  |&quot;POST&quot; |&quot;PUT&quot; |&quot;DELETE&quot; |&quot;TRACE&quot; |&quot;CONNECT&quot;  | extension-method</span><br><span class="line"> </span><br><span class="line">//资源地址的定义</span><br><span class="line">Request-URI   =&quot;*&quot; | absoluteURI | abs_path | authotity（CONNECT）</span><br></pre></td></tr></table></figure>

<p>其中 Request 消息中使用的 header 可以是 general-header 或者 request-header，在 request-header 中有一个比较特殊的字段 Host，它会与 Request URL 一起作为 Request 消息的接收者判断请求资源的条件。</p>
<p>规则如下</p>
<ul>
<li>如果Request-URI是绝对地址（absoluteURI），这时请求里的主机存在于Request-URI里。任何出现在请求里Host头域值应当被忽略；</li>
<li>假如Request-URI不是绝对地址（absoluteURI），并且请求包括一个Host头域，则主机由该Host头域值决定；</li>
<li>假如由规则１或规则２定义的主机是一个无效的主机，则应当以一个400（错误请求）错误消息返回。</li>
</ul>
<p><strong>response 响应头</strong></p>
<p>几乎和请求消息一模一样，唯一区别就是状态行，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Response = Status-Line              </span><br><span class="line">           *(( general-header        </span><br><span class="line">            | response-header       </span><br><span class="line">            | entity-header ) CRLF)  </span><br><span class="line">              CRLF</span><br><span class="line">            [ message-body ]</span><br></pre></td></tr></table></figure>

<p>状态行定义如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Status-Line = HTTP-Version SP Status-Code SP Reason-Phrase CRLF</span><br></pre></td></tr></table></figure>



<p><strong>header 头部</strong></p>
<ul>
<li><p>通用头（General Header Fields）：可用于 request，也可用于 response，不可作为实体头，只能作为消息的头。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">general-header = Cache-Control            ; Section 14.9</span><br><span class="line">               | Connection               ; Section 14.10</span><br><span class="line">               | Date                     ; Section 14.18</span><br><span class="line">               | Pragma                   ; Section 14.32</span><br><span class="line">               | Trailer                  ; Section 14.40</span><br><span class="line">               | Transfer-Encoding        ; Section 14.41</span><br><span class="line">               | Upgrade                  ; Section 14.42</span><br><span class="line">               | Via                      ; Section 14.45</span><br><span class="line">               | Warning                  ; Section 14.46</span><br></pre></td></tr></table></figure></li>
<li><p>请求头（Request Header Fields）：被请求发起端用来改变请求行为的头。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">request-header = Accept                   ; Section 14.1</span><br><span class="line">               | Accept-Charset           ; Section 14.2</span><br><span class="line">               | Accept-Encoding          ; Section 14.3</span><br><span class="line">               | Accept-Language          ; Section 14.4</span><br><span class="line">               | Authorization            ; Section 14.8</span><br><span class="line">               | Expect                   ; Section 14.20</span><br><span class="line">               | From                     ; Section 14.22</span><br><span class="line">               | Host                     ; Section 14.23</span><br><span class="line">               | If-Match                 ; Section 14.24</span><br><span class="line">               | If-Modified-Since        ; Section 14.25</span><br><span class="line">               | If-None-Match            ; Section 14.26</span><br><span class="line">               | If-Range                 ; Section 14.27</span><br><span class="line">               | If-Unmodified-Since      ; Section 14.28</span><br><span class="line">               | Max-Forwards             ; Section 14.31</span><br><span class="line">               | Proxy-Authorization      ; Section 14.34</span><br><span class="line">               | Range                    ; Section 14.35</span><br><span class="line">               | Referer                  ; Section 14.36</span><br><span class="line">               | TE                       ; Section 14.39</span><br><span class="line">               | User-Agent               ; Section 14.43</span><br></pre></td></tr></table></figure></li>
<li><p>响应头（Response Header Fields）：被服务器用来对资源进行进一步的说明。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">response-header = Accept-Ranges           ; Section 14.5</span><br><span class="line">                | Age                     ; Section 14.6</span><br><span class="line">                | ETag                    ; Section 14.19</span><br><span class="line">                | Location                ; Section 14.30</span><br><span class="line">                | Proxy-Authenticate      ; Section 14.33</span><br><span class="line">                | Retry-After             ; Section 14.37</span><br><span class="line">                | Server                  ; Section 14.38</span><br><span class="line">                | Vary                    ; Section 14.44</span><br><span class="line">                | WWW-Authenticate        ; Section 14.47</span><br></pre></td></tr></table></figure></li>
<li><p>实体头（Entity Header Fields）：如果消息带有消息体，实体头用来作为元信息；如果没有消息体，就是为了描述请求的资源的信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">entity-header  = Allow                    ; Section 14.7</span><br><span class="line">               | Content-Encoding         ; Section 14.11</span><br><span class="line">               | Content-Language         ; Section 14.12</span><br><span class="line">               | Content-Length           ; Section 14.13</span><br><span class="line">               | Content-Location         ; Section 14.14</span><br><span class="line">               | Content-MD5              ; Section 14.15</span><br><span class="line">               | Content-Range            ; Section 14.16</span><br><span class="line">               | Content-Type             ; Section 14.17</span><br><span class="line">               | Expires                  ; Section 14.21</span><br><span class="line">               | Last-Modified            ; Section 14.29</span><br><span class="line">               | extension-header</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="HTTP-的消息体（Message-Body）和实体主体（Entity-Body）"><a href="#HTTP-的消息体（Message-Body）和实体主体（Entity-Body）" class="headerlink" title="HTTP 的消息体（Message Body）和实体主体（Entity Body）"></a>HTTP 的消息体（Message Body）和实体主体（Entity Body）</h3><p>如果有Transfer-Encoding头，那么消息体解码完了就是实体主体，如果没有Transfer-Encoding头，消息体就是实体主体。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">message-body = entity-body</span><br><span class="line">             | &lt;entity-body encoded as per Transfer-Encoding&gt;</span><br></pre></td></tr></table></figure>

<p>在 request 消息中，消息头中含有 Content-Length 或者 Transfer-Encoding，标识会有一个消息体跟在后边。如果请求的方法不应该含有消息体（如OPTION），那么 request 消息一定不能含有消息体，即使客户端发送过去，服务器也不会读取消息体。</p>
<p>在 response 消息中，是否存在消息体由请求方法和返回码来共同决定。像1xx，204，304不会带有消息体。</p>
<h3 id="HTTP-消息体的长度"><a href="#HTTP-消息体的长度" class="headerlink" title="HTTP 消息体的长度"></a>HTTP 消息体的长度</h3><p>消息体长度的确定有一下几个规则，它们顺序执行：</p>
<ul>
<li>所有不应该返回内容的Response消息都不应该带有任何的消息体，消息会在第一个空行就被认为是终止了。</li>
<li>如果消息头含有Transfer-Encoding，且它的值不是identity，那么消息体的长度会使用chunked方式解码来确定，直到连接终止。</li>
<li>如果消息头中有Content-Length，那么它就代表了entity-length和transfer-length。如果同时含有Transfer-Encoding，则entity-length和transfer-length可能不会相等，那么Content-Length会被忽略。</li>
<li>如果消息的媒体类型是multipart/byteranges，并且transfer-length也没有指定，那么传输长度由这个媒体自己定义。通常是收发双发定义好了格式， HTTP1.1客户端请求里如果出现Range头域并且带有多个字节范围（byte-range）指示符，这就意味着客户端能解析multipart/byteranges响应。</li>
<li>如果是 Response 消息，也可以由服务器来断开连接，作为消息体结束。</li>
</ul>
<p>从消息体中得到实体主体，它的类型由两个header来定义，Content-Type 和 Content-Encoding（通常用来做压缩）。如果有实体主体，则必须有 Content-Type ，如果没有，接收方就需要猜测，猜不出来就是用application/octet-stream。</p>
<h2 id="HTTP-连接"><a href="#HTTP-连接" class="headerlink" title="HTTP 连接"></a>HTTP 连接</h2><p>HTTP1.1的连接默认使用持续连接（persistent connection），持续连接指的是，有时是客户端会需要在短时间内向服务端请求大量的相关的资源，如果不是持续连接，那么每个资源都要建立一个新的连接，HTTP底层使用的是TCP，那么每次都要使用三次握手建立TCP连接，将造成极大的资源浪费。</p>
<p>持续连接可以带来很多的好处：</p>
<ul>
<li>使用更少的TCP连接，对通信各方的压力更小；</li>
<li>可以使用管道（pipeline）来传输信息，这样请求方不需要等待结果就可以发送下一条信息，对于单个的TCP的使用更充分；</li>
<li>流量更小；</li>
<li>顺序请求的延时更小；</li>
<li>不需要重新建立TCP连接就可以传送error，关闭连接等信息。</li>
</ul>
<p>HTTP1.1的服务器使用TCP的流量控制来控制HTTP的流量，HTTP1.1的客户端在收到服务器连接中发过来的error信息，就要马上关闭此链接。</p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>network</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>从底层原理学习 react-redux</title>
    <url>/2020/09/26/frontEnd/%E4%BB%8E%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0react-redux/</url>
    <content><![CDATA[<p><img src="/2020/09/26/frontEnd/%E4%BB%8E%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0react-redux/image-20210727212540567.png" alt="image-20210727212540567"></p>
<span id="more"></span>
<h2 id="redux-是什么？"><a href="#redux-是什么？" class="headerlink" title="redux 是什么？"></a>redux 是什么？</h2><ul>
<li>redux 是一个架构（Flux 架构的一种变种）它不关注你到底用什么库，你可以把它应用到 React 和 Vue，甚至跟 jQuery 结合都没有问题。</li>
<li><strong>它解决了复杂的数据通信问题</strong>，它适用于<strong>多交互，多数据源</strong>的场景</li>
<li>也就是说遇到简单数据通讯，像父传子，子穿父等是不需要 redux 的</li>
</ul>
<h2 id="redux-的核心思想是什么？"><a href="#redux-的核心思想是什么？" class="headerlink" title="redux 的核心思想是什么？"></a>redux 的核心思想是什么？</h2><ul>
<li>数据驱动视图，它是一个状态机，视图与状态是一一对应的</li>
<li>所有状态都保存在一个对象（state）中</li>
<li>如何通过 action 来更新 state 这就是核心思想</li>
</ul>
<h2 id="redux-核心概念"><a href="#redux-核心概念" class="headerlink" title="redux 核心概念"></a>redux 核心概念</h2><ul>
<li><p>state 就是一个用对象来描述的数据源，存储着所有的数据，任何代码都不能改变它</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const data = &#123;</span><br><span class="line">	a: 1,</span><br><span class="line">	b: 2,</span><br><span class="line">	c: 3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>action 就是一个行为指示器，也是一个对象，它描述了数据（state）改变的逻辑</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123; type: &#x27;ADD_TODO&#x27;, index: 1&#125;</span><br><span class="line">&#123; type: &#x27;DELETE_TODO&#x27;, text: &#x27;go&#x27;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>reducer 是一个纯函数，用于将 state 和 action 串起来，它接收 state 和 action，并返回新的 state，刚开始可能只有一个 reducer，随着项目的扩张，你可以</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function filter(state = &#x27;SHOW_ALL&#x27;, action) &#123;</span><br><span class="line">	if(action.type === &#x27;SET&#x27;) &#123;</span><br><span class="line">		return action.index</span><br><span class="line">	&#125;</span><br><span class="line">	return state</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>也就是说 action 是描述发生了什么，和使用 reducers 来根据 action 更新 state 的用法。 </p>
<h2 id="三大原则"><a href="#三大原则" class="headerlink" title="三大原则"></a>三大原则</h2><ul>
<li>单一数据源：<strong>整个应用的 state 被储存在一颗 object tree 中，并且这个 object tree 只存在于唯一一个 store 中。</strong></li>
<li>State 是只读的：<strong>唯一改变 state 的方法就是触发 action，action 是一个用于描述已发生事件的普通对象。</strong></li>
<li>使用纯函数修改：<strong>为了描述 action 如何改变 state tree ，你需要编写 reducers。</strong></li>
</ul>
<h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><h3 id="store"><a href="#store" class="headerlink" title="store"></a>store</h3><p>职责</p>
<ul>
<li>维持应用的 state</li>
<li>提供 getState() 方法获取 state</li>
<li>提供 dispatch(action) 方法更新 state</li>
<li>通过 subscribe(listener) 注册监听器</li>
<li>通过 subscribe(listener) 返回的函数注销监听器</li>
</ul>
<p>reduce 提供一个 api 用来创建 store —— createStore()，它接收 2 个参数，第一个参数是 reducer，第二个参数是可选的，用于设置 state 的初始状态，<strong>整个 redux 应用只有一个单一的 store</strong></p>
<p>手动实现一个 createStore()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const createStore = (reducer, state) =&gt; &#123;</span><br><span class="line">	const getState = () =&gt; state || &#123;&#125;</span><br><span class="line">	const listeners = []</span><br><span class="line">	const dispatch = (action) =&gt; &#123;</span><br><span class="line">		state = reducer(state, action)</span><br><span class="line">		listeners.forEach(listener =&gt; listener())</span><br><span class="line">	&#125;</span><br><span class="line">	const subscribe = (listener) =&gt; &#123;</span><br><span class="line">		listeners.push(listener)</span><br><span class="line">		return () =&gt; &#123;</span><br><span class="line">			listeners = listeners.filter(l =&gt; l !== listener)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	dispatch(&#123;&#125;)</span><br><span class="line">	return &#123;</span><br><span class="line">		getState,</span><br><span class="line">		dispatch</span><br><span class="line">		subscribe</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="reducer"><a href="#reducer" class="headerlink" title="reducer"></a>reducer</h3><p><em>了解完 store 后，我们看看里面的 reducer 是什么？</em></p>
<p>reducer 其实是一个函数，它接收两个参数，state 和 action，返回 state</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const newReducer = (state, action) =&gt; &#123;</span><br><span class="line">	switch(action.type) &#123;</span><br><span class="line">		case &#x27;SET_TITLE&#x27;:</span><br><span class="line">			return &#123;</span><br><span class="line">				...state,</span><br><span class="line">				title: action.title</span><br><span class="line">			&#125;</span><br><span class="line">		default: </span><br><span class="line">			return state</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="subscribe"><a href="#subscribe" class="headerlink" title="subscribe"></a>subscribe</h3><p>这个函数是用于订阅数据变化后执行的函数，返回一个函数，用于取消订阅</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const unsubscribe = store.subscribe(() =&gt; console.log(‘数据变化了’))</span><br><span class="line">unsubscribe() // 取消订阅</span><br></pre></td></tr></table></figure>



<h2 id="redux-的使用"><a href="#redux-的使用" class="headerlink" title="redux 的使用"></a>redux 的使用</h2><blockquote>
<p>yarn add redux</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 创建状态变化逻辑 reducer</span><br><span class="line">const reducer = (initState, action) =&gt; &#123;</span><br><span class="line">    switch (action.type) &#123;</span><br><span class="line">        case &#x27;ADD_A&#x27;:</span><br><span class="line">            return &#123;</span><br><span class="line">                ...initState,</span><br><span class="line">                a: action.a</span><br><span class="line">            &#125;</span><br><span class="line">        case &#x27;ADD_B&#x27;:</span><br><span class="line">            return &#123;</span><br><span class="line">                ...initState,</span><br><span class="line">                b: action.b</span><br><span class="line">            &#125;</span><br><span class="line">        default:</span><br><span class="line">            return &#123;</span><br><span class="line">                ...initState</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 创建数据源 state</span><br><span class="line">const state = &#123;</span><br><span class="line">    a: 1,</span><br><span class="line">    b: 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 创建 redux 应用 store</span><br><span class="line">const store = createStore(reducer, state)</span><br><span class="line"></span><br><span class="line">// run</span><br><span class="line">console.log(store.getState()) // &#123; a: 1, b: 2 &#125;</span><br><span class="line">store.dispatch(&#123; type: &#x27;ADD_A&#x27;, a: 5 &#125;) // 修改</span><br><span class="line">console.log(store.getState()) // &#123; a: 5, b: 2 &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="combineReducers-reducers-——-reducer-拆分"><a href="#combineReducers-reducers-——-reducer-拆分" class="headerlink" title="combineReducers(reducers) —— reducer 拆分"></a>combineReducers(reducers) —— reducer 拆分</h2><p>为了方便管理，我们需要对 reducer  函数进行拆分，拆分后的每一块独立负责管理 state 的一部分。</p>
<p>combineReducers 辅助函数的作用是，把一个由多个不同 reducer 函数作为 value 的 object，合并成一个最终的 reducer 函数，然后就可以对这个 reducer 调用 createStore。</p>
<p>合并后的 reducer 可以调用各个子 reducer，并把它们的结果合并成一个 state 对象。state 对象的结构由传入的多个 reducer 的 key 决定。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	reducer1: ...</span><br><span class="line">	reducer2: ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>返回值：</strong>一个调用 reducers 对象里所有 reducer 的 reducer，并且构造一个与 reducers 对象结构相同的 state <strong>对象</strong>。</p>
<p>每个传入 combineReducers 的 reducer 都需满足以下规则</p>
<ul>
<li>所有未匹配到的 action，必须把它接收到的第一个参数也就是那个 state 原封不动返回。</li>
<li>永远不能返回 undefined，否则会抛出异常</li>
<li>如果传入的 state 就是 undefined，一定要返回对应 reducer 的初始 state，根据上一条规则，初始 state 禁止使用 undefined。使用 ES6 的默认参数值语法来设置初始 state 很容易，但你也可以手动检查第一个参数是否为 undefined。</li>
</ul>
<p>用法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// todo.js</span><br><span class="line">export default function todos(state = [], action) &#123;</span><br><span class="line">	switch(action.type) &#123;</span><br><span class="line">		case &#x27;ADD_TODO&#x27;:</span><br><span class="line">			return state.concat([action.text])</span><br><span class="line">		default:</span><br><span class="line">			return state</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// counter.js</span><br><span class="line">export default function counter(state = 0, action) &#123;</span><br><span class="line">	 switch (action.type) &#123;</span><br><span class="line">          case &#x27;INCREMENT&#x27;:</span><br><span class="line">            return state + 1</span><br><span class="line">          case &#x27;DECREMENT&#x27;:</span><br><span class="line">            return state - 1</span><br><span class="line">          default:</span><br><span class="line">            return state</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// index.js</span><br><span class="line">const reducer = combineReducers(&#123;</span><br><span class="line">  todos,</span><br><span class="line">  counter</span><br><span class="line">&#125;)</span><br><span class="line">const store = createStore(reducer)</span><br><span class="line">console.log(store.getState()) // &#123; counter: 0, todos: [] &#125;</span><br></pre></td></tr></table></figure>



<p><strong>combineReducers 实现原理</strong></p>
<p>combineReducers 接收所有的 reducer，合并成最终的 reducers 函数，那我们可以写一个框架</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const rootReducer = combineReducers(&#123;</span><br><span class="line">	reducer1,</span><br><span class="line">	reducer2,</span><br><span class="line">	reducer3,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>


<p>核心代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const combineReducers = (obj) =&gt; &#123;</span><br><span class="line"> 	var finalState = &#123;&#125;;</span><br><span class="line"> 	function reducer(state, action) &#123;</span><br><span class="line"> 		//reducer 具体逻辑</span><br><span class="line"> 	 	for (var p in obj) &#123;</span><br><span class="line">         //根据 key 属性值调用 function(state.属性名，action)</span><br><span class="line">         finalState[p] = obj[p](state[p], action);</span><br><span class="line">        &#125;</span><br><span class="line">        //返回state</span><br><span class="line"> 		return finalState</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	//返回最终的 reducer</span><br><span class="line">	return reducers</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="redux-数据流"><a href="#redux-数据流" class="headerlink" title="redux 数据流"></a>redux 数据流</h2><p><strong>严格的单向数据流</strong>是 Redux 架构的设计核心。</p>
<p>单向数据流优缺点：</p>
<ul>
<li><p>优点：所有状态变化都可以被记录、跟踪，状态变化通过手动调用触发，源头易追溯。</p>
</li>
<li><p>缺点：会有很多类似的样板代码，代码量会相应的上升。</p>
</li>
</ul>
<p>双向数据流优缺点</p>
<ul>
<li>优点：在操作表单时使用<code>v-model</code>方便简单，可以省略繁琐或重复的<code>onChange</code>事件去处理每个表单数据的变化（减少代码量）。</li>
<li>缺点：属于暗箱操作，无法很好的追踪双向绑定的数据的变化。</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/29953244/103887429-fc13f580-511d-11eb-979d-66657c0530dc.png" alt="image"></p>
<p>在 react 中，一个状态可能被多个组件依赖或者影响，在此，没有一套应用状态管理方案，只能够通过状态提升实现，层级少还没问题，层级多，那就会变的非常复杂。</p>
<p>后来，学习了 context，我们知道，可以把共享状态放到父组件的 context 上，这个父组件下所有的组件都可以从 context 中直接获取到状态而不需要一层层地进行传递了。但是直接从 context 里面存放、获取数据增强了组件的耦合性；并且所有组件都可以修改 context 里面的状态就像谁都可以修改共享状态一样，导致程序运行的不可预料。</p>
<h2 id="redux-和-react-redux-有什么区别？"><a href="#redux-和-react-redux-有什么区别？" class="headerlink" title="redux 和 react-redux 有什么区别？"></a>redux 和 react-redux 有什么区别？</h2><p>Redux 和 React-redux 并不是同一个东西。React-redux 就是把 Redux 这种架构模式和 React.js 结合起来的一个库，就是 Redux 架构在 React.js 中的体现。</p>
<h2 id="react-redux-原理"><a href="#react-redux-原理" class="headerlink" title="react-redux 原理"></a>react-redux 原理</h2><p>react-redux 实际上就是 context 和 redux 的组合，通过高阶函数模式封装了 <code>connect 函数</code>和 <code>Provider 容器组件</code>，context 的特点是可以组件透传，redux 的特点是单向数据流，修改数据只能用 dispatch。</p>
<p>说干就干，我们来实现一个 connect</p>
<p>connect 设计思想</p>
<ul>
<li><p>是一个高阶组件</p>
</li>
<li><p>将 store 的 state 和 dispatch 注入到 mapStateToProps 和 mapDispatchToProps 中</p>
</li>
<li><p>返回一个 props 里面有处理过的 state 和 dispach</p>
</li>
<li><p>有个 mapStateToProps 参数告诉 store 需要哪些数据（不可能把 state 的全部取出来吧）<strong>读数据</strong></p>
<p>我们设计一下 mapStateToProps</p>
<ul>
<li>它是一个函数</li>
<li>返回需要在 store 中提取的 state 对象</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const mapStateToProps = (state) =&gt; &#123;</span><br><span class="line">	return &#123;</span><br><span class="line">		a: state.a,</span><br><span class="line">		b: state.b,</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>有个 mapDispatchToProps 参数用于触发 store 的 dispatch，也就是<strong>写数据</strong></p>
<p>我们设计一下 mapDispatchToProps </p>
<ul>
<li>它是个函数</li>
<li>返回一个需要在 store 中调用 dispatch 的对象</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const mapDispatchToProps = (dispatch) =&gt; &#123;</span><br><span class="line">	return &#123;</span><br><span class="line">		a: (value) =&gt; dispatch(&#123; type: &#x27;UPDATE&#x27;, value &#125;)</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; MyContext &#125; from &#x27;./provider&#x27;</span><br><span class="line">export connect = (mapStateToProps, mapDispatchToProps) =&gt; (WrappedComponent) =&gt; &#123;</span><br><span class="line">	class Connect extends Component &#123;</span><br><span class="line">		constructor() &#123;</span><br><span class="line">			super()</span><br><span class="line">			this.state = &#123;</span><br><span class="line">				allProps: &#123;&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		componentWillMount() &#123;</span><br><span class="line">			this._updateProps()</span><br><span class="line">			this.context.store.subscribe(() =&gt; this._updateProps())</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		_updateProps() &#123;</span><br><span class="line">			let statePorps = mapStateToProps</span><br><span class="line">				? mapStateToProps(this.context.store.getState())</span><br><span class="line">        		: &#123;&#125; // 防止 mapStateToProps 没有传入</span><br><span class="line">        	let dispatchProps = mapDispatchToProps</span><br><span class="line">                ? mapDispatchToProps(this.context.store.dispatch, this.props)</span><br><span class="line">                : &#123;&#125; // 防止 mapDispatchToProps 没有传入</span><br><span class="line">            this.setState(&#123;</span><br><span class="line">                allProps: &#123;</span><br><span class="line">                  ...stateProps,</span><br><span class="line">                  ...dispatchProps</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">		&#125;</span><br><span class="line">		render() &#123;</span><br><span class="line">			return &lt;WrappedComponent &#123;...this.state.allProps&#125;/&gt;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	Connect.contextType = MyContext</span><br><span class="line">	return Connect</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>探究完 connect 我们再看看 <code>Provider </code> 是怎么实现的</p>
<h2 id="Provider-原理"><a href="#Provider-原理" class="headerlink" title="Provider 原理"></a>Provider 原理</h2><p>要用 context 就是因为要把 <code>store</code> 存放到里面，好让子组件 <code>connect</code> 的时候能够取到 <code>store</code>。我们可以额外构建一个组件来做这种事情，然后让这个组件成为组件树的根节点，那么它的子组件都可以获取到 context 了。</p>
<p>我们把这个组件叫 <code>Provider</code>，它提供（provide）了 <code>store</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export const MyContext = React.createContext(&#123;&#125;) </span><br><span class="line">export class Provider extends Component &#123;</span><br><span class="line">	render() &#123;</span><br><span class="line">		return (</span><br><span class="line">			&lt;MyContext.Provider value=&#123;this.props.store&#125;&gt;</span><br><span class="line">				&#123;this.props.children&#125;</span><br><span class="line">			&lt;/MyContext.Provider&gt;</span><br><span class="line">		)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>./store.js</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...  // redecers 代码就不写了，一个 action 一个 state 组合 reducers，这里生成 store</span><br><span class="line">export default createStore(reducers)</span><br></pre></td></tr></table></figure>



<p>./index.js</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">import React from &#x27;react&#x27;</span><br><span class="line">import ReactDOM from &#x27;react-dom&#x27;;</span><br><span class="line">import &#123; Provider &#125; from &#x27;react-redux&#x27;</span><br><span class="line">import store from &#x27;store&#x27;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;React.StrictMode&gt;</span><br><span class="line">    &lt;Provider store=&#123;store&#125;&gt; // 使用 Provider 在最顶层注入</span><br><span class="line">      &lt;App /&gt;</span><br><span class="line">    &lt;/Provider&gt;</span><br><span class="line">  &lt;/React.StrictMode&gt;,</span><br><span class="line">  document.getElementById(&#x27;root&#x27;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<p>./children.js</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React from &#x27;react&#x27;</span><br><span class="line">import &#123; connect &#125; from &#x27;react-redux&#x27;</span><br><span class="line">class Child extends React.Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        console.log(this.props.data, &#x27;我拿到 store 里面数据了&#x27;)</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">               Hello world</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">const mapStateToProps = (state) =&gt; &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        data: state</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">export default connect(mapStateToProps)(Chlid)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>redux</tag>
      </tags>
  </entry>
  <entry>
    <title>水平和垂直居中的N种方式</title>
    <url>/2020/08/28/frontEnd/%E6%B0%B4%E5%B9%B3%E5%92%8C%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E7%9A%84N%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p><img src="/2020/08/28/frontEnd/%E6%B0%B4%E5%B9%B3%E5%92%8C%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E7%9A%84N%E7%A7%8D%E6%96%B9%E5%BC%8F/image-20210727220849144.png" alt="image-20210727220849144"></p>
<span id="more"></span>

<p>在 CSS 世界中，元素有三种形式</p>
<ul>
<li>行内元素 display: inline, 代表 span 特点：<ul>
<li>(1)设置宽高无效。</li>
<li>(2)对 margin 仅设置左右方向有效，上下无效；padding 设置上下左右都有效，即会撑大空间。</li>
<li>(3)不会自动进行换行</li>
</ul>
</li>
<li>块级元素 display: block, 代表 div 特点：<ul>
<li>(1)能够识别宽高</li>
<li>(2) margin 和 padding 的上下左右均对其有效</li>
<li>(3)可以自动换行</li>
<li>(4)多个块状元素标签写在一起，默认排列方式为从上至下</li>
</ul>
</li>
<li>行内块级元素 display: inline-block 行内块状元素综合了行内元素和块状元素的特性，但是各有取舍。特点：<ul>
<li>(1)不自动换行</li>
<li>(2)能够识别宽高</li>
<li>(3)默认排列方式为从左到右</li>
</ul>
</li>
</ul>
<h2 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h2><ul>
<li><p>1）若是行内元素，父级又是块级元素，直接在父级设置 <code>test-align: center</code> 可实现水平居中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;level_01&quot;&gt;</span><br><span class="line">  &lt;span&gt;我要居中&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">  .level_01&#123;</span><br><span class="line">    text-align: center;</span><br><span class="line">    border: 1px solid red;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>2）使用 <code>margin: 0 auto</code> 要注意，设定宽度。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;level_02&quot;&gt;</span><br><span class="line">  &lt;span&gt;使用 margin: 0 auto; 记得设置宽度&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">  .level_02&#123;</span><br><span class="line">    border: 1px solid red;</span><br><span class="line">    margin: 0 auto;</span><br><span class="line">    width: fit-content;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>3）子元素 float 情况下，父元素使用 <code>width: fit-content</code> 和 <code>margin: 0 auto</code> 可实现水平居中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;level_03&quot;&gt;</span><br><span class="line">  &lt;div style=&quot;float: left&quot;&gt;</span><br><span class="line">    子元素用 float 情况下的水平居中</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">  .level_03 &#123;</span><br><span class="line">    border: 1px solid red;</span><br><span class="line">    margin: 0 auto;</span><br><span class="line">    width: fit-content;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>4）使用 flex 布局，可以轻松实现水平居中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;level_04&quot;&gt;</span><br><span class="line">  &lt;span&gt;</span><br><span class="line">    flex 布局</span><br><span class="line">  &lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">  .level_04 &#123;</span><br><span class="line">    border: 1px solid red;</span><br><span class="line">    display: flex;</span><br><span class="line">    justify-content: center;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>5）使用 absolute + transform 属性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;level_05&quot;&gt;</span><br><span class="line">  &lt;span&gt;</span><br><span class="line">    absolute + transform 属性</span><br><span class="line">  &lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">  .level_05 &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    left: 50%;</span><br><span class="line">    transform: translateX(-50%);</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>6）需要居中的元素, 通过 margin-left, 和 width 实现, 这个有固定宽度需求</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;level_06&quot;&gt;</span><br><span class="line">  &lt;span&gt;</span><br><span class="line">    需要居中的元素, 通过 margin-left, 和 width 实现, 这个有固定宽度需求</span><br><span class="line">  &lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">  .level_06 &#123;</span><br><span class="line">    width: 600px;</span><br><span class="line">    margin-left: -300px;</span><br><span class="line">    position: absolute;</span><br><span class="line">    left: 50%;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>7）使用绝对定位方式, 以及left:0; right:0; margin:0 auto;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;level_07&quot;&gt;</span><br><span class="line">    &lt;span&gt;</span><br><span class="line">      需要居中的元素, 通过 margin 和 absolute 实现, 这个有固定宽度需求</span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;style&gt;</span><br><span class="line">    .level_07 &#123;</span><br><span class="line">      width: 600px;</span><br><span class="line">      position: absolute;</span><br><span class="line">      left: 0;</span><br><span class="line">      right: 0;</span><br><span class="line">      margin: 0 auto;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/style&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h2><ul>
<li><p>1）单行文本可通过 line-height 实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;vertical_01&quot;&gt;</span><br><span class="line">  单行文本可通过 line-height 实现</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">  .vertical_01 &#123;</span><br><span class="line">    border: 1px solid red;</span><br><span class="line">    height: 100px;</span><br><span class="line">    line-height: 100px;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>2）若元素是行内块级元素, 基本思想是使用 display: inline-block, vertical-align: middle 和一个伪元素让内容块处于容器中央.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;vertical_02&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;son&quot;&gt;</span><br><span class="line">    通过伪元素实现，</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">  .vertical_02::after &#123;</span><br><span class="line">    content: &#x27;&#x27;;</span><br><span class="line">    height: 300px;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .vertical_02::after,</span><br><span class="line">  .son &#123;</span><br><span class="line">    display: inline-block;</span><br><span class="line">    vertical-align: middle;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>3）可用 vertical-align 属性, 而 vertical-align 只有在父层为 td 或者 th 时, 才会生效, 对于其他块级元素, 例如 div、p 等, 默认情况是不支持的. 为了使用 vertical-align , 我们需要设置父元素display:table, 子元素 display:table-cell;vertical-align:middle; <strong>优点：元素高度可以动态改变, 不需再CSS中定义, 如果父元素没有足够空间时, 该元素内容也不会被截断</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;vertical_03&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;son&quot;&gt;</span><br><span class="line">    通过 table vertical-align 属性实现</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">  .vertical_03 &#123;</span><br><span class="line">    display: table;</span><br><span class="line">    height: 300px;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .vertical_03 .son &#123;</span><br><span class="line">    display: table-cell;</span><br><span class="line">    vertical-align: middle</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>4）flex 布局</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;vertical_04&quot;&gt;</span><br><span class="line">  通过 flex 实现垂直居中</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">  .vertical_04 &#123;</span><br><span class="line">    display: flex;</span><br><span class="line">    align-items: center;</span><br><span class="line">    height: 300px;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>5）通过 transform 实现垂直居中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;vertical_05&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;son&quot;&gt;</span><br><span class="line">    通过 transform 实现垂直居中</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">  .vertical_05 &#123;</span><br><span class="line">    position: relative;</span><br><span class="line">    height: 300px;</span><br><span class="line">  &#125;</span><br><span class="line">  .vertical_05 .son &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top:50%;</span><br><span class="line">    transform: translateY(-50%);</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>6）设置父元素相对定位(position:relative)，通过 margin-top 实现垂直居中。<strong>缺点：父元素空间不够时, 子元素可能不可见(当浏览器窗口缩小时,滚动条不出现时).如果子元素设置了overflow:auto, 则高度不够时, 会出现滚动条。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;vertical_06&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;son&quot;&gt;</span><br><span class="line">    通过 margin-top 实现垂直居中</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">  .vertical_06 &#123;</span><br><span class="line">    position: relative;</span><br><span class="line">  &#125;</span><br><span class="line">  .vertical_06 .son &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    height: 300px;</span><br><span class="line">    margin-top: 150px;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>js7种创建对象模式</title>
    <url>/2020/08/26/frontEnd/js7%E7%A7%8D%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><img src="/2020/08/26/frontEnd/js7%E7%A7%8D%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%BC%8F/image-20210727215341846.png" alt="image-20210727215341846"></p>
<span id="more"></span>

<ul>
<li>工厂模式</li>
<li>构造函数模式</li>
<li>原型模式</li>
<li>组合使用构造函数模式和原型模式</li>
<li>动态原型模式</li>
<li>寄生模式</li>
<li>稳妥构造函数模式</li>
</ul>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>工厂模式使用一个函数来封装创建对象、属性赋值、组装对象，这个函数叫做工厂函数。使用的时候只需要将对象的信息作为参数传递给工厂函数，工厂函数就会帮我们“加工”出需要的对象了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function createPerson(name, age) &#123;</span><br><span class="line">    var o = &#123;&#125;;</span><br><span class="line">    o.name = name;</span><br><span class="line">    o.age = age;</span><br><span class="line">    o.sayName = function() &#123;</span><br><span class="line">        alert(this.name);</span><br><span class="line">    &#125;;</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br><span class="line">var person1 = createPerson(&quot;p1&quot;, 21);</span><br><span class="line">var person2 = createPerson(&quot;p2&quot;, 22);</span><br><span class="line">var person3 = createPerson(&quot;p3&quot;, 23);</span><br></pre></td></tr></table></figure>

<p>缺陷：</p>
<ul>
<li>低效率，每次调用工厂函数都重复地定义了相同的函数（上面例子的sayName）。这些函数的作用完全相同，却各自占用了内存空间和cpu资源。</li>
<li>对象识别困难。实例对象与它的工厂函数没有关联。给出一个对象，很难知道它是通过哪个模板构造出来的（即对象的“类型”）。</li>
</ul>
<h3 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h3><p>构造函数模式的特点是：模板的所有属性都通过构造函数来定义。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Person(name, age) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.sayName = function() &#123;</span><br><span class="line">        alert(this.name);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">var person1 = new Person(&quot;p1&quot;, 21);</span><br><span class="line">var person2 = new Person(&quot;p2&quot;, 22);</span><br><span class="line">var person3 = new Person(&quot;p3&quot;, 23);</span><br></pre></td></tr></table></figure>

<p>缺陷：<br>低效率。原因与工厂模式相同。在上面这个例子中，我们每次执行一次Person构造函数，都会定义一个sayName函数（函数在js中是对象）。所有的sayName函数作用都是一样的，重复的定义显然是浪费cpu和内存资源。我们可以这样改进：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Person(name, age) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.sayName = sayName;</span><br><span class="line">&#125;</span><br><span class="line">function sayName() &#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这样做，又会有以下两个问题：</p>
<ul>
<li>在全局作用域定义的sayName仅仅只是为了给Person使用，这让全局作用域有点名不副实（全局作用域被滥用）。</li>
<li>如果Person需要定义很多方法，那么就需要定义很多个全局函数，这会污染命名空间，而且封装性很差，代码混乱。<br>基于以上原因，我们很少使用纯的构造函数模式，文章的后面会展示如何将构造函数模式与原型模式一起使用而避免这些问题。</li>
</ul>
<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>原型模式的特点是：模板的所有属性都定义在原型对象上，让所有实例对象共享原型链上的属性。每次创建对象只是创建一个[[prototype]]指向这个原型的空对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Person() &#123;&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    name: &quot;Nicholas&quot;,</span><br><span class="line">    age: 29,</span><br><span class="line">    friends: [&quot;Shelby&quot;, &quot;Court&quot;],</span><br><span class="line">    sayName: function() &#123;</span><br><span class="line">        alert(this.name);</span><br><span class="line">    &#125;,</span><br><span class="line">    constructor: Person</span><br><span class="line">&#125;;</span><br><span class="line">var person1 = new Person();</span><br><span class="line">var person2 = new Person();</span><br></pre></td></tr></table></figure>

<p>以上代码虽然使用到了构造函数和new关键字，但是我们并没有在构造函数内添加属性。使用它们仅仅是为了创建一个[[prototype]]指向这个模板的空对象。事实上，我们也可以不使用构造函数来实现原型模式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var personTemplate = &#123;</span><br><span class="line">  name: &quot;Nicholas&quot;,</span><br><span class="line">  age: 29,</span><br><span class="line">  friends: [&quot;Shelby&quot;, &quot;Court&quot;],</span><br><span class="line">  sayName: function() &#123;</span><br><span class="line">      alert(this.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var person1 = Object.create(personTemplate);</span><br><span class="line">var person2 = Object.create(personTemplate);</span><br></pre></td></tr></table></figure>

<p>缺陷：<br>使用原型模式不会出现构造函数模式中重复定义函数的问题。但是会出现其他的问题：</p>
<ul>
<li><p>如果不通过构造函数来实现原型模式（比如通过Object.create来指定新对象的原型），会出现与工厂模式相同的对象识别问题。</p>
</li>
<li><p>在实例化的时候我们无法指定新对象的属性值。比如name和age的值始终都是默认的”Nicholas”和29。程序员需要在创建实例以后自己将需要的name和age赋值给新对象。</p>
</li>
<li><p>原型链的改变会影响所有已经构造出的实例。这是一种灵活性，也是一种危险。如果我们不小心通过实例对象改变了原型链上的属性，会影响所有的实例对象。比如：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">person1.friedns.push(&#x27;new friend&#x27;);</span><br></pre></td></tr></table></figure>

<p>person1.friedns和person2.friedns都会增加’new friend’。</p>
<h3 id="组合使用构造函数模式和原型模式"><a href="#组合使用构造函数模式和原型模式" class="headerlink" title="组合使用构造函数模式和原型模式"></a>组合使用构造函数模式和原型模式</h3><p>构造函数模式和原型模式定义“模板”的思想是完全不同的：</p>
<ul>
<li>构造函数模式的思路是每次实例化对象的时候都给新对象定义属性。</li>
<li>原型模式的思路是所有实例对象共享同一条原型链。<br>这两者都有自己的缺陷，但是又不会出现对方的缺陷，因此很容易就想到，将这两个模式一起使用，优势互补。</li>
</ul>
<p>组合模式就是：<strong>通过构造函数来定义那些需要属于自己的属性，通过原型对象来定义那些需要共享的属性（尤其是函数）。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Person(name, age, friends) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.friends = friends;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    constructor: Person,</span><br><span class="line">    sayName: function() &#123;</span><br><span class="line">        alert(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var person1 = new Person(&quot;p1&quot;, 21, [&#x27;f1&#x27;, &#x27;f2&#x27;]);</span><br><span class="line">var person2 = new Person(&quot;p2&quot;, 22, [&#x27;f3&#x27;, &#x27;f4&#x27;]);</span><br></pre></td></tr></table></figure>

<p>这种创建对象的模式，是在js中被使用最多、广泛认可的定义“对象模板”的方法。</p>
<blockquote>
<p>使用原型链的时候，我们要作出合理的选择：</p>
</blockquote>
<ul>
<li>哪些属性是每个实例对象都拥有的，需要在每次实例化的时候添加到实例对象上。</li>
<li>哪些属性是所有实例共享的，只需要定义在原型对象上。这可以减少资源的浪费。</li>
</ul>
<p>缺陷：<br>组合模式已经相当好用了。程序员对组合模式的主要抱怨是：构造函数定义与原型定义的割裂。能不能将两者放在同一个代码块中呢？这时候就需要下面的动态原型模式了。</p>
<h3 id="动态原型模式"><a href="#动态原型模式" class="headerlink" title="动态原型模式"></a>动态原型模式</h3><p>动态原型模式可以看作是一种组合模式，它将原型的配置放在了构造函数中，使得“模板定义”的代码集中在了一个代码块中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Person(name, age) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    if (typeof this.sayName != &quot;function&quot;) &#123;</span><br><span class="line">        Person.prototype.sayName = function() &#123;</span><br><span class="line">            alert(this.name);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，“类”的定义更加“一体化”了。</p>
<h3 id="寄生模式"><a href="#寄生模式" class="headerlink" title="寄生模式"></a>寄生模式</h3><p>寄生模式利用已有的对象创建方式，封装得到新的对象创建方式。新特性“寄生”在旧的对象上。<br>寄生模式封装了以下步骤：</p>
<p>① 使用已有的对象创建方法，创建新的实例对象<br>② 将这个对象增强（给它增加属性）<br>③ 返回这个对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function SpecialArray() &#123;</span><br><span class="line">    var values = new Array();</span><br><span class="line">    values.push.apply(values, arguments);</span><br><span class="line">    values.toPipedString = function() &#123;</span><br><span class="line">        return this.join(&quot;|&quot;);</span><br><span class="line">    &#125;;</span><br><span class="line">    return values;</span><br><span class="line">&#125;</span><br><span class="line">var colors = new SpecialArray(&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;);</span><br><span class="line">console.log(colors.toPipedString()); </span><br><span class="line">//&quot;red|blue|green&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>以上例子中，使不使用new关键字，结果都一样。<br>寄生模式和工厂模式在本文的例子几乎一样，除了工厂函数前不能使用new关键字以外，两者的区别主要在于设计思想上：</p>
</blockquote>
<ul>
<li>工厂模式是用来大量制造复杂对象的。要制造出这些复杂对象，你可能需要在工厂函数中给对象添加属性、设置对象的原型链、拼接几个组件（对象）。</li>
<li>寄生模式用来制造已有对象的增强对象。在寄生模式的函数中，一般都是给对象添加属性。</li>
</ul>
<p>缺陷：<br>寄生模式的缺陷与工厂模式相同：低效率和对象识别。<br>不管是否使用new关键字，寄生模式的函数都像一个工厂函数，与实例对象没有关系，出现对象识别问题。在上例中colors instanceof SpecialArray的值为false；colors.constructor为Array，而不是SpecialArray。</p>
<h3 id="稳妥构造函数模式"><a href="#稳妥构造函数模式" class="headerlink" title="稳妥构造函数模式"></a>稳妥构造函数模式</h3><p>在一些特殊环境下，对象的使用者并不是对象的定义者。定义者在定义对象的时候要防止他的对象被滥用，因此定义者就需要定义“稳妥对象”来给使用者使用。<br>稳妥对象（Durable Object）是这样一种对象：</p>
<ul>
<li>它的“信息”并不直接保存在对象属性中，以防被对象的使用者随意访问。</li>
<li>对象属性上定义了一些工作方法。这些方法可以访问到这些“信息”，以便完成工作。</li>
<li>在工作方法中绝不使用this指针，而是通过闭包来访问所需要的对象“信息”。</li>
</ul>
<p>用来创建稳妥对象的函数就叫稳妥构造函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Car(make, model, year) &#123; // 传递给Car的参数是私有变量</span><br><span class="line">    var o = new Object();</span><br><span class="line"></span><br><span class="line">    var condition = &#x27;used&#x27;; // 私有变量</span><br><span class="line"></span><br><span class="line">    o.sayCar = function() &#123; // 公有函数</span><br><span class="line">        console.log(&#x27;I have a &#x27; + condition + &#x27; &#x27; + year + &#x27; &#x27; + make + &#x27; &#x27; + model + &#x27;.&#x27;);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var johnCar = Car(&#x27;Ford&#x27;, &#x27;F150&#x27;, &#x27;2011&#x27;);</span><br><span class="line"></span><br><span class="line">johnCar.sayCar();</span><br><span class="line">// I have a used 2011 Ford F150.</span><br></pre></td></tr></table></figure>

<p>johnCar对象是安全的，因为使用者只能够调用它的sayCar方法，而无法直接访问它的make, model, year, condition信息。</p>
<blockquote>
<p>这些“信息”可以理解为私有变量。<br>不一定要像上面这个例子一样，通过工厂函数来实现稳妥构造函数模式，完全可以改成使用构造函数来实现，这样还能解决对象识别的问题。可见这些对象创建模式并不是互斥的，只要掌握了它们的核心思想，就可以各取所长：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Car(make, model, year) &#123; // 传递给Car的参数是私有变量</span><br><span class="line">    var condition = &#x27;used&#x27;; // 私有变量</span><br><span class="line">    this.sayCar = function() &#123; // 公有函数</span><br><span class="line">        console.log(&#x27;I have a &#x27; + condition + &#x27; &#x27; + year + &#x27; &#x27; + make + &#x27; &#x27; + model + &#x27;.&#x27;);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">var johnCar = new Car(&#x27;Ford&#x27;, &#x27;F150&#x27;, &#x27;2011&#x27;);</span><br><span class="line">johnCar.sayCar();</span><br><span class="line">// I have a used 2011 Ford F150.</span><br><span class="line">console.log(johnCar instanceof Car);</span><br><span class="line">// true</span><br></pre></td></tr></table></figure>

<blockquote>
<p>重复定义sayCar函数是不能避免的，这是因为我们需要使用闭包，以便它能访问make, model, year, condition这些变量。闭包的使用详见彻底理解js闭包。</p>
</blockquote>
<!-- https://blog.csdn.net/u014346301/article/details/52204967 -->


<h4 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h4><p>工厂模式</p>
<ul>
<li>对象识别困难</li>
<li>重复定义函数, 占用CPU和内存空间</li>
</ul>
<p>构造函数模式</p>
<ul>
<li>虽然解决了对象识别问题, 但是依旧没有解决函数复用问题而导致的, 多次占用 CPU 和内存空间</li>
<li>改进版的构造函数模式, 虽然可以解决函数复用问题, 但这样做会将函数暴露出来, 污染全局环境</li>
</ul>
<p>原型模式</p>
<ul>
<li>如果不通过构造函数来实现原型模式,（比如通过Object.create来指定新对象的原型），会出现与工厂模式相同的对象识别问题。</li>
<li>实例化时候无法指定新对象的属性</li>
<li>原型链改变会影响所有已构造出的实例</li>
</ul>
<p>组合构造函数和原型模式</p>
<ul>
<li>定义属性和定义方法无法包裹在一个函数内</li>
</ul>
<p>动态原型模式</p>
<ul>
<li>没什么缺陷, 通过typeof判断属性值是否是函数, 是函数则在原型上定义该函数</li>
<li>使用动态原型模式时，不能使用对象字面量重写原型。如果在已经创建了实例的情况下重写原型，那么就会切断现有的实例与新原型之间的联系。</li>
</ul>
<p>寄生模式</p>
<ul>
<li>寄生模式和工厂模式一样, 通过已有对象创建新的实例方法</li>
<li>一般通过寄生模式为对象添加新属性, 不过这样会导致出现工厂函数同样的问题</li>
</ul>
<p>稳妥构造函数模式</p>
<ul>
<li>可以创建私有变量, 只暴露出接口</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>object</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise 原理解析</title>
    <url>/2020/06/28/frontEnd/promise%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p><img src="/2020/06/28/frontEnd/promise%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/image-20210727200920395.png" alt="image-20210727200920395"></p>
<span id="more"></span>


<blockquote>
<p>promise 有三种状态 pending（进行中），fulfilled（成功），rejected（失败）</p>
<p>有 7 种方法</p>
<p>Promise.prototype.then()</p>
<p>Promise.all()</p>
<p>Promise.race()</p>
<p>Promise.resolve()</p>
<p>Promise.reject()</p>
<p>Promise.prototype.catch()</p>
<p>Promise.prototype.finally()</p>
</blockquote>
<h3 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then()"></a>Promise.prototype.then()</h3><h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h3><blockquote>
<p>Promise.all() 用于将多个 Promise 实例，包装成一个新的 Promise 实例，子 Promise 全部完成时，触发 then</p>
</blockquote>
<p>它传入一个数组，数组均为 Promise 对象，返回值也是一个数组，数组里面是结果的值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">myPromise.all = function(promiseArr = []) &#123;</span><br><span class="line">	return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        let result = []</span><br><span class="line">        let index = 0</span><br><span class="line">        function addData(key, value) &#123;</span><br><span class="line">            result[key] = value</span><br><span class="line">            index++</span><br><span class="line">            if (index === promiseArr.length) &#123;</span><br><span class="line">                resolve(result)</span><br><span class="line">                console.log(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (let i = 0; i &lt; promiseArr.length; i++) &#123;</span><br><span class="line">            if (promiseArr[i] instanceof Promise) &#123;</span><br><span class="line">                promiseArr[i].then(data =&gt; &#123;</span><br><span class="line">                    addData(i, data)</span><br><span class="line">                &#125;, reason =&gt; &#123;</span><br><span class="line">                    reject(reason)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                addData(i, arr[i])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h3><blockquote>
<p>Promise.race() 用于将多个 Promise 实例，包装成一个新的 Promise 实例，返回最快完成的子 Promise，触发 then</p>
</blockquote>
<p>它传入一个数组，数组均为 Promise 对象，返回值是一个值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">myPromise.race = function(promiseArr = []) &#123;</span><br><span class="line">	return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">		for(let i = 0; i &lt; promiseArr.length; i++) &#123;</span><br><span class="line">			let current = promiseArr[i];</span><br><span class="line">			if(current instanceof Promise) &#123;</span><br><span class="line">				current.then(resolve, reject)</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				resolve(current)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let promise1 = new Promise(resolve =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; resolve(1), 1000)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">let promise2 = new Promise(resolve =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; resolve(2), 4000)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">let promise3 = new Promise(resolve =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; resolve(3), 2000)</span><br><span class="line">&#125;)</span><br><span class="line">myPromise.all([promise1, promise2, promise3]).then(v =&gt; console.log(v))</span><br></pre></td></tr></table></figure>



<h3 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h3><blockquote>
<p>将值转换成 Promise 对象，并返回 resolve 值</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">myPromise.resolve = function(item) &#123;</span><br><span class="line">	if(item instanceof Promise) &#123;</span><br><span class="line">		return item</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		return new Promise(resolve =&gt; resolve(item))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h3><blockquote>
<p>将值转换成 Promise 对象，并返回 reject 值</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">myPromise.reject = function(item) &#123;</span><br><span class="line">	return new Promise((resolve, reject) =&gt; reject(item))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Promise-finally"><a href="#Promise-finally" class="headerlink" title="Promise.finally()"></a>Promise.finally()</h3><blockquote>
<p>无论成功还是失败都要执行 finally 方法，返回一个 Promise 对象</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">myPromise.finally = function(callback) &#123;</span><br><span class="line">	return this.then(value =&gt; &#123;</span><br><span class="line">		return new Promise.resolve(callback()).then(() =&gt; value)</span><br><span class="line">	&#125;, reason =&gt; &#123;</span><br><span class="line">		return new Promise.resolve(callback()).then(() =&gt; throw reason)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Promise-catch"><a href="#Promise-catch" class="headerlink" title="Promise.catch()"></a>Promise.catch()</h3><blockquote>
<p>捕获错误方法</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">myPromise.catch = function(failCallback) &#123;</span><br><span class="line">	return this.then(undefined, failCallback)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>promise</tag>
      </tags>
  </entry>
  <entry>
    <title>no-cache,max-age=0,no-store一样吗?</title>
    <url>/2020/06/21/network/maxage=0/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>network</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>create-react-app修改webpack(配置项)方法</title>
    <url>/2020/06/01/frontEnd/create-react-app%E4%BF%AE%E6%94%B9webpack(%E9%85%8D%E7%BD%AE%E9%A1%B9)%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p><img src="/2020/06/01/frontEnd/create-react-app%E4%BF%AE%E6%94%B9webpack(%E9%85%8D%E7%BD%AE%E9%A1%B9)%E6%96%B9%E6%B3%95/image-20210720104450241.png" alt="image-20210720104450241"></p>
<span id="more"></span>

<p>我们都知道 create-react-app 是将 webpack 配置文件隐藏起来的，但在项目过程中，我们需要修改配置文件，这里提供两个方法</p>
<ul>
<li>通过 eject 命令释放 webpack 文件<br>react-scripts 是 create-react-app 的一个核心包，一些脚本和工具的默认配置都集成在里面，而 yarn eject 命令执行后会将封装在 create-react-app 中的配置全部反编译到当前项目，这样用户就能完全取得 webpack 文件的控制权。所以，eject 命令存在的意义就是更改 webpack 配置，通过 eject 方法释放的配置文件这个操作是不可逆的，要谨慎<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm run eject</span><br></pre></td></tr></table></figure></li>
<li>react-app-rewired<br>安装react-app-rewired<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install react-app-rewired --save-dec</span><br></pre></td></tr></table></figure>
在 package.json 中，将原本的 react-script 改为 react-app-rewired<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;start&quot;: &quot;react-app-rewired start&quot;,</span><br><span class="line">  &quot;build&quot;: &quot;react-app-rewired build&quot;,</span><br><span class="line">  &quot;test&quot;: &quot;react-app-rewired test&quot;,</span><br><span class="line">  &quot;eject&quot;: &quot;react-app-rewired eject&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在根目录下新建config-overrides.js,在config-overrides.js里更改配置项，项目启动的时候会先在config-overrides.js里读数据，对webpack里的默认文件进行整合，最后才会启动。</li>
</ul>
<p>要对 webpack 配置，还需要安装 customize-cra 包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install customize-cra --save-dev</span><br></pre></td></tr></table></figure>
<p><code>customize-cra</code> 利用 <code>react-app-rewired</code> 和 <code>config-overrides.js</code> 文件。通过导入<code>customize-cra</code> 函数并导出包装在我们的 <code>override</code> 函数中的一些函数调用，您可以轻松地修改构成 <code>create-react-app</code> 的基础配置对象（webpack，webpack-dev-server，babel等）。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>如何设计一个 Restful Api</title>
    <url>/2020/05/01/network/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AARestfulApi/</url>
    <content><![CDATA[<p><img src="/2020/05/01/network/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AARestfulApi/image-20210719171209274.png" alt="image-20210719171209274"></p>
<blockquote>
<p>在开发 BFF 层时候，会涉及到很多 api 设计，无论是命名还是请求方法，没有一定的套路，会很慕凌两可，没有任何头绪。</p>
</blockquote>
<span id="more"></span>

<p>基于这些痛点，从 8 个维度对 API 进行探讨</p>
<ul>
<li><p>协议</p>
<p>  基本上都是 http 或 https 协议</p>
</li>
<li><p>域名</p>
<p>  如果是大型服务，一般会为 api 开专属域名</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://api.xxx.com</span><br></pre></td></tr></table></figure>

<p>  不过，一般来说，对于简单的 api 都是加在主域名下面</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://xxx.com/api/</span><br></pre></td></tr></table></figure></li>
<li><p>版本</p>
<p>  随着迭代的进行，api 可能有 v1，v2，v3 等，这样的设计的好处是，不同版本下接口含义相同无所谓，譬如说，同样是部署功能，v1 版可能是 a 逻辑，v2 版可能是 b 逻辑，这样可以兼容旧版本</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://xxx.com/api/v1/</span><br><span class="line">https://xxx.com/api/v2/</span><br></pre></td></tr></table></figure>

<p>  另一种做法是，将版本号放在HTTP头信息中，但不如放入URL方便和直观。</p>
</li>
<li><p>路径</p>
<p>  路径又称”终点”（endpoint），表示 API 的具体网址。</p>
<p>  在 RESTful 架构中，每个网址代表一种资源（resource），所以网址中<strong>不能有动词，只能有名词</strong>，而且<strong>所用的名词往往与数据库的表格名对应</strong>。一般来说，数据库中的表都是同种记录的”集合”（collection），所以 API 中的名词也应该使用复数。</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://xxx.com/api/v1/zoos</span><br></pre></td></tr></table></figure></li>
<li><p>方法</p>
<ul>
<li>GET：从服务器取出资源</li>
<li>POST：在服务器新建一个资源</li>
<li>PUT：在服务器更新资源</li>
<li>DELETE：从服务器删除资源</li>
</ul>
</li>
<li><p>过滤信息（Query）</p>
<p>  综合来说，对于 GET 请求，用到 query 时要想着过滤两个字</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?limit=10：指定返回记录的数量</span><br><span class="line">?offset=10：指定返回记录的开始位置</span><br><span class="line">?page=2&amp;per_page=100：指定第几页，以及每页的记录数。</span><br><span class="line">?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。</span><br><span class="line">?animal_type_id=1：指定筛选条件</span><br></pre></td></tr></table></figure></li>
<li><p>状态码</p>
<ul>
<li>200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。</li>
<li>201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。</li>
<li>202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务）</li>
<li>204 NO CONTENT - [DELETE]：用户删除数据成功。</li>
<li>400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。</li>
<li>401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。</li>
<li>403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。</li>
<li>404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。</li>
<li>406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。</li>
<li>410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。</li>
<li>422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。</li>
<li>500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。</li>
</ul>
</li>
<li><p>Hypermedia API</p>
<p>  这是一个新的思路，Hypermedia API 是指返回结果中提供链接，连向其他 API 方法，使得用户不查文档，也知道下一步应该做什么。</p>
<p>  譬如当用户向 api.example.com 的根目录发出请求，会得到这样一个文档。</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&quot;link&quot;: &#123;</span><br><span class="line">  &quot;rel&quot;:   &quot;collection https://www.example.com/zoos&quot;,</span><br><span class="line">  &quot;href&quot;:  &quot;https://api.example.com/zoos&quot;,</span><br><span class="line">  &quot;title&quot;: &quot;List of zoos&quot;,</span><br><span class="line">  &quot;type&quot;:  &quot;application/vnd.yourformat+json&quot;</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>  文档中有一个 link 属性，用户读取这个属性就知道下一步该调用什么 API 了。rel 表示这个 API 与当前网址的关系（collection关系，并给出该collection的网址），href 表示 API 的路径，title 表示 API 的标题，type 表示返回类型。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title>圣杯模型和双飞翼模型</title>
    <url>/2020/03/28/frontEnd/%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E5%92%8C%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<p><img src="/2020/03/28/frontEnd/%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E5%92%8C%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80/image-20210727220451665.png" alt="image-20210727220451665"></p>
<span id="more"></span>

<p>圣杯模型和双飞翼模型都是为了实现三列的布局的，中间内容宽度自适应，两边内容宽度固定。</p>
<blockquote>
<p>很好理解呀，想象一下，圣杯，就是奖杯，两边两个耳朵，中间可大可小，但是两边是不变的；双飞翼，想象成鸟，鸟的翅膀是不变的，鸟吃的多，肚子就胖了。</p>
</blockquote>
<p><img src="/2020/03/28/frontEnd/%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E5%92%8C%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80/86025519-e03de180-ba60-11ea-8659-54d2eb4d087b.png" alt="img"></p>
<p><img src="/2020/03/28/frontEnd/%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E5%92%8C%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80/86025687-111e1680-ba61-11ea-923a-6e222d888c0f.png" alt="img"></p>
<p>这两个模型都是一样的只是叫法不同罢了，它的布局要求有几点：</p>
<ul>
<li><p>三列布局，中间宽度自适应，两边定宽</p>
</li>
<li><p>中间栏要在浏览器中优先展示渲染</p>
</li>
<li><p>允许任意列的高度最高</p>
</li>
</ul>
<h2 id="圣杯模型"><a href="#圣杯模型" class="headerlink" title="圣杯模型"></a>圣杯模型</h2><p>实现代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;style&gt;</span><br><span class="line">    .header &#123;</span><br><span class="line">      background-color: red;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .container &#123;</span><br><span class="line">      overflow: hidden;</span><br><span class="line">      padding:0 200px 0 200px;</span><br><span class="line">    &#125;</span><br><span class="line">    .main &#123;</span><br><span class="line">      float: left;</span><br><span class="line">      position: relative;</span><br><span class="line">      background-color: orange;</span><br><span class="line">      width: 100%;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .left &#123;</span><br><span class="line">      margin-left: -100%;</span><br><span class="line">      float: left;</span><br><span class="line">      position: relative;</span><br><span class="line">      left: -200px;</span><br><span class="line">      background-color: green;</span><br><span class="line">      width: 200px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .right &#123;</span><br><span class="line">      margin-left: -200px;</span><br><span class="line">      float: left;</span><br><span class="line">      position: relative;</span><br><span class="line">      right: -200px;</span><br><span class="line">      background-color: yellow;</span><br><span class="line">      width: 200px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .footer &#123;</span><br><span class="line">      position: relative;</span><br><span class="line">      background-color: blue;</span><br><span class="line">      clear: both;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div class=&quot;header&quot;&gt;</span><br><span class="line">    header</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;container&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;main&quot;&gt;main&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;footer&quot;&gt;</span><br><span class="line">    footer</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>这里主要说几个技术点</p>
<ul>
<li><p>html 布局方式上（header）中（container）下（footer），container 中呈现圣杯式布局方案 <code>main</code>，<code>left</code>，<code>right</code></p>
</li>
<li><p><code>main</code> 放第一位的主要原因是为了实现<strong>中间栏要在浏览器中优先展示渲染</strong>这个需求。</p>
</li>
<li><p>container 中的元素均采用浮动方式，让元素左对齐 <code>float: left</code>。</p>
<p><img src="/2020/03/28/frontEnd/%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E5%92%8C%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80/86025742-24c97d00-ba61-11ea-808c-dedd13962656.png" alt="img"></p>
</li>
<li><p>由于 container 中元素都浮动了，这会导致 footer 元素也跟着到了第二行，为了解决这个问题，我们要用到清除浮动骚操作  <code>clear:both</code>。</p>
<p><img src="/2020/03/28/frontEnd/%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E5%92%8C%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80/86025875-54788500-ba61-11ea-8bfc-2eca818241c5.png" alt="img"></p>
</li>
<li><p>解决完清除浮动，在 container 中设置边框会发现，出现了高度塌陷问题，如紫色部分。</p>
<p><img src="/2020/03/28/frontEnd/%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E5%92%8C%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80/86025991-7a058e80-ba61-11ea-94c7-247e5b5de9fc.png" alt="img"></p>
</li>
<li><p>为了解决这一问题，我们要给 container 加上 <code>overflow: hidden</code>，触发 BFC 闭合浮动</p>
<p><img src="/2020/03/28/frontEnd/%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E5%92%8C%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80/86026072-8e498b80-ba61-11ea-92c5-2eebbc7590ba.png" alt="img"></p>
</li>
<li><p>由于我们的前提是左右固定，中间自适应，因此在宽度属性上，左右 200px，中间 100%，因此中间宽度 100% 后两边会撑下去。</p>
<p><img src="/2020/03/28/frontEnd/%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E5%92%8C%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80/86026197-b2a56800-ba61-11ea-9682-869dc7e7314c.png" alt="img"></p>
</li>
<li><p>为了解决这个问题，我们要用到 margin 负值大法，左边元素 <code> margin-left: -100%;</code>，右边元素 <code>margin-left: -200px;</code> 此时的 main 在最底下。</p>
<p><img src="/2020/03/28/frontEnd/%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E5%92%8C%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80/86026710-5a229a80-ba62-11ea-90be-2d340d4296df.png" alt="img"></p>
</li>
<li><p>为了让 main 出现，我们通过调整 container 的 padding 实现</p>
<p><img src="/2020/03/28/frontEnd/%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E5%92%8C%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80/86026636-44ad7080-ba62-11ea-943d-981c77c622e9.png" alt="img"></p>
</li>
</ul>
<ul>
<li><p>最后，通过 relative 调整元素位置，实现圣杯模型布局</p>
<p><img src="/2020/03/28/frontEnd/%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E5%92%8C%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80/86026755-69a1e380-ba62-11ea-9300-09cb7e65a505.png" alt="img"></p>
</li>
</ul>
<h2 id="双飞翼布局"><a href="#双飞翼布局" class="headerlink" title="双飞翼布局"></a>双飞翼布局</h2><p>实现代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">  &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">  &lt;style&gt;</span><br><span class="line">    .header &#123;</span><br><span class="line">      background-color: red;</span><br><span class="line">    &#125;</span><br><span class="line">    .container &#123;</span><br><span class="line">      overflow: hidden;</span><br><span class="line">    &#125;</span><br><span class="line">    .main &#123;</span><br><span class="line">      float: left;</span><br><span class="line">      width: 100%;</span><br><span class="line">    &#125;</span><br><span class="line">    .content &#123;</span><br><span class="line">      background-color: blue;</span><br><span class="line">      margin: 0 200px 0 200px;</span><br><span class="line">    &#125;</span><br><span class="line">    .left &#123;</span><br><span class="line">      float: left;</span><br><span class="line">      margin-left: -100%;</span><br><span class="line">      width: 200px;</span><br><span class="line">      background-color: green;</span><br><span class="line">    &#125;</span><br><span class="line">    .right &#123;</span><br><span class="line">      float: left;</span><br><span class="line">      margin-left: -200px;</span><br><span class="line">      width: 200px;</span><br><span class="line">      background-color: yellow;</span><br><span class="line">    &#125;</span><br><span class="line">    .footer &#123;</span><br><span class="line">      background-color: violet;</span><br><span class="line">      clear: both;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div class=&quot;header&quot;&gt;</span><br><span class="line">    header</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;container&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;main&quot;&gt;</span><br><span class="line">      &lt;div class=&quot;content&quot;&gt;</span><br><span class="line">        main</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;footer&quot;&gt;footer&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>圣杯模型和双飞翼布局大部分实现思想是相同，也都是三栏全部 float 浮动，左右两栏加上负 margin 让其跟中间栏 div 并排，实现三栏布局。他们的唯一区别在于解决<strong>中间栏 div 内容不被遮挡</strong>问题的思路不一样。</p>
<p>圣杯布局的中间栏是通过设置 container 的内边距和相对定位来解决覆盖问题。而双飞翼中，我们是在 main 中加一个 content 来显示内容，然后设置 margin 为左右栏 div 留出位置。</p>
<p>相对于圣杯模型，双飞翼多使用了一个 div，却少了 4 个 css 属性（圣杯布局 container 的 padding-left 和padding-right 这2个属性，加上左右两个 div 用相对布局 position: relative 及对应的 right 和 left 共 4 个属性）而双飞翼布局子 div 里用 margin-left 和 margin-right 共 2 个属性，比圣杯布局思路更直接和简洁一点。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>防抖和节流</title>
    <url>/2020/03/26/frontEnd/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/</url>
    <content><![CDATA[<p><img src="/2020/03/26/frontEnd/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/image-20210719161517412.png" alt="image-20210719161517412"></p>
<p>在网上，关于防抖和节流的实现方式已经很多了，这里也就不在依依列举，只是说说这两种思想方式，要注意，函数防抖和节流只是一种解决问题的设计思想罢了。</p>
<span id="more"></span>

<h3 id="思想缘由"><a href="#思想缘由" class="headerlink" title="思想缘由"></a>思想缘由</h3><p>在浏览器中，频繁的操作 DOM 是非常消耗内存和 CPU 时间，在我们项目开发过程中，或多或少会绑定一些持续触发的事件，如 resize，scroll，mousemove 以及移动端 touchmove 等。同一个事件在同一刻产生大量的事件函数，若处理不当，轻则导致浏览器卡顿，重则导致浏览器崩溃，无论出现哪种情况，都不是我们所期望的，此时，函数防抖 (debounce) 和节流 (throttle) 的思想应运而生。</p>
<p>函数防抖和节流就是为了处理同一时刻事件的触发频率和事件函数的执行频率这两者关系的。<br>我们知道 DOM 事件的触发频率是不可控的，因此我们只能控制事件函数的执行频率，只要是没有达到条件要求的事件，都不触发事件函数，通过这一手段，可以极大的优化浏览器的性能。</p>
<h3 id="函数防抖"><a href="#函数防抖" class="headerlink" title="函数防抖"></a>函数防抖</h3><blockquote>
<p>函数防抖是指某事件被频繁的触发，在延迟一定的时间内，若该事件没有继续被触发，则执行事件函数，在整个过程中，事件函数只会被触发一次。</p>
</blockquote>
<p>应用场景：在事件连续触发过程中，你期望事件函数只执行一次，例如：Ajax实时搜索（keydown）。</p>
<p>举个例子，我们在浏览页面内容的时候经常会使用到滚动条，若此时我们绑定了一个滚动条事件，但是，并没有加任何的防抖保护，这意味着用户只要触动了滚动条，就会产生成百上千条滚动事件，进而触发成百上千次事件函数，若每条事件函数的时间复杂度为O(n²)，后果可想而知，直接把浏览器搞崩了，这样的产品，还没开始，已经结束了。</p>
<p>此时，若加上防抖，效果就大大的不同了，<strong>我们虽然无法阻止事件的触发频率，但是可以控制事件函数的执行频率</strong>，无论你触发了多少次事件，只要在保护时间内有触发，就不执行事件函数，反之，执行。</p>
<p>没有什么能比图片更形象的了👇</p>
<p><img src="/2020/03/26/frontEnd/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/16875c49b54c388b.jpeg" alt="防抖"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function debounce(func, wait) &#123;</span><br><span class="line">  let timeout = null;</span><br><span class="line">  return function() &#123;</span><br><span class="line">    let _this = this;</span><br><span class="line">    let args = arguments;</span><br><span class="line">    if (timeout) &#123;</span><br><span class="line">      clearTimeout(timeout)</span><br><span class="line">    &#125;</span><br><span class="line">    timeout = setTimeout(() =&gt; &#123;</span><br><span class="line">        func.apply(_this, args)</span><br><span class="line">    ), wait)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>防抖的核心就是通过定时器来延迟事件函数的执行，在未达到定时器时间情况下，依旧产生了触发事件，就将上一个定时器删除。</p>
<h3 id="函数节流"><a href="#函数节流" class="headerlink" title="函数节流"></a>函数节流</h3><p>函数节流是指某事件被频繁的触发，在事件触发期间，它会周期的执行事件函数。</p>
<blockquote>
<p>举个例子，水滴的下落，我们将水喉拨到一个角度，水滴会周期性一滴一滴的滴落。</p>
</blockquote>
<p>应用场景：在事件连续触发过程中，你期望周期性的间隔一定时间来调用回调函数，例如：计算鼠标移动的距离（mousemove）</p>
<p><img src="/2020/03/26/frontEnd/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/168762255558206d.jpeg" alt="节流"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function (func, wait) &#123;</span><br><span class="line">  let time = null;</span><br><span class="line">  return function() &#123;</span><br><span class="line">    let _this = this;</span><br><span class="line">    let args = arguments;</span><br><span class="line">    if (!timer) &#123;</span><br><span class="line">      timer = setTimeout(function() &#123;</span><br><span class="line">        func.apply(_this, args)</span><br><span class="line">        timer = null</span><br><span class="line">      &#125;, delay)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>npm 和 yarn 那些事</title>
    <url>/2020/03/05/github/npm%E5%92%8Cyarn/</url>
    <content><![CDATA[<p><img src="/2020/03/05/github/npm%E5%92%8Cyarn/image-20210727215037064.png" alt="image-20210727215037064"></p>
<span id="more"></span>

<p>今天同事给了我一个新项目，按照以往经验</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone xxx</span><br><span class="line">npm i</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure>

<p>这时候，同事也给我来了波操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone xxx</span><br><span class="line">yarn</span><br><span class="line">yarn dev</span><br></pre></td></tr></table></figure>

<p>以前有用过 yarn 但是没深入了解，就问了下同事，yarn 和 npm 有啥区别呀？</p>
<p>空气安静了几分钟，说明，这种问题 du 一下就知道了。</p>
<p>带着疑虑</p>
<p><strong>Yarn 是什么？</strong></p>
<p>从<a href="https://engineering.fb.com/web/yarn-a-new-package-manager-for-javascript/">官方文档</a>中我们知道，yarn 是 js 的新软件包管理工具，它是为了<strong>弥补 npm 缺陷而出现的替代产物</strong>，也就是说，它比 npm 更强，能用 npm 实现的，用它也能实现。</p>
<p><strong>npm 的问题</strong></p>
<ul>
<li><p>用 npm 的时候，我们经常会有这种感觉，巨慢，巨慢，巨慢，无论是拉下一个新项目还是删除 node_modules 重新 install 时候依旧如此。</p>
</li>
<li><p>之前的 npm 还无法锁定版本号，这就导致同一个项目，安装的时候<strong>无法保持一致性</strong>，下面列举了三个版本号在安装时代表的不同含义，不过这点 npm 后面也修复了，也有了 package.lock.json 文件。</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;6.0.6&quot; </span><br><span class="line">&quot;~6.0.6&quot;</span><br><span class="line">&quot;^6.0.6&quot;</span><br></pre></td></tr></table></figure>

<p>  这三种版本表示法是代表什么含义呢？</p>
<p>  “6.0.6” 表示安装指定的 6.0.6 版本</p>
<p>  “~6.0.6” 表示安装 6.0.X 中最新的版本</p>
<p>  “^6.0.6” 表示安装 6.X.X 中最新的版本</p>
</li>
<li><p>安装的时候，包会在同一时间下载和安装，中途某个时候，一个包抛出了一个错误，但是 npm 依旧会继续下载和安装包。因为npm会把所有的日志输出到终端，有关错误包的错误信息就会在一大堆npm打印的警告中丢失掉，并且你甚至永远<strong>不会注意到实际发生的错误</strong>。</p>
</li>
</ul>
<p><strong>yarn 的优势</strong></p>
<ul>
<li><p>速度快，体现在两个方面</p>
<ul>
<li>并行安装：无论是 npm 还是 yarn 在执行包的安装时，都会执行一系列任务，npm 是按照队列执行每个 package，也就是说必须要等到当前 package 安装完成之后，才能继续后面的安装。而 Yarn 是同步执行所有任务，提高了性能。</li>
<li>离线模式：若之前已经安装过一个软件包，用 yarn 再次安装时会从缓存中获取，不用像 npm 那样从网络下载。</li>
</ul>
</li>
<li><p>安装<strong>版本统一</strong></p>
<ul>
<li>这点 npm 也统一了安装包，但还是说明下，yarn 的统一方式和原理，为了防止拉取到不同的版本，Yarn 有一个锁定文件 (lock file) 记录了被确切安装上的模块的版本号。每次只要新增了一个模块，Yarn 就会创建（或更新）yarn.lock 这个文件。这么做就保证了，每一次拉取同一个项目依赖时，使用的都是一样的模块版本。npm 其实也有办法实现处处使用相同版本的 packages，但需要开发者执行 npm shrinkwrap 命令。这个命令将会生成一个锁定文件，在执行 npm install 的时候，该锁定文件会先被读取，和 Yarn 读取 yarn.lock 文件一个道理。npm 和 Yarn 两者的不同之处在于，Yarn 默认会生成这样的锁定文件，而 npm 要通过 shrinkwrap 命令生成 npm-shrinkwrap.json 文件，只有当这个文件存在的时候，packages 版本信息才会被记录和更新。</li>
</ul>
</li>
<li><p>更简洁的输出</p>
<ul>
<li>npm 的输出信息比较冗长。在执行 npm install 的时候，命令行里会不断地打印出所有被安装上的依赖。相比之下，Yarn 简洁太多：默认情况下，结合了 emoji直观且直接地打印出必要的信息，也提供了一些命令供开发者查询额外的安装信息。</li>
</ul>
</li>
<li><p>多注册来源处理</p>
<ul>
<li>所有的依赖包，不管他被不同的库间接关联引用多少次，安装这个包时，只会从一个注册来源去装，要么是 npm 要么是 bower, 防止出现混乱不一致。</li>
</ul>
</li>
<li><p>更好的语义化</p>
<ul>
<li>yarn改变了一些npm命令的名称，比如 yarn add/remove，感觉上比 npm 原本的 install/uninstall 要更清晰。</li>
</ul>
</li>
</ul>
<p><strong>yarn 的安装过程</strong></p>
<ul>
<li>解析<ul>
<li>Yarn 通过向注册表发出请求并递归查找每个依赖关系来开始解决依赖关系。</li>
</ul>
</li>
<li>获取<ul>
<li>接下来，Yarn在全局缓存目录中查找是否已经下载了所需的软件包。如果没有，Yarn 会获取软件包并将其放置在全局缓存中，这样它就可以脱机工作并且不需要多次下载依赖项。依赖的也可以作为离线安装包放在源代码管理中。</li>
</ul>
</li>
<li>链接<ul>
<li>最后，Yarn通过将全局缓存中所需的所有文件复制到本地<code>node_modules</code>目录中，将所有内容链接在一起。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>github</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>npm</tag>
        <tag>yarn</tag>
      </tags>
  </entry>
  <entry>
    <title>别再问我 React 组件怎么写了</title>
    <url>/2019/12/05/frontEnd/%E5%88%AB%E5%86%8D%E9%97%AE%E6%88%91React%E7%BB%84%E4%BB%B6%E6%80%8E%E4%B9%88%E5%86%99%E4%BA%86/</url>
    <content><![CDATA[<p><img src="/2019/12/05/frontEnd/%E5%88%AB%E5%86%8D%E9%97%AE%E6%88%91React%E7%BB%84%E4%BB%B6%E6%80%8E%E4%B9%88%E5%86%99%E4%BA%86/image-20210716221604377.png" alt="image-20210716221604377"></p>
<p>React 是一个 Javascript 库, 主要用于构建 UI 的, 因此抛开<strong>组件去谈React是没有灵魂的</strong>，React 的核心就是围绕组件展开的。</p>
<span id="more"></span>

<h3 id="组件划分"><a href="#组件划分" class="headerlink" title="组件划分"></a>组件划分</h3><p><img src="/2019/12/05/frontEnd/%E5%88%AB%E5%86%8D%E9%97%AE%E6%88%91React%E7%BB%84%E4%BB%B6%E6%80%8E%E4%B9%88%E5%86%99%E4%BA%86/image-20210715141852795.png" alt="image-20210715141852795"></p>
<p>当我们拿到一张设计稿时可以这样去拆解，按功能，按模块，按领域，依依划分。</p>
<p>大家不用太纠结怎么拆，在这里你只用大概知道，这次开发会涉及那些组件，那些组件能够组合。</p>
<p>在前端领域中，DOM 中<strong>节点</strong>是最小单位，节点上面是<strong>元素</strong>，而 React 带来了组件，一个<strong>组件</strong>是由多个元素组成。因此组件是由一个一个元素组合而成的，而这就是组件设计中的<strong>最小颗粒度</strong>。</p>
<p>组件在设计上具备可枚举性和通用性，因此<strong>组件可以分为基础组件和业务组件</strong>，例如 antd 组件库就是典型的基础组件。</p>
<h4 id="基础组件"><a href="#基础组件" class="headerlink" title="基础组件"></a>基础组件</h4><p><strong>基础组件</strong>颗力度小，强调的是通用性，可以理解为纯组件，一般由多个元素拼凑而成。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const Button = (props) =&gt; (&lt;button onClick=&#123;props.handleClick&#125;&gt;按钮&lt;/button&gt;)</span><br></pre></td></tr></table></figure>

<p>刚刚还提到另外一个组件，没错，它就是<strong>业务组件</strong>！</p>
<h4 id="业务组件"><a href="#业务组件" class="headerlink" title="业务组件"></a>业务组件</h4><p>在理解业务组件前，要理解什么是业务，业务指的是项目中的具体实现，譬如说，学生管理系统这个项目，学生成绩查询就是具体的业务，而多个业务凑在一起就形成了项目。</p>
<p>理解了业务，业务代码就很好理解了，为了实现某个业务功能的代码就是业务代码，学生成绩查询可能包括搜索，筛选等业务功能。</p>
<p>同理，业务组件就是实现业务功能的组件。</p>
<p>业务组件更强调的是垂直业务而言的，会有特定的交互逻辑和数据处理逻辑，也可以理解为根据业务的需求，将<strong>单个</strong>基础组件进行功能的扩展。注意，这里强调的是<strong>单个</strong>，整合多个基础组件，这里面依旧不包含<strong>事件处理、状态管理、数据请求等逻辑</strong>。</p>
<p>举个例子：</p>
<p>按钮组件，它是个基础组件，在赋予业务能力时，它就变成了搜索按钮，跳转到具体url按钮，删除按钮，<strong>将基础组件赋予一定定向的能力后，它就成了业务组件。</strong></p>
<p>没错了，业务组件是一类具有<strong>定向能力</strong>（我也不知道为什么会想到这个词，感觉蛮贴切的）的组件。</p>
<p>所以，基础组件具有<strong>通用性</strong>，而业务组件具有<strong>定向性</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const GoHome = (props) =&gt; &#123;</span><br><span class="line">	const goUrl = () =&gt; &#123;&#125;</span><br><span class="line">	return &lt;Button handleClick=&#123;goUrl&#125; /&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>GoHome 组件只有一个功能，那就是 goHome</p>
<p><img src="/2019/12/05/frontEnd/%E5%88%AB%E5%86%8D%E9%97%AE%E6%88%91React%E7%BB%84%E4%BB%B6%E6%80%8E%E4%B9%88%E5%86%99%E4%BA%86/image-20210715151326931.png" alt="image-20210715151326931"></p>
<p>基础组件是业务组件的抽象，而业务组件是基础组件的具体。</p>
<p>组件和组件间的组合在一起是什么呢？没错了，那就是<strong>区块</strong></p>
<h4 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h4><p>组件与组件是可以自由组合的，形式大体分两种，组合，嵌套。</p>
<p>区块更多的是承担<strong>组件间的逻辑</strong>，它就像一个中转站，可以让组件 A，组件 B 之间的数据自由交换。在区块中，会有更少的 UI，取而代之的是更多的逻辑和状态。像<strong>事件处理、状态管理、数据请求</strong>都在这处理。</p>
<p>区块的一大标志——<strong>不对外暴露接口属性，也就是没有 props</strong>。这带来的好处是区块与前端项目无依赖关系，对区块定制是通过修改项目中的区块代码来实现的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 假设有两个业务组件，一个是输入框，一个是 goUrl 按钮</span><br><span class="line">const Block = () =&gt; &#123;</span><br><span class="line">	const [state, setState] = useState(&#x27;&#x27;)</span><br><span class="line">	return (</span><br><span class="line">		&lt;&gt;</span><br><span class="line">			&lt;Input onChange=&#123;setState&#125; /&gt;</span><br><span class="line">			&lt;GoUrl url=&#123;state&#125;/&gt;</span><br><span class="line">		&lt;/&gt;</span><br><span class="line">	)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 区块的使用</span><br><span class="line">const Page = () =&gt; &#123;</span><br><span class="line">	return (</span><br><span class="line">		&lt;Block /&gt;</span><br><span class="line">	)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>区块网上又是什么呢？没错了，就是<strong>页面</strong>。</p>
<h4 id="页面"><a href="#页面" class="headerlink" title="页面"></a>页面</h4><p>页面是当前路由下的最高层，它是由多个区块组合而成的，它是浏览器窗口中所有功能的集合，而一个应用是由多个页面拼凑而成的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const Page = () =&gt; &#123;</span><br><span class="line">	return (</span><br><span class="line">		&lt;&gt;</span><br><span class="line">			&lt;Block /&gt;</span><br><span class="line">			&lt;Block1 /&gt;</span><br><span class="line">			&lt;Block2 /&gt;</span><br><span class="line">		&lt;/&gt;</span><br><span class="line">	)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>页面没啥功能，就是区块的承载者。</p>
<p>这里小结一下，<strong>前端应用，有多个路由，每个路由对应一个页面，一个页面又由多个区块组成，每个区块又由多个业务组件构成，业务组件又是由基础组件演变而来的。</strong></p>
<p>一个或多个页面则组成了**应用(Application)<strong>。开发应用的组织模式，就是</strong>前端项目(Project)**。前端项目可以这样划分</p>
<p><img src="/2019/12/05/frontEnd/%E5%88%AB%E5%86%8D%E9%97%AE%E6%88%91React%E7%BB%84%E4%BB%B6%E6%80%8E%E4%B9%88%E5%86%99%E4%BA%86/image-20210714011757190.png" alt="image-20210714011757190"></p>
<p>我们还可以总结一点，基础组件具备的是通用性，更加强调 UI，而到了页面层，更少去处理 UI，更多的是逻辑状态。</p>
<p><img src="/2019/12/05/frontEnd/%E5%88%AB%E5%86%8D%E9%97%AE%E6%88%91React%E7%BB%84%E4%BB%B6%E6%80%8E%E4%B9%88%E5%86%99%E4%BA%86/image-20210715160127501.png" alt="image-20210715160127501"></p>
<p>我们在开发组件时候可以想想，目前做的这个组件在那一层呢？</p>
<h3 id="设计准则"><a href="#设计准则" class="headerlink" title="设计准则"></a>设计准则</h3><p>为组件的设计制定了 8 个准则</p>
<h4 id="单一职责-SRP（避免了功能的重复）"><a href="#单一职责-SRP（避免了功能的重复）" class="headerlink" title="单一职责 SRP（避免了功能的重复）"></a>单一职责 SRP（避免了功能的重复）</h4><blockquote>
<p>当组件只有一个改变原因时，它就符合单一职责原则。</p>
</blockquote>
<p>在编写 React 组件时，首先要考虑的就是<strong>单一职责原则</strong>，它要求组件的改变有且只有一个原因。怎么理解呢？也就是说，在开发业务组件时，要清晰知道，这个功能是干嘛的，譬如搜索功能和编辑功能，虽然他们都是由 button 这个基础组件衍变的业务组件，但是不能将这两个功能写在一个组件中，而要拆分成两个业务组件。</p>
<p>举个例子</p>
<ul>
<li>搜索按钮<ul>
<li>它的触发原则是，输入框内容的改变</li>
<li>内容的改变，导致了向服务器发送 url</li>
<li>获取到了数据</li>
</ul>
</li>
</ul>
<p>单一职责原则不仅仅用在组件的设计上，也可以用在功能的设计上，譬如，获取天气预报这个功能。</p>
<p>天气预报的需要从后端获取数据，然后再展示在页面上，我们就可以把它拆分成获取数据 + 数据展示，而不要把这两个功能写在一个组件中，将多个功能放在一起的，称之为<strong>组合</strong>，这是 React 的另一个核心功能。</p>
<h4 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h4><blockquote>
<p>组件是将多个组件联合在一起，创建出功能更强大组件的一种方式，它就是上述区块的概念。</p>
</blockquote>
<p>组合的目的是实现组件间数据的通讯，它是在一个组件中，实现了多个功能的整合，这时候有小伙伴说了，它不是违背了单一职责原则么？确实如此。</p>
<p>单一职责描述的是如何将需求拆分成一个一个独立的功能，组件描述的是如何将这些功能整合在一起，就像一辆汽车，单一职责描述的是轮胎是负责接触地面的，发动机是负责驱动的，方向盘是负责转向的，而组合就是将这些东西拼凑在一起，构成了汽车。</p>
<p>组合有可复用的特点</p>
<p>譬如说，天猫的搜索功能，它的业务逻辑，搜索接口都是一样的，搜索按钮和输入框<strong>组合</strong>成了一个区块，但是在多个页面会用到，这就是可复用性。</p>
<p><img src="/2019/12/05/frontEnd/%E5%88%AB%E5%86%8D%E9%97%AE%E6%88%91React%E7%BB%84%E4%BB%B6%E6%80%8E%E4%B9%88%E5%86%99%E4%BA%86/image-20210715172151551.png" alt="image-20210715172151551"></p>
<h4 id="复用"><a href="#复用" class="headerlink" title="复用"></a>复用</h4><blockquote>
<p>可重复的组件，一次编写，多次使用。</p>
</blockquote>
<p>不要把组合和复用混为一谈，他们的应用场景不一样，组合虽然具有可复用的特性，但是具备可复用特性的并不都是组合，基础组件，业务组件都可以复用，但是他们并不是组合而成的。因此<strong>组合的一定可复用，可复用的不一样是组合</strong>。</p>
<p><img src="/2019/12/05/frontEnd/%E5%88%AB%E5%86%8D%E9%97%AE%E6%88%91React%E7%BB%84%E4%BB%B6%E6%80%8E%E4%B9%88%E5%86%99%E4%BA%86/image-20210715173440613.png" alt="image-20210715173440613"></p>
<h5 id="项目中的复用"><a href="#项目中的复用" class="headerlink" title="项目中的复用"></a>项目中的复用</h5><blockquote>
<p>复用并不是毫无成本的，只有一个组件符合单一原则并且具有合理封装时，它才是可复用的</p>
</blockquote>
<p>因此，复用一个组件实际上意味着复用其职责。只有单一职责的组件或者功能才是最容易复用的。</p>
<p>所以，基础组件和业务组件的复用性最高。</p>
<h5 id="复用第三方库"><a href="#复用第三方库" class="headerlink" title="复用第三方库"></a>复用第三方库</h5><p>像 react-router，redux，这些就是非常优秀的第三方库，开箱即用。</p>
<h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><blockquote>
<p>封装组件提供 props 控制其行为而不是暴露其内部结构。</p>
</blockquote>
<p>耦合是决定组件之间依赖程度的特性，根据组件之间的依赖程度，可分成松耦合和紧耦合。</p>
<ul>
<li>当组件 A 对组件 B 影响不大时，就发生松耦合</li>
<li>当组件 A 对组件 B 相互之间都有影响，且高度依赖时，就发生紧耦合</li>
</ul>
<p>松耦合是我们设计应用结构和组件之间关系的目标。</p>
<p><strong>松耦合</strong>会带来以下好处：</p>
<ul>
<li>可以在不影响应用其它部分的情况下对某一块进行修改。、</li>
<li>任何组件都可以替换为另一种实现</li>
<li>在整个应用程序中实现组件复用，从而避免重复代码</li>
<li>独立组件更容易测试，增加了测试覆盖率</li>
</ul>
<p>相反，紧耦合的系统会失去上面描述的好处。主要缺点是很难修改高度依赖于其他组件的组件。即使是一处修改，也可能导致一系列的依赖组件需要修改。</p>
<p>松耦合的实现方式 —— 封装</p>
<p>那么该如何封装组件呢？</p>
<p>这里提出了<strong>高内聚，低耦合</strong>的设计思想</p>
<ul>
<li>高内聚：指<strong>将逻辑紧密相关的内容放在一个组件内</strong></li>
<li>低耦合：指不同组件之间的依赖关系要尽量弱化，也就是每个组件要尽量独立，一个组件不应该掌握着其他组件的细节，而是要尽量做到对其他组件了解很少，甚至是一无所知。A 组件里的功能绝对不能写在 B 组件里</li>
</ul>
<p>封装一个组件可以从两个维度去思考</p>
<ul>
<li><p>隐藏内部细节</p>
<p><strong>这是反面教材</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const Child = (props) =&gt; &#123;</span><br><span class="line">	const updateNumber = (val) =&gt; &#123;props.parents(val)&#125;</span><br><span class="line">	return (</span><br><span class="line">		&lt;button onClick=&#123;</span><br><span class="line">			() =&gt; updateNumber(+1)</span><br><span class="line">		&#125;&gt;</span><br><span class="line">    	Increase</span><br><span class="line">    &lt;/button&gt;</span><br><span class="line">	)</span><br><span class="line">&#125;</span><br><span class="line">const App = () =&gt; &#123;</span><br><span class="line">	const [state, setState] = useState()</span><br><span class="line">	return (</span><br><span class="line">		&lt;&gt;</span><br><span class="line">			&lt;div&gt;&#123;state&#125;&lt;/div&gt;</span><br><span class="line">			&lt;Child parants=&#123;setState&#125;/&gt;</span><br><span class="line">		&lt;/&gt;</span><br><span class="line">	)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样设计就非常不合理，App 中的 state 更新方法放在了 Child 组件中，从一个角度看，Child 可以通过这个方法修改任意的值，这样会对 App 组件造成严重的破坏，另一个角度而已，他们的耦合性高，复用性差。</p>
<p><strong>修复</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const Child = (props) =&gt; &#123;</span><br><span class="line">	return (</span><br><span class="line">		&lt;button onClick=&#123;() =&gt; props.parants(1)&#125;&gt;</span><br><span class="line">    	Increase</span><br><span class="line">    &lt;/button&gt;</span><br><span class="line">	)</span><br><span class="line">&#125;</span><br><span class="line">const App = () =&gt; &#123;</span><br><span class="line">	const [state, setState] = useState()</span><br><span class="line">	return (</span><br><span class="line">		&lt;&gt;</span><br><span class="line">			&lt;div&gt;&#123;state&#125;&lt;/div&gt;</span><br><span class="line">			&lt;Child parants=&#123;(val) =&gt; setState(val)&#125;/&gt;</span><br><span class="line">		&lt;/&gt;</span><br><span class="line">	)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改后，Child 组件只对外暴露值</p>
<p>因此我们可以得出一个结论，<strong>要提升组件复用性，组件间通讯，尽量传基本数据类型</strong>。</p>
</li>
<li><p>状态管理，正确使用 state 和 props</p>
<ul>
<li><p>state 是用于维护当前组件的状态</p>
<p>在 React 更新机制中，state 每次改变都会触发重渲染(re-render)，带来不必要的性能损耗，同时 state 中管理太多状态也会造成状态冗余。所以我们应尽量维持组件 stateless 化。在将状态塞进 state 之前都先思考一件事，这个状态真的适合放进 state 吗？“</p>
<p>那些状态适合用 state 管理呢？—— <strong>可能会改变 UI 的 flag</strong>。例如一个绑定了 UI 动效的 <code>className</code>，或者一个 JS 动画的判断条件 <code>isButtonDisabled</code>。适合放进 state 的状态通常只会有三种数据类型 <code>Number</code>、<code>String</code> 以及最常出现的 <code>Boolean</code>。  </p>
<ul>
<li>这是一个弹窗组件，此时，该组件的显隐（show）就适合用 state 去管理，因为显隐状态是自己维护的。</li>
<li>表单内容的变化，如果每次变化都要通过 props 通知父组件，又触发一系列的 re-render，这样做很影响性能，因此放在 state 中，当 submit 时再告知父组件，这才是明智之举。</li>
</ul>
</li>
<li><p>props 是外部组件的状态</p>
<p>props 更多是定义默认值，它主要是丰富当前 state，props 的数据是不可变数据，因此多用 props，可以提升组件的复用性，降低耦合度</p>
</li>
</ul>
</li>
<li><p>通讯</p>
<p>组件开发过程中，尽量保持组件状态的纯净性，始终使用不可变数据的思想进行状态变更，避免在组件逻辑中直接对原数据使用 <code>pop</code>，<code>push</code>，<code>slice</code>，<code>reverse</code> 等会改变原数据的方法，这样会造成数据传递中产生难以观测的改变，后续不便于追踪和管理组件更新。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// good</span><br><span class="line">const data = [...this.props.data]</span><br><span class="line">const new = data.pop()</span><br><span class="line">// not good</span><br><span class="line">const new = this.props.data.pop()</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h4><blockquote>
<p>我的理解是分开各自管理</p>
</blockquote>
<p>上面，我们提出了区块的概念，区块由多个业务组件的组合，在区块中，我们可以处理<strong>事件、状态、请求</strong>，业务组件少，还无所谓，试想一下，如果有100个业务组件，都放在一个区块中，这个区块的承载也太重了，随着业务组件的增加会降低维护性和复用性。</p>
<p>打个比方，现在有两个不同业务模型的组件，ComA 和 ComB，它们的呈现方式都是渲染列表，只不过两者的业务逻辑不同罢了，通常组合的方式为直接在业务组件中处理好逻辑再往下传递，负责展示的列表组件只负责展示，没有任何逻辑处理。思路是对的，不过，当业务组件非常多时，每个业务模型都有自己的业务逻辑，全部放在业务组件中处理，就会造成信息冗余。</p>
<p>解决这个问题的方法就是将区块中的业务组件包裹一层组件，而这个组件就叫做<strong>容器组件</strong></p>
<p>容器组件只负责当前组件的业务逻辑的处理和数据的获取，不负责 UI 的渲染，UI 的渲染和部分业务逻辑交给原本的业务组件。</p>
<p><img src="/2019/12/05/frontEnd/%E5%88%AB%E5%86%8D%E9%97%AE%E6%88%91React%E7%BB%84%E4%BB%B6%E6%80%8E%E4%B9%88%E5%86%99%E4%BA%86/image-20210715203120668.png" alt="image-20210715203120668"></p>
<p>以后其中一个业务规则有变动时，也可以灵活变动相应的列表组件，而无需拓展公用组件，也无需在父组件中寻找列表处理的逻辑在哪儿。</p>
<p>最常用的就是 react-redux 中的 connect</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// ListComponent</span><br><span class="line">const ListComponent = () = &gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line">// ListContainer</span><br><span class="line">import React, &#123; useEffect &#125; from &#x27;react&#x27;</span><br><span class="line">import &#123; connect &#125; from &#x27;react-redux&#x27;</span><br><span class="line"></span><br><span class="line">const ListContainer = (&#123;list, getLists&#125;) =&gt; &#123;</span><br><span class="line">	// 处理业务逻辑 </span><br><span class="line">	useEffect(() =&gt; &#123;</span><br><span class="line">		getLists()</span><br><span class="line">	&#125;, [])</span><br><span class="line">	return (</span><br><span class="line">		&lt;ListComponent data=&#123;list&#125;/&gt;</span><br><span class="line">	)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const mapState = state =&gt; (&#123;</span><br><span class="line">  list: state.getIn([&#x27;lists&#x27;]),</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const mapDispatch = &#123;</span><br><span class="line">  getLists,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default connect(mapState, mapDispatch)(ListContainer)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import List from &#x27;./ListContainer&#x27;const App = () =&gt; &#123;	return (		&lt;List /&gt;	)&#125;</span><br></pre></td></tr></table></figure>



<h4 id="组件的粒度如何控制"><a href="#组件的粒度如何控制" class="headerlink" title="组件的粒度如何控制"></a>组件的粒度如何控制</h4><p>业务代码中组件抽取的粒度一直是一个比较纠结的问题，粒度太粗项目中可能会存在太多的重复代码，粒度太细会影响后续可扩展性，大部分情况下只能根据实际业务情况进行评估。但是这其中还是有一些经验可以参考：</p>
<ul>
<li>组件树的组合不宜过深，通常控制在 3 至 5 层之间比较理想，过深的组件层级容易造成组件通讯的负担。</li>
<li>有几种东西一般可以被提取为可复用的组件：基础控件、公共样式，以及拥有稳定业务逻辑的组件。</li>
</ul>
<h4 id="纯组件"><a href="#纯组件" class="headerlink" title="纯组件"></a>纯组件</h4><blockquote>
<p>理解纯函数，就很好理解纯组件了，纯组件是指那些有相同输入，必定有相同输出的<strong>组件</strong></p>
</blockquote>
<h5 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h5><p>在理解纯组件前，我们先了解下纯函数</p>
<blockquote>
<p>在函数编程中，对于给定相同的输入，纯函数总是返回相同的输出，而且不会对外界产生副作用。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function add(a, b) &#123;	return a + b&#125;add(1, 2) // 3</span><br></pre></td></tr></table></figure>

<p>这个函数，只要给定了两个数字，函数总会返回相同的结果.</p>
<p>下面我们修改下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let isTrue = falsefunction add(a, b) &#123;	if (isTrue) &#123;		return null	&#125;	isTrue = true	return a + b &#125;add(1, 2) // 3add(1, 2) // null</span><br></pre></td></tr></table></figure>

<p>上面的就不是纯函数了，因为第一次执行该函数时，修改了 isTrue 全局变量的状态，这就对外产生了副作用，从而对第二次的值产生了影响。</p>
<p>纯函数是没有副作用且不依赖全局状态，只要相同的输入，就一定会有相同的输出，因此纯函数的结果是可预测的，确定的，可以复用的，且易于测试。</p>
<p>纯函数带来的最大好处就是<strong>复用性</strong>和<strong>维护性</strong>。</p>
<p>React 提供的是一套 javascript 组件库，在组件设计上应该更多的思考<strong>复用性</strong>，因此可以将纯函数的思想引入组件设计中，就形成了纯组件。</p>
<p>React 对外只有一个数据来源 props，当 props 相同，渲染出来的组件也相同时，我们称为纯组件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Message(&#123; text &#125;) &#123;    return &lt;div className=&quot;message&quot;&gt;&#123;text&#125;&lt;/div&gt;;&#125;&lt;Message text=&quot;Hello World!&quot; /&gt;// =&gt; &lt;div class=&quot;message&quot;&gt;Hello World&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>纯组件是我们追求的目标，但现实会告诉你，要确保所有的组件是纯组件是不可能的，当你设计一个 <code>Input</code> 组件时，必须会对外产生交互，它会根据用户输入值进行渲染。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const InputField = () =&gt; &#123;	const [value, setValue] = useState(&#x27;&#x27;)	const handleChange = (&#123;target: &#123; v &#125;&#125;) =&gt; &#123;		setValue(v)	&#125;	return (		&lt;div&gt;			&lt;span&gt;				You input: &#123;value&#125;			&lt;/span&gt;			&lt;input				type=&#x27;text&#x27;				value=&#123;value&#125;				onChange=&#123;handleChange&#125;			/&gt;		&lt;/div&gt;	)&#125;</span><br></pre></td></tr></table></figure>

<p>在开发过程中，你会遇到非常多的非纯组件，例如<strong>网络请求，使用全局状态，本地存储等</strong>，所以在开发过程中，你需要区分纯组件和非纯组件，并对组件进行<strong>提纯</strong>。</p>
<p><img src="/2019/12/05/frontEnd/%E5%88%AB%E5%86%8D%E9%97%AE%E6%88%91React%E7%BB%84%E4%BB%B6%E6%80%8E%E4%B9%88%E5%86%99%E4%BA%86/image-20210718122853064.png" alt="image-20210718122853064"></p>
<p>非纯代码显式的表明了它有副作用，或者是依赖全局状态。在隔离状态下，不纯代码对系统其它部分的不可预测的影响较小。</p>
<p>在 React 中不要使用全局变量，如果需要，请放在 Redex 中。</p>
<h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><ul>
<li><p>从全局变量中提取纯组件</p>
<p>举一个被全局变量污染的例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const App = (&#123; children &#125;) =&gt; &#123;	const header = globalConfig.headName ? &lt;h1&gt;&#123;globalConfig.headName&#125;&lt;/h1&gt; : null	return (		&lt;&gt;			&#123;header&#125;			&#123;children&#125;		&lt;/&gt;	)&#125;</span><br></pre></td></tr></table></figure>

<p>它这个组件受 globalConfig 控制，耦合度高，不是纯组件</p>
<p>下面我们通过 props 进行改造</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const App = (&#123; children, headName &#125;) =&gt; &#123;	const header = headName ? &lt;h1&gt;&#123;headName&#125;&lt;/h1&gt; : null	return (		&lt;&gt;			&#123;header&#125;			&#123;children&#125;		&lt;/&gt;	)&#125;App.defaultProps = &#123;	headName: globalConfig.headName&#125;</span><br></pre></td></tr></table></figure>

<p>通过 props 该组件就变成了纯组件了，globalConfig.headName 只是默认值，App 组件复用性大大提高。</p>
</li>
<li><p>提取网页请求中的纯组件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 这里只是核心代码，其余代码自行补充const WaterFetch = () =&gt; &#123;	const [data, setData] = useState(&#123;		quality: 0,		volume: 0,	&#125;)	useEffect(() =&gt; &#123;		axios.get(&#x27;http://www.test.com/api&#x27;).then((res) =&gt; &#123;			const &#123;data: &#123; quality, volume &#125;&#125; = res.data			setData(&#123;				quality,				volume,			&#125;)		&#125;)	&#125;, [])	return (		&lt;Info quality=&#123;quality&#125; volume=&#123;volume&#125; /&gt;	)&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码，我们把网络请求放到了组件内部，很明显它不是纯组件，因为相同的输入会产生不同的输出，组件渲染依赖于服务端的返回结果，虽然请求这一步，我们是无法消除的，但是我们通过 redux 可以改变处理请求的位置。</p>
<p>redux 的方法有很多，具体就不一一赘述，这里我们只讲思路</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const WaterFetch = (&#123;waterData: &#123;quality, volume&#125;, getData&#125;) =&gt; &#123;	useEffect(() =&gt; &#123;		getData() // 异步请求，放在 redux 中	&#125;, [])	return (		&lt;Info quality=&#123;quality&#125; volume=&#123;volume&#125; /&gt;	)&#125;connect(state =&gt; &#123;	waterData: state.waterData&#125;, &#123;	getData: action.getData&#125;)(WaterFetch)</span><br></pre></td></tr></table></figure></li>
</ul>
<div style="visibility: hidden">[从生产到消费，基于物料的前端开发链路](https://developer.aliyun.com/article/772938)</div>


]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>我与异步有个约会</title>
    <url>/2019/12/05/frontEnd/%E6%88%91%E4%B8%8E%E5%BC%82%E6%AD%A5%E6%9C%89%E4%B8%AA%E7%BA%A6%E4%BC%9A/</url>
    <content><![CDATA[<p><img src="/2019/12/05/frontEnd/%E6%88%91%E4%B8%8E%E5%BC%82%E6%AD%A5%E6%9C%89%E4%B8%AA%E7%BA%A6%E4%BC%9A/image-20210905211344152.png" alt="image-20210905211344152"></p>
<span id="more"></span>

<blockquote>
<p>异步异步，只用记住两句话</p>
<ul>
<li>同一时刻执行不同的事情，等事件有结果了，把结果返回过来。</li>
<li>某个事件的异步，并不会影响函数本身的执行进度，Generator 除外。</li>
</ul>
</blockquote>
<p>由于 <code>javascript</code> 单线程的特性，异步操作是工作中绕不过的话题，目前的异步解决方案有以下几种</p>
<ul>
<li><p>callback</p>
</li>
<li><p>addEventListener</p>
</li>
<li><p>Genarator</p>
</li>
<li><p>Promise</p>
</li>
<li><p>async / await</p>
</li>
</ul>
<h3 id="callback"><a href="#callback" class="headerlink" title="callback"></a>callback</h3><p>这是最简单，最实用的异步解决方案了，在异步处理中，当你无从下手时，应该想到它，但也是最无奈的，因为会产生回调地狱。</p>
<h3 id="addEventListener"><a href="#addEventListener" class="headerlink" title="addEventListener"></a>addEventListener</h3><p>事件监听可以理解为观察者模式，某个事件触发后，才会触发里面的执行逻辑，更多用在 DOM 中，如果通过一个 Event Bus 去管理，会大大增加我们的可维护难度。</p>
<h3 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h3><p>这个叫生成器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function a() &#123;</span><br><span class="line">  return &#x27;a&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function b() &#123;</span><br><span class="line">  return &#x27;b&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function c() &#123;</span><br><span class="line">  return &#x27;c&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function* generator() &#123;</span><br><span class="line">  yield a()</span><br><span class="line">  console.log(1)</span><br><span class="line">  yield b()</span><br><span class="line"> 	console.log(2)</span><br><span class="line">  yield c()</span><br><span class="line">  console.log(3)</span><br><span class="line">  return &#x27;d&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const g = generator()</span><br><span class="line">console.log(g.next())</span><br><span class="line">console.log(g.next())</span><br><span class="line">console.log(g.next())</span><br><span class="line">console.log(g.next())</span><br><span class="line">console.log(g.next())</span><br></pre></td></tr></table></figure>



<h3 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h3><p>这个是 ES6 提出的，它有三个状态，pending(进行中)、fulfilled(已成功) 和 rejected(已失败)，和两个回调结果，resolve（成功时的回调），reject（失败时的回调）</p>
<p>状态是不可逆的，要么成功，要么失败。</p>
<p>它的核心逻辑就是当你要返回时候调用 resolve</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">new Promise((resolve) =&gt; &#123;</span><br><span class="line">	setTimeout(() =&gt; &#123;</span><br><span class="line">		resolve(&#x27;timeout&#x27;)</span><br><span class="line">	&#125;, 10000)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这段代码表明 10s 后返回 promise 的回调，然后你拿到了这个回调可以继续执行业务。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>说说你对 props 和 state 的理解</title>
    <url>/2019/12/03/frontEnd/%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9props%E5%92%8Cstate%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<p><img src="/2019/12/03/frontEnd/%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9props%E5%92%8Cstate%E7%9A%84%E7%90%86%E8%A7%A3/image-20210719174006859.png" alt="image-20210719174006859"></p>
<p><code>state</code> 和 <code>props</code> 都可以影响组件的行为和表现方式，区别在于一个对内，一个对外</p>
<span id="more"></span>

<p><code>state</code> 相当于组件内部的数据源，在组件内部初始化，通过 <code>this.setState()</code> 方法进行更新，会导致组件重新渲染，<strong>外部不能访问也不能修改</strong>。</p>
<p><code>props</code> 正好相反，它的主要作用是让使用该组件的父组件可以传入参数来配置该组件，它是外部传进来的配置参数，<strong>组件内部无法控制也无法修改</strong>。除非外部组件主动传入新的 <code>props</code>，否则组件的 <code>props</code> 永远保持不变。</p>
<p>一个组件 <code>state</code> 中的数据可以通过 <code>props</code> 传给子组件</p>
<p>一个组件可以使用外部传入的 <code>props</code> 来初始化自己的 <code>state</code>。</p>
<p>它们的职责很分明，**<code>state</code> 是让组件控制自己的状态，<code>props</code> 是让外部对组件自己进行配置**。</p>
<p>如果不明确它们的使用场景，那么记住一个简单的原则，**尽量少地用 <code>state</code>，尽量多地用 <code>props</code>**。</p>
<p>没有 <code>state</code> 的组件叫做无状态组件（stateless component），设置了 <code>state</code> 的组件叫做有状态组件（stateful component）因为状态会带来管理的复杂性，我们尽量<strong>多地写无状态组件，尽量少地写有状态的组件</strong>。这样会降低代码维护的难度，也会在一定程度上增强组件的可复用性。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>this 的 7 种使用场景</title>
    <url>/2019/06/28/frontEnd/this%E7%9A%847%E7%A7%8D%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
    <content><![CDATA[<p><img src="/2019/06/28/frontEnd/this%E7%9A%847%E7%A7%8D%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/image-20210727210100236.png" alt="image-20210727210100236"></p>
<span id="more"></span>

<p>关于this的指向问题<br>函数中this取何值，是在函数真正被调用执行的时候确定下来的，函数定义的时候确定不了。<br>this 的取值是属于执行上下文的一部分，每次调用函数，都会产生一个新的执行上下文环境。当代码中使用了 this，这个 this 的值就直接从执行的上下文中获取了，而不会从作用域链中搜寻。</p>
<p>大概可以分7种情况</p>
<ul>
<li><p>① 全局 &amp; 调用普通函数<br>在全局环境中，this 永远指向 window<br>普通函数在调用的时候，无论普通函数内嵌套多少个普通函数，this 依旧是指向 window的</p>
</li>
<li><p>② 构造函数<br>在构造函数中，this 代表的是 new 出来的对象, 也就是构造函数</p>
</li>
<li><p>③ 对象方法<br>如果函数作为对象方法时，方法中的 this 指向该对象，但是，如果在对象方法中定义函数，那情况就不同的了</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  var obj = &#123;</span><br><span class="line">    x: 10,</span><br><span class="line">    foo: function () &#123;</span><br><span class="line">        function f()&#123;</span><br><span class="line">            console.log(this);      //Window</span><br><span class="line">            console.log(this.x);    //undefined</span><br><span class="line">        &#125;</span><br><span class="line">        f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.foo();</span><br></pre></td></tr></table></figure>
<p>  可以这么理解：函数 f 虽然是在 obj.foo 内部定义的，但它仍然属于一个普通函数，this 仍指向 window。<br>  但如果函数不作为对象方法被调用时</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  var obj = &#123;</span><br><span class="line">    x: 10,</span><br><span class="line">    foo: function () &#123;</span><br><span class="line">        console.log(this);       //Window</span><br><span class="line">        console.log(this.x);     //undefined</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var fn = obj.foo;</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure>
<p>  obj.foo 被赋值给一个全局变量，并没有作为 obj 的一个属性被调用，那么此时 this 的值是 window。</p>
</li>
<li><p>④ 构造函数 prototype 属性<br>构造函数中，this 指向的是 new 出来的对象，在整个原型链中，任何一个地方调用this，依旧指的是 new 出来的对象</p>
</li>
<li><p>⑤ 函数用 call，apply 或者 bind 调用<br>当一个函数被call、apply 或者 bind 调用时，this 的值就取传入对象的值</p>
</li>
<li><p>⑥ DOM event this<br>在一个 HTML DOM 事件处理程序里，this 始终指向这个处理程序所绑定的 HTML DOM 节点</p>
</li>
<li><p>⑦ 箭头函数中的 this<br>箭头函数内部的 this 是词法作用域，由上下文确定，也就是说，箭头函数中的 this 指向的是外层的调用者。<br>call，apply，bind 方法对于箭头函数来说只是传入参数，对它的 this 毫无影响</p>
</li>
<li><p>⑧ 延迟函数setTimeout &amp; setInterval<br>非箭头函数情况下，延迟函数中的 this 是指向window的，箭头函数情况下，如果有外层包裹延迟函数，则箭头函数中 this 指向外层函数， 若没有，指向 window</p>
</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>你会用闭包吗？</title>
    <url>/2019/06/05/frontEnd/%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<p><img src="/2019/06/05/frontEnd/%E9%97%AD%E5%8C%85/image-20210719175302125.png" alt="image-20210719175302125"></p>
<p>闭包的定义</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">闭包是指那些能够访问自由变量的函数</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>什么是自由变量呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">自由变量指那些在函数中使用，但既不是函数参数，也不是函数的局部变量的变量</span><br></pre></td></tr></table></figure>

<p>所以，闭包 = 函数 + 自由变量</p>
<p>也可以这样理解</p>
<ul>
<li>作为一个函数变量的一个引用，当函数返回时，其处于激活状态</li>
<li>一个闭包就是当一个函数返回时，一个没有释放资源的栈区</li>
</ul>
<p>或者说<strong>当一个函数能够记住并访问到其所在的词法及作用于链，特别强调是在其定义的作用域外进行的访问，此时该函数和其上层执行上下文共同构成闭包</strong>。</p>
<ul>
<li>闭包的硬核条件<ul>
<li>闭包一定是函数对象</li>
<li>闭包和词法作用域，作用域链，垃圾回收机制息息相关</li>
<li>当函数一定是在其定义的作用域外进行的访问时，才产生闭包，记住<strong>一定是作用域外，当前作用域都不是闭包</strong></li>
<li>闭包是由该函数和其上层执行上下文共同构成</li>
</ul>
</li>
</ul>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>test 函数可以访问 a，但是 a 既不是 test 函数的局部变量，也不是 test 函数的参数，因此 a 就是自由变量，那么，函数 test + test 函数访问的自由变量 a 就构成了一个闭包。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const a = &#x27;hello world&#x27;</span><br><span class="line">function test() &#123;</span><br><span class="line">	return a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是理论上的闭包</p>
<p>那么在 ECMAScript 中，闭包指</p>
<ul>
<li>从理论角度，所有的函数，因为它们都在创建的时候就将上层上下文的数据保存起来了，哪怕是简单的全局变量也是如此，因为函数中访问全局变量就相当于是在访问自由变量，这个时候使用最外层的作用域。</li>
<li>从实践角度，以下函数才算是闭包：<ul>
<li>即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）</li>
<li>在代码中引用了自由变量</li>
</ul>
</li>
</ul>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>优点<ul>
<li>可以读取函数内部的变量</li>
<li>可以让这些局部变量保存在内存中，实现变量数据共享</li>
</ul>
</li>
<li>缺点<ul>
<li>由于闭包会让函数中的变量都保存在内存中，因此会增加内存的开销，不能滥用闭包，否则会造成网页性能问题，在 IE 中会导致内存泄漏，解决方法是，函数退出前，将局部变量删除。</li>
<li>闭包会在父函数外部，改变父函数内部变量的值，所以如果你把父函数当作对象使用，把闭包当作它的公用方法，把内部变量当作它的私有属性，这时一定要小心，不要随便改变父函数内部变量的值。</li>
</ul>
</li>
</ul>
<h3 id="经典的闭包面试题"><a href="#经典的闭包面试题" class="headerlink" title="经典的闭包面试题"></a>经典的闭包面试题</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var data = [];</span><br><span class="line"></span><br><span class="line">for (var i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">  data[i] = function () &#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data[0](); // 3</span><br><span class="line">data[1](); // 3</span><br><span class="line">data[2](); // 3</span><br></pre></td></tr></table></figure>

<p>解析：在此处 i 会变量提升，变成全局作用域，初始值为 undefined，经过循环赋值为 3，当执行 <code>data[0]()</code> 时候，i 会沿着作用域链寻找，<code>data[0]</code> 上下午中并没有 i 值，所以向上查找，i 为 3，打印结果就为 3 了。</p>
<p>那么改成闭包后，通过匿名函数，增加函数作用域</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var data = [];</span><br><span class="line"></span><br><span class="line">for (var i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">  data[i] = (function (i) &#123;</span><br><span class="line">        return function()&#123;</span><br><span class="line">            console.log(i);</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data[0](); // 0</span><br><span class="line">data[1](); // 1</span><br><span class="line">data[2](); // 2</span><br></pre></td></tr></table></figure>

<p>此时，它会从匿名函数的参数中获取 i 的值</p>
<h3 id="如何在工作中查看闭包身影呢？"><a href="#如何在工作中查看闭包身影呢？" class="headerlink" title="如何在工作中查看闭包身影呢？"></a>如何在工作中查看闭包身影呢？</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function a() &#123;</span><br><span class="line">	const test = &#x27;test&#x27;</span><br><span class="line">  function b() &#123;</span><br><span class="line">  	return test</span><br><span class="line">  &#125;</span><br><span class="line">	return b</span><br><span class="line">&#125;</span><br><span class="line">const bFunc = a()</span><br><span class="line">bFunc()</span><br></pre></td></tr></table></figure>

<p><img src="/2019/06/05/frontEnd/%E9%97%AD%E5%8C%85/image-20210719194131646.png" alt="image-20210719194131646"></p>
<p>可以看到一开始执行栈中只有全局上下文</p>
<p><img src="/2019/06/05/frontEnd/%E9%97%AD%E5%8C%85/image-20210719194410374.png" alt="image-20210719194410374"></p>
<p>a 函数入栈，它的函数作用域中有 b 函数和 test 变量</p>
<p><img src="/2019/06/05/frontEnd/%E9%97%AD%E5%8C%85/image-20210719194529823.png" alt="image-20210719194529823"></p>
<p>a 函数执行完出栈，准备将 a 函数的返回值压到栈中，此时全局上下文为空</p>
<p><img src="/2019/06/05/frontEnd/%E9%97%AD%E5%8C%85/image-20210719194804947.png" alt="image-20210719194804947"></p>
<p>Closure 就是闭包，里面显示引用了外部作用域的 test 变量</p>
<p><img src="/2019/06/05/frontEnd/%E9%97%AD%E5%8C%85/image-20210719195246999.png" alt="image-20210719195246999"></p>
<p>如果还是不会分析，可以用 circle 把作用域图画出来，就很好看出闭包了。</p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>闭包有三大应用</p>
<ul>
<li><p>模块</p>
<p>一个模块有公有（私有）的属性和方法，而闭包的特点之一是<strong>隐藏</strong>，通过闭包，可以隐藏私有属性和方法，只暴露公有的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var myModule = (window) =&gt; &#123;</span><br><span class="line">	let name = &#x27;george&#x27;</span><br><span class="line">	function getName() &#123;</span><br><span class="line">		return name;</span><br><span class="line">	&#125;</span><br><span class="line">	return &#123;</span><br><span class="line">		name,</span><br><span class="line">		getName</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)(window)</span><br><span class="line"></span><br><span class="line">console.log( myModule.name ) // george</span><br><span class="line">console.log( myModule.getName() ); // geroge</span><br></pre></td></tr></table></figure>

<p><code>return</code> 的返回值使用到了闭包</p>
</li>
<li><p>延时器(setTimeout)、计数器(setInterval)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for( var i = 0; i &lt; 5; i++ ) &#123;</span><br><span class="line">	setTimeout(() =&gt; &#123;</span><br><span class="line">		console.log( i );</span><br><span class="line">	&#125;, 1000 * i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子，输出结果全是 4，虽然这里也用了闭包，不过 for 循环中是全局作用域，而 setTimeout 是在宏任务中执行，因此，闭包访问了全局变量 i，为 4，</p>
<p>为了达到预期，我们改造下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for( var i = 0; i &lt; 5; i++ ) &#123;</span><br><span class="line">	((j) =&gt; &#123;</span><br><span class="line">		setTimeout(() =&gt; &#123;</span><br><span class="line">			console.log( j );</span><br><span class="line">		&#125;, 1000 * j)</span><br><span class="line">	&#125;)(i)	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IIEF 形成了函数作用域，函数作用域中能够记住每次循环所在的词法作用域和作用域链。</p>
</li>
<li><p>监听器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var oDiv = document.querySeletor(&quot;#div&quot;);</span><br><span class="line">oDiv.addEventListener(&#x27;click&#x27;, function() &#123;</span><br><span class="line">	console.log(oDiv.name);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><a href="https://io-oi.me/tech/hexo-next-optimization/">https://io-oi.me/tech/hexo-next-optimization/</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>js 原型和原型链</title>
    <url>/2019/06/03/frontEnd/js%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    <content><![CDATA[<p><img src="/2019/06/03/frontEnd/js%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/image-20210719172127055.png" alt="image-20210719172127055"></p>
<span id="more"></span>

<h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><h3 id="什么是原型？"><a href="#什么是原型？" class="headerlink" title="什么是原型？"></a>什么是原型？</h3><p>每一个 JavaScript 对象( null 除外)在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型”继承”属性。</p>
<p>每个构造函数都有一个原型属性 prototype，它是一个指针，指向一个对象，该对象包含了所有属性的实例和方法，使用<strong>原型对象</strong>的好处可以让所有对象实例共享它所包含的属性和方法。</p>
<p><strong>至少我们知道了，每个构造函数有个 prototype（原型）属性指向它的原型对象</strong></p>
<!--more-->

<h3 id="什么是构造函数？"><a href="#什么是构造函数？" class="headerlink" title="什么是构造函数？"></a>什么是构造函数？</h3><p>构造函数和普通函数一样，只不过它被 new 操作符调用了，可以这样理解，被 new 操作符调用的函数就是构造函数，反之就是普通函数</p>
<h3 id="什么是原型对象？"><a href="#什么是原型对象？" class="headerlink" title="什么是原型对象？"></a>什么是原型对象？</h3><p>原型对象它包含了所有属性的实例和方法，默认只有 constructor 属性，其他属性都是从 Object 继承而来。通过 new 关键词调用构造函数可以创建一个实例，该实例拥有原型对象上的所有属性和方法。</p>
<p><strong>至少我们知道，每个原型对象都有一个 constructor （构造函数）属性指向构造函数</strong></p>
<h3 id="什么是实例对象？"><a href="#什么是实例对象？" class="headerlink" title="什么是实例对象？"></a>什么是实例对象？</h3><p>实例对象内部有个 [[Prototype]] 指针（除了 null），指向原型对象，浏览器中用 <code>__proto__</code> 属性代替。</p>
<p><strong>至少我们知道，每个实例对象中都有一个 <code>__proto__</code>属性，指向实例对象</strong></p>
<h3 id="缕一缕它们的三角恋关系"><a href="#缕一缕它们的三角恋关系" class="headerlink" title="缕一缕它们的三角恋关系"></a>缕一缕它们的三角恋关系</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">实例对象 = new 构造函数</span><br><span class="line">原型对象 = 实例对象.__proto__</span><br><span class="line">构造函数 = 原型对象.constructor</span><br><span class="line">原型对象 = 构造函数.prototype</span><br><span class="line"></span><br><span class="line">function Person() &#123;&#125;</span><br><span class="line">let person = new Person()</span><br><span class="line">console.log(person.__proto__ === Person.prototype) // true</span><br><span class="line">console.log(Person === Person.prototype.constructor) // true</span><br></pre></td></tr></table></figure>

<p><img src="/2019/06/03/frontEnd/js%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/82810452-21226380-9ec1-11ea-9523-1f4447fdbbfd.png" alt="img"></p>
<h3 id="写在构造函数中的属性和原型上的属性有什么区别"><a href="#写在构造函数中的属性和原型上的属性有什么区别" class="headerlink" title="写在构造函数中的属性和原型上的属性有什么区别"></a>写在构造函数中的属性和原型上的属性有什么区别</h3><p>写在构造函数中的属性实例化后会在实例对象中，而原型上的属性是在原型对象中，实例对象只修改删除自己的属性不会影响到其他实例上的属性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line">    this.name = &#x27;george&#x27; // 构造函数上的属性</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.age = 18 // 原型上的属性</span><br><span class="line">const person = new Person()</span><br><span class="line">const person1 = new Person()</span><br><span class="line">person.age = 16</span><br><span class="line">console.log(person.age, person1.age);</span><br></pre></td></tr></table></figure>



<h3 id="说说多个对象实例共享原型所保存的属性和方法的基本原理"><a href="#说说多个对象实例共享原型所保存的属性和方法的基本原理" class="headerlink" title="说说多个对象实例共享原型所保存的属性和方法的基本原理"></a>说说多个对象实例共享原型所保存的属性和方法的基本原理</h3><blockquote>
<p>当代码读取某个对象属性时，都会执行一次搜索，目标是给定名字的属性，搜索首先从对象实例本身开始，如果在实例中找到了具有给定名字的属性，则返回该属性的值，如果没有找到，则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性，如果在原型对象中找到了这个属性，则返回该属性的值。</p>
</blockquote>
<h3 id="什么是原型的动态性"><a href="#什么是原型的动态性" class="headerlink" title="什么是原型的动态性"></a>什么是原型的动态性</h3><blockquote>
<p>对原型对象做任何修改都可以立刻从实例上反映出来，这就是原型的动态性。</p>
</blockquote>
<h3 id="原型对象的问题"><a href="#原型对象的问题" class="headerlink" title="原型对象的问题"></a>原型对象的问题</h3><p>原型模式最大的问题就是其共享的本性导致的</p>
<h3 id="new-一个构造函数发生了什么？"><a href="#new-一个构造函数发生了什么？" class="headerlink" title="new 一个构造函数发生了什么？"></a>new 一个构造函数发生了什么？</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Foo() &#123;...&#125;;</span><br><span class="line">let f1 = new Foo();</span><br></pre></td></tr></table></figure>

<p>以上代码表示创建一个构造函数Foo()，并用new关键字实例化该构造函数得到一个实例化对象f1。虽然是简简单单的两行代码，然而它们背后的关系却是错综复杂的，如下图所示:</p>
<p><img src="/2019/06/03/frontEnd/js%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/103335317-92597300-4aaf-11eb-9f04-3dfddb950ceb.png" alt="image"></p>
<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><ul>
<li>isPrototypeOf()：用于测试一个对象是否在另一个对象的原型链上，若存在返回 true，反之返回 false</li>
<li>Object.getPrototypeOf()：用于获取一个对象的原型</li>
<li>hasOwnProperty()：用于检测一个属性在实例中还是在原型中</li>
<li>in 操作符：该操作符用于判断对象是否有这个属性，会沿着原型查找</li>
<li>Object.keys()：返回一个包含所有可枚举属性的字符串数组，不会查找原型，如果要查找原型，可以使用 for-in</li>
<li>Object.getOwnPropertyNames()</li>
</ul>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><h3 id="什么是原型链？"><a href="#什么是原型链？" class="headerlink" title="什么是原型链？"></a>什么是原型链？</h3><p>原型链的顶端是 null</p>
<p>原型链是一种机制，指的是 JS 每个对象<code>包括原型对象</code>都有一个内置的[[proto]]属性指向它的原型对象，每个原型对象也有[[proto]]属性，将它们连接在一起就是原型链</p>
<p><img src="/2019/06/03/frontEnd/js%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/103365875-15a0b600-4afc-11eb-8eb4-ef354d3c4d06.png" alt="image"></p>
<p><strong>原型链存在主要是为了实现对象的继承</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Foo() &#123;&#125;</span><br><span class="line">function Foo1() &#123;&#125;</span><br><span class="line">function Foo2() &#123;&#125;</span><br><span class="line">Foo.prototype.__proto__ = Foo1.prototype</span><br><span class="line">Foo1.prototype.__proto__ = Foo2.prototype</span><br><span class="line">const f = new Foo()</span><br><span class="line">console.log(&#x27;f&#x27;, f);</span><br><span class="line"></span><br><span class="line">f -&gt; Foo() -&gt; Foo1() -&gt; Foo2() -&gt; Object -&gt;null</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>JSX 原理</title>
    <url>/2019/06/01/frontEnd/JSX%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p><img src="/2019/06/01/frontEnd/JSX%E5%8E%9F%E7%90%86/image-20210719172849531.png" alt="image-20210719172849531"></p>
<p>首先思考一个问题，如何用 JS 对象来表现一个 DOM 元素的结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div className=&quot;content&quot; id=&quot;box&quot;&gt;</span><br><span class="line">	&lt;h1&gt;Hello World&lt;/h1&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>其实每个 DOM 都可以用 JS 对象来表示，一个 DOM 元素包含的信息只有 3 个 —— 标签名，属性，子元素</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	tag: &#x27;div&#x27;,</span><br><span class="line">	attrs: &#123; className: &#x27;content&#x27;, id: &#x27;box&#x27;&#125;,</span><br><span class="line">	children: [&#123;</span><br><span class="line">		tag: &#x27;h1&#x27;,</span><br><span class="line">		attrs: null,</span><br><span class="line">		children: [&#x27;Hello World&#x27;]</span><br><span class="line">	&#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说任何 HTML 表示的 UI 信息都可以通过 JS 对象来描述。但是在开发中，用 JS 描述太长了，结构也不是很清晰，还是用 HTML 的方式写比较方便。</p>
<p>于是 React 就把 JS 的语法扩展了一下，让 JS 语言能够支持这种直接在 JS 代码里面编写类似 HTML 标签结构的语法，这样写起来就方便多了，通过 babel 编译时，会把类似 HTML 的 JSX 结构转换成 JS 的对象结构。</p>
<p><img src="/2019/06/01/frontEnd/JSX%E5%8E%9F%E7%90%86/103338849-b2dafa80-4aba-11eb-90d2-11c58a1ce864.png" alt="image"></p>
<p>React.createElement 会构建一个 JS 对象来描述你 HTML 结构的信息，包括标签，属性，还有子元素等。所以使用 React 和 JSX 时候一定要经过 babel 编译。</p>
<p>也就是说<strong>JSX 其实就是 JS 对象</strong></p>
<p>有了表示 HTML 结构和信息的对象以后，就可以拿去构造真正的 DOM 元素，然后把这个 DOM 元素塞到页面上，这就是 ReactDOM.render 所干的事情。ReactDOM.render 功能就是把组件渲染并且构造 DOM 树，然后插入到页面上某个特定的元素上</p>
<p>总结一下从 JSX 到页面到底经过了什么样的过程：</p>
<p><img src="/2019/06/01/frontEnd/JSX%E5%8E%9F%E7%90%86/103339035-47ddf380-4abb-11eb-8e94-64225c22827f.png" alt="image"></p>
<p>为什么不直接从 JSX 直接渲染构造 DOM 呢需要经过中级这一层？</p>
<p>一、当我们拿到一个表示 UI 的结构和信息的对象以后，不一定会把元素渲染到浏览器的普通页面上，我们有可能把这个结构渲染到 canvas 上，或者是手机 App 上。所以这也是为什么会要把 <code>react-dom</code> 单独抽离出来的原因，可以想象有一个叫 <code>react-canvas</code> 可以帮我们把 UI 渲染到 canvas 上，或者是有一个叫 <code>react-app</code> 可以帮我们把它转换成原生的 App（实际上这玩意叫 <code>ReactNative</code>）。</p>
<p>二、有了这样一个对象。当数据变化，需要更新组件的时候，就可以用比较快的算法操作这个 JavaScript 对象，而不用直接操作页面上的 DOM，这样可以尽量少的减少浏览器重排，极大地优化性能。</p>
<p>所以<br>① JSX 是 JS 语言的一种语法扩展，长的像 HTML 但不是 HTML<br>② React 可以用 JSX 来描述组件长什么样。<br>③ JSX 在编译的时候会变成相应的 JS 对象描述。<br>④ react-dom 负责把这个描述 UI 信息的 js 对象变成 DOM 元素，并渲染到页面上。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>jsx</tag>
      </tags>
  </entry>
  <entry>
    <title>npm 的那些事</title>
    <url>/2019/05/06/github/npm%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
    <content><![CDATA[<p><img src="/2019/05/06/github/npm%E9%82%A3%E4%BA%9B%E4%BA%8B/image-20210720103921996.png" alt="image-20210720103921996"></p>
<span id="more"></span>

<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
<th>详细解释</th>
</tr>
</thead>
<tbody><tr>
<td>npm install moduleName</td>
<td>安装模块到项目目录下</td>
<td>1. 安装模块到项目node_modules目录下。<br>2. 不会将模块依赖写入devDependencies或dependencies 节点。<br>3. 运行 npm install 初始化项目时不会下载模块。</td>
</tr>
<tr>
<td>npm install -g moduleName</td>
<td>-g 的意思是将模块安装到全局，具体安装到磁盘哪个位置，要看 npm config prefix 的位置。</td>
<td>1. 安装模块到全局，不会在项目node_modules目录中保存模块包。<br>2. 不会将模块依赖写入devDependencies或dependencies 节点。<br>3. 运行 npm install 初始化项目时不会下载模块。</td>
</tr>
<tr>
<td>npm install –save moduleName</td>
<td>-save 的意思是将模块安装到项目目录下，并在package文件的dependencies节点写入依赖。<br>缩写 -S</td>
<td>1. 安装模块到项目node_modules目录下。<br>2. 会将模块依赖写入dependencies 节点。<br>3. 运行 npm install 初始化项目时，会将模块下载到项目目录下。<br>4. 运行npm install –production或者注明NODE_ENV变量值为production时，会自动下载模块到node_modules目录中。</td>
</tr>
<tr>
<td>npm install –save-dev moduleName</td>
<td>-save-dev 的意思是将模块安装到项目目录下，并在package文件的devDependencies节点写入依赖。<br>缩写 -D</td>
<td>1. 安装模块到项目node_modules目录下。<br>2. 会将模块依赖写入devDependencies 节点。<br>3. 运行 npm install 初始化项目时，会将模块下载到项目目录下。<br>4. 运行npm install –production或者注明NODE_ENV变量值为production时，不会自动下载模块到node_modules目录中。</td>
</tr>
<tr>
<td>npm install –save-optional moduleName</td>
<td>–save-optional 表示将安装的包写入 package.json 里面的 optionalDependencies <br>缩写 -O</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>结论:<br>devDependencies 节点下的模块是我们在开发时需要用的，比如项目中使用的 gulp ，压缩css、js的模块。这些模块在我们的项目部署后是不需要的，所以我们可以使用 -save-dev 的形式安装。像 express 这些模块是项目运行必备的，应该安装在 dependencies 节点下，所以我们应该使用 -save 的形式安装。</p>
<p>dependencies 就是少了个<strong>dev</strong>，发生产时候，它会根据里面的包进行加载引入</p>
<p>解析 package.json<br>scripts: 声明 npm 脚本指令, 在启动项目时, 通过 npm run 可调用相应的指令<br>dependencies: 项目在生产环境中的依赖包, 版本有 ^ 表示向上兼容, 例如 “3.3.5^”<br>devDependencies: 项目在开发和测试环境中的依赖包<br>engines: 声明项目需要的 node 和 npm 版本范围<br>browserslist: 浏览器版本</p>
<p>顺序执行多个命令<br>一个npm脚本可以执行多个任务，这些任务之间可以指定不同的执行顺序。</p>
<p>‘&amp;’ 并行执行顺序，同时执行<br>“dev”:”node test.js &amp; webpack”</p>
<p>‘&amp;&amp;’继发顺序，执行前面之后才可以执行后面<br>“dev”:”node test.js &amp;&amp; webpack”<br>————————————————<br>版权声明：本文为CSDN博主「胖鹅68」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/hbiao68/article/details/83614831">https://blog.csdn.net/hbiao68/article/details/83614831</a></p>
]]></content>
      <categories>
        <category>github</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title>js 类型转换</title>
    <url>/2019/04/06/frontEnd/js%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<p><img src="/2019/04/06/frontEnd/js%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/image-20210720110050093.png" alt="image-20210720110050093"></p>
<span id="more"></span>

<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><h3 id="显示转换"><a href="#显示转换" class="headerlink" title="显示转换"></a>显示转换</h3><p><strong>只有三种转换为数字，字符串，布尔类型</strong></p>
<h4 id="转换为数字"><a href="#转换为数字" class="headerlink" title="转换为数字"></a>转换为数字</h4><p>将一个值转换为数值的方式有三种：Number()、parseFloat()、parseInt()</p>
<p><strong>Number()</strong> 适用于任何数据类型</p>
<ul>
<li><p>① 如果是 Boolean 类型，true 和 false 将分别转换为 1 和 0</p>
</li>
<li><p>② 如果是数字值，只是简单的传入和返回</p>
</li>
<li><p>③ 如果是 null，返回 0</p>
</li>
<li><p>④ 如果是 undefined， 返回 NaN</p>
</li>
<li><p>⑤ 如果是字符串，遵循以下规则</p>
<ul>
<li>如果字符串中只包含数字（包括前面带正号或负号情况），则将其转换为十进制数值。</li>
<li>如果字符串中包含有效的浮点格式，则将其转换为对应的浮点数值</li>
<li>如果字符串中包含有效的十六进制格式，则将其转换为相同大小的十进制整数值</li>
<li>如果是空字符串，则将其转换为0</li>
<li>如果字符串中包含除上述格式之外的字符，则将其转换为 NaN</li>
</ul>
</li>
<li><p>⑥ 如果是对象，则调用对象的 valueOf 方法，然后依照前面的规则转换返回的值。如果转换的结果是 NaN，则调用对象的 toString() 方法，然后再次依照前面的规则转换返回的字符串值。</p>
</li>
<li><p>⑦ 如果是数组，会返回数组长度</p>
</li>
<li><p>⑧ 如果是 Symbol 则报错</p>
</li>
</ul>
<p>由于 Number() 函数在转换字符串时比较复杂而且不够合理，因此推荐 parseInt() 和 parseFloat() 来处理字符串类型</p>
<p><strong>parseInt()</strong><br>parseInt() 函数在转换字符串时，更多的时看其是否符合数值模式。该函数会忽略字符串前面的空格，直到找到第一个非空格字符串。如果第一个字符不是数字字符或者负号，则会返回NaN，也就是说如果是空字符串会返回 NaN，如果第一个字符是数字会继续解析第二个字符，直到解析完所有后续的字符或者遇到了一个非数字字符才结束。</p>
<p>parseInt() 还有第二个参数，转换时使用的基数（即多少进制），默认是 10 进制。</p>
<p>parseInt() 是向下取整的</p>
<p><strong>parseFloat()</strong><br>parseFloat() 和 parseInt() 类似，唯一的区别就是保留浮点数。而 parseInt() 会将浮点数省略。</p>
<h4 id="转换为字符串"><a href="#转换为字符串" class="headerlink" title="转换为字符串"></a>转换为字符串</h4><p>将一个值转换为字符串的方式有两种：toString()、String()</p>
<p>toString()</p>
<p>除了 null 和 undefined，几乎每个值都有该方法，该方法唯一要做的就是返回相应的字符串表现。通常情况下，toString() 方法不必传递参数，但是它可以接收一个参数，输出数值的基数，默认情况下，toString() 方法以十进制格式返回数值的字符串表示。</p>
<p>String()</p>
<p>该方法能够处理任何类型的值，包括 null 和 undefined。但要注意的是在处理对象时会默认调用 toString() 方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let obj = &#123;a:1&#125;</span><br><span class="line">console.log(String(obj)) // [object Object]</span><br><span class="line">let obj1 = &#123;b:2,toString: function() &#123;return 3&#125;&#125;</span><br><span class="line">console.log(String(obj1)) // 3</span><br></pre></td></tr></table></figure>



<h4 id="转换为布尔类型"><a href="#转换为布尔类型" class="headerlink" title="转换为布尔类型"></a>转换为布尔类型</h4><p>显示转换布尔类型的函数只有一种 Boolean()</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>true</th>
<th>false</th>
</tr>
</thead>
<tbody><tr>
<td>Boolean</td>
<td>true</td>
<td>false</td>
</tr>
<tr>
<td>String</td>
<td>任何非空字符串</td>
<td>“”(空字符串)</td>
</tr>
<tr>
<td>Number</td>
<td>任何非零数字值（包括无穷大）</td>
<td>0 和 NaN</td>
</tr>
<tr>
<td>Object</td>
<td>任何对象</td>
<td>null</td>
</tr>
<tr>
<td>Undefined</td>
<td>n/a</td>
<td>undefined</td>
</tr>
<tr>
<td>Function</td>
<td>true</td>
<td>n/a</td>
</tr>
</tbody></table>
<p>n/a ：表示不存在这种情况</p>
<h3 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h3><p>① 值类型之间的数据类型转换</p>
<ul>
<li><p>数字和字符串使用 + 运算符：会将数字先转换为字符串，然后进行字符串连接操作</p>
</li>
<li><p>布尔参与的 + 运算符：首先会将布尔值转换为对应的数字或者字符串，然后再进行相应的字符串连接或者算数运算。</p>
</li>
<li><p>Null 和 Undefined 参与的 + 运算符操作：</p>
<ul>
<li>如果和数字进行计算，null 会转化为 0，undefined 会转换为 NaN。</li>
<li>如果和字符串进行计算，首先调用 String() 方法，取得相应的字符串值再进行操作。</li>
</ul>
</li>
<li><p>减法操作： 如果一个操作数为string，boolean，null，undefined，则在后台调用 Number()，将其转换成数值，再进行操作。</p>
</li>
<li><p> == 等性运算：undefined 和 null 比较特殊，它们两个使用 == 运算符返回值是 true，其他值类型（Number，Null，Undefined）进行比较的时候都会将运算数转换为数字，NaN 和 NaN 是不相等的（这是由于浮点数的精度决定的）</p>
</li>
</ul>
<p>  虽然，JavaScript 提供了 isNaN 来检测某个值是否为 NaN，但是，这也不太精确的，因为，在调用 isNaN 函数之前，本身就存在了一个隐式转换的过程，它会把那些原本不是 NaN 的值转换成 NaN 的，如下:</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">isNaN(&quot;foo&quot;); // true </span><br><span class="line">isNaN(undefined); // true </span><br><span class="line">isNaN(&#123;&#125;); // true </span><br><span class="line">isNaN(&#123; valueOf: &quot;foo&quot; &#125;); // true</span><br></pre></td></tr></table></figure>

<p>  幸运的是,有一种可靠的并且准确的方法可以检测NaN。我们都知道,只有NaN是自己不等自己的,那么,我们就以使用不等于号 (!==) 来判断一个数是否等于自身,从而,可以检测到 NaN 了</p>
<p>  我们也可以把这种模式定义成一个函数,如下:</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function isReallyNaN(x) &#123; return x !== x; &#125; // 只适用于判断基本类型，因为对象也不等于对象 即 &#123;&#125; !== &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>② 引用类型转值类型</p>
<p>对象是可以转换成原始值的，最简单方法就是把它转换成字符串</p>
<p>对象转换成字符串是调用了它的 toString 函数，即 obj.toString()</p>
<p>类似，对象也可以转换成数字的，它是通过 valueOf 函数实现的，当然你也可以自定义 toString 和 valueOf 函数</p>
<p>如果，一个对象同时存在 valueOf 方法和 toString 方法，那么 valueOf 方法总是会被优先调用</p>
<p>注意：具有valueOf的对象，应该定义一个相应的toString方法，用来返回相等的数字的字符串形式。</p>
<p>③ 真值运算</p>
<p>比如 if，||，&amp;&amp;，如果它们的操作数不是布尔类型，JS 会通过简单的转换规则，将一些非布尔类型的值转换成布尔类型的，大多数的值都会转换成 true，<strong>只有少数的是 false，它们分别是 false，0，-0，””，NaN，null，undefined</strong>，因为存在数字和字符串以及对象的值为 false，所以，直接用真值转换来判断一个函数的参数是否传进来了，这是不太安全的。</p>
<p>检测 undefined 的更加准确的方法是用 typeof 操作</p>
<p>注意：检测一些未定义的变量时，应该使用typeOf或者undefined作比较，而不应该直接用真值运算。</p>
<h3 id="和"><a href="#和" class="headerlink" title="== 和 ==="></a>== 和 ===</h3><p><strong>=== 可以理解绝对比较，不会类型相同，值相同才相等，不多说</strong></p>
<p>下面讲解下 == 比较规则</p>
<p>== 比较规则：相同类型比较数据，不同类型才会发生类型转换<br>对于 == 来说，如果双方的类型不一样就会发生类型转换。<br>比较规则如下：</p>
<p>现在有两个值 x，y</p>
<p>先比较 x 和 y 的<strong>类型是否相同</strong>，类型相同情况下</p>
<ul>
<li>如果 x 类型 = undefined 返回 true</li>
<li>如果 x 类型 = Null 返回 true</li>
<li>如果 x 类型是 Number<ul>
<li>如果 x 是 NaN 返回 false</li>
<li>如果 y 是 NaN 返回 false</li>
<li>如果 x 和 y 具有相同的值，返回 true</li>
<li>如果 x = +0，y = -0 返回 true</li>
<li>如果 x = -0，y = +0 返回 true</li>
<li>否则返回 false</li>
</ul>
</li>
<li>如果 x 的类型为 String，且 x 和 y 是完全相同的字符序列（长度相等，字符相等），则返回 true，否则返回 false</li>
<li>如果 x 的类型为 Boolean，且 x 和 y 皆为 true 或皆为 false，则返回 true，否则返回 false</li>
<li>如果 x 和 y 引用同一个对象，则返回true，否则返回 false</li>
</ul>
<p>反之，<strong>类型不同</strong></p>
<p>如果 x 等于 null 并且 y 等于 undefined 返回 true<br>如果 x 等于 undefined 并且 y 等于 null 返回 ture<br>如果 x 的类型为 Number，y 的类型为 String，则会将 y 转换为 Number 类型后再比较<br>如果 x 的类型为 String，y 的类型为 Number，则会将 x 转换为 Number 类型后再比较<br>如果 x 的类型为 Boolean，则将 x 的类型转换为 Number 类型后再比较<br>如果 y 的类型为 Boolean，则将 y 的类型转换为 Number 类型后再比较<br>如果 x 的类型为 String 或者 Number，y 的类型为 Object，则将 y 转换成原始类型后再与 x 比较<br>如果 y 的类型为 String 或者 Number，x 的类型为 Object，则将 x 转换成原始类型后再与 y 比较<br>否则返回 false</p>
<p>上面提到了，类型是对象的基本类型比较时的情况，这里特别说明下，对象到数字的转换过程<br>首先，你要转换的对象必须有 valueOf 或 toString 方法，如果没有，则无法转换，直接返回 false，若对象具有valueOf()方法，它会调用该方法，得到一个返回值是原始类型的结果（注意，调用方法返回的结果应该是原始类型值才行，若不是，则会调用下一个方法（toString）），再将该值与另一个比较值比较，否则，会去找toString()方法，比较原理和 valueOf 一样。</p>
<ul>
<li>空数组转换为数字0<ul>
<li>原理：数组继承了默认的valueOf()方法，这个方法返回一个对象而不是一个原始值，因此，数组到数的转换则调用toString()方法。空数组转换为空字符串，空字符串转换为数字0。</li>
</ul>
</li>
</ul>
<p>一句话总结，<strong>三元运算符先“分清是非”，再决定今后该走哪条路，“==”运算符比较“喜欢”Number类型。</strong></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>js 类型判断</title>
    <url>/2019/04/04/frontEnd/js%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/</url>
    <content><![CDATA[<p><img src="/2019/04/04/frontEnd/js%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/image-20210720105616798.png" alt="image-20210720105616798"></p>
<span id="more"></span>

<h2 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h2><p>JS 有 5 种判断数据类型的方法</p>
<h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><p>typeof 的返回值有 7 种，string，number，boolean，undefined，null，object，function</p>
<p>规则如下：</p>
<ul>
<li>基本类型，除了 null 均可返回正确结果</li>
<li>引用类型，除了 function，一律返回 object 类型</li>
<li>对于 null，返回 object 类型</li>
<li>function 返回 function </li>
</ul>
<h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p>instanceof 用于处理对象类型的，它要求开发者明确地确认对象为某个特定类型，它检测的是原型。它是根据原型链去查找的。</p>
<p>它的公式关系是</p>
<p>a 是 A 的实例，即（a instanceof A），则返回 true，否则返回 false，这里要注意一下，A 是所属原型链上的构造函数，例如 A -&gt; B -&gt; C 构成一条原型链，那么 a instanceof B 等于 true，a instaceof C 也等于 true， 也就是说 instanceof 会沿着原型链去寻找。</p>
<p><strong>通常来讲，使用 instanceof 就是判断一个实例是否属于某种类型。</strong></p>
<p><strong>instanceof 只能用来判断对象类型，而不能用来判断原始类型，并且所有对象类型 instanceof Object 都是 true</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">funciton Foo() &#123;&#125;</span><br><span class="line">var foo = new Foo()</span><br><span class="line">console.log(foo instanceof Foo) // true</span><br></pre></td></tr></table></figure>

<p><strong>更重要的一点是 instanceof 可以在继承关系中用来判断一个实例是否属于它的父类型</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 判断 foo 是否是 Foo 类的实例 , 并且是否是其父类型的实例</span><br><span class="line">function Aoo()&#123;&#125; </span><br><span class="line">function Foo()&#123;&#125; </span><br><span class="line">Foo.prototype = new Aoo();//JavaScript 原型继承</span><br><span class="line">  </span><br><span class="line">var foo = new Foo(); </span><br><span class="line">console.log(foo instanceof Foo)//true </span><br><span class="line">console.log(foo instanceof Aoo)//true</span><br></pre></td></tr></table></figure>

<p>因此使用 instanceof 时要注意的一点是，如果该类型从属一个原型链上，那么通过 instanceof 来判断就不准了，<strong>因此instanceof 只能用来判断两个对象是否属于实例关系</strong>， 而不能判断一个对象实例具体属于哪种类型。</p>
<p>举个例子：<br>[], Array, Object</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[] instanceof Array; // true</span><br><span class="line">&#123;&#125; instanceof Object;// true</span><br><span class="line">new Date() instanceof Date;// true</span><br><span class="line">   </span><br><span class="line">function Person()&#123;&#125;;</span><br><span class="line">new Person() instanceof Person;</span><br><span class="line">   </span><br><span class="line">[] instanceof Object; // true</span><br><span class="line">new Date() instanceof Object;// true</span><br><span class="line">new Person instanceof Object;// true</span><br></pre></td></tr></table></figure>

<p>我们发现，虽然 instanceof 能够判断出 [] 是Array的实例，但它认为 [] 也是Object的实例，为什么呢？</p>
<p>我们来分析一下 []、Array、Object 三者之间的关系：</p>
<p>从 instanceof 能够判断出 [].<strong>proto</strong>  指向 Array.prototype，而 Array.prototype.<strong>proto</strong> 又指向了Object.prototype，最终 Object.prototype.<strong>proto</strong> 指向了null，标志着原型链的结束。因此，[]、Array、Object 就在内部形成了一条原型链</p>
<p><strong>instanceof内部原理</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// JavaScript instanceof 运算符代码</span><br><span class="line">function instance_of(L, R) &#123;//L 表示左表达式，R 表示右表达式</span><br><span class="line">  var O = R.prototype;// 取 R 的显示原型</span><br><span class="line">  L = L.__proto__;// 取 L 的隐式原型</span><br><span class="line">  while (true) &#123; </span><br><span class="line">    if (L === null) </span><br><span class="line">      return false; </span><br><span class="line">    if (O === L)// 这里重点：当 O 严格等于 L 时，返回 true </span><br><span class="line">      return true; </span><br><span class="line">    L = L.__proto__; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h3><p>我们通过一个函数 F 来说明</p>
<p>当一个函数 F 被定义时，JS 引擎会为 F 添加 prototype 原型，然后在 prototype 上添加一个 constructor 属性，并让其指向F的引用，当执行 var f = new F() 时，F 被当成了构造函数，f 是 F 的实例对象，此时 F 原型上的 constructor 传递到了 f 上，因此 f.constructor === F。因此 F 利用原型对象上的constructor 引用了自身，当 F 作为构造函数来创建对象时，原型上的 constructor 就被传递到了新创建的对象上，从原型链角度讲，构造函数 F 就是新对象的类型。这样做的意义是，让新对象在诞生以后，就具有可追溯的数据类型。</p>
<p>因此通过 constructor 可以判断实例的数据类型，它和 instanceof 的其中一个不同点在于不会沿着原型链查找</p>
<p>注意点</p>
<p>① null 和 undefined 是无效的对象，因此是不会有 constructor 存在的，这两种类型的数据需要通过其他方式来判断。<br>② 函数的 constructor 是不稳定的，这个主要体现在自定义对象上，当开发者重写 prototype 后，原有的 constructor 引用会丢失，constructor 会默认为 Object</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function F()&#123;&#125;</span><br><span class="line">F.prototype = &#123; a: &#x27;xxx&#x27; &#125;</span><br><span class="line">var f = new F()</span><br><span class="line">f.constructor == F // false</span><br><span class="line">f.constructor // Object</span><br></pre></td></tr></table></figure>

<p>prototype 被重新赋值的是一个 { }， { } 是 new Object() 的字面量，因此 new Object() 会将 Object 原型上的 constructor 传递给 { }，也就是 Object 本身。</p>
<p>因此，为了规范开发，在重写对象原型时一般都需要重新给 constructor 赋值，以保证对象实例的类型不被篡改。</p>
<h3 id="toString-精准判断对象类型"><a href="#toString-精准判断对象类型" class="headerlink" title="toString 精准判断对象类型"></a>toString 精准判断对象类型</h3><p>toString() 是 Object 的原型方法，调用该方法，默认返回当前对象的 [[Class]] 。这是一个内部属性，其格式为 [object Xxx] ，其中 Xxx 就是对象的类型。</p>
<p>对于 Object 对象，直接调用 toString()  就能返回 [object Object] 。而对于其他对象，则需要通过 call / apply 来调用才能返回正确的类型信息。</p>
<p>公式</p>
<blockquote>
<p>Object.prototype.toString.call(xxx)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;Object.prototype.toString.call(&#x27;&#x27;) // [object String]</span><br><span class="line">&gt;Object.prototype.toString.call(123) // [object Number]</span><br></pre></td></tr></table></figure>

<p><strong>toString 方法对于所有基本的数据类型都能进行判断，即使是 null 和 undefined，但是它无法获取到实例是属于那个构造函数的。</strong></p>
</blockquote>
<p>返回值有 String，Number，Symbol，Null，undefined，Undefined，Function，Object，Array</p>
<p><strong>Object.prototype.toString.call() 常用于判断浏览器内置对象。</strong></p>
<p><strong>所以说 typeof 和 toString 检测的是实例与数据类型的关系，instanceof 和 constructor 检测的是实例与构造函数之间的关系</strong></p>
<h3 id="Array-isArray"><a href="#Array-isArray" class="headerlink" title="Array.isArray"></a>Array.isArray</h3><p>该函数的作用是用来判断对象是否为数组</p>
<h4 id="instanceof-与-Array-isArray"><a href="#instanceof-与-Array-isArray" class="headerlink" title="instanceof 与 Array.isArray"></a>instanceof 与 Array.isArray</h4><p>当检测Array实例时，Array.isArray 优于 instanceof ，因为 Array.isArray 可以检测出 iframes</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var iframe = document.createElement(&#x27;iframe&#x27;);</span><br><span class="line">document.body.appendChild(iframe);</span><br><span class="line">xArray = window.frames[window.frames.length-1].Array;</span><br><span class="line">var arr = new xArray(1,2,3); // [1,2,3]</span><br><span class="line"></span><br><span class="line">// Correctly checking for Array</span><br><span class="line">Array.isArray(arr);  // true</span><br><span class="line">Object.prototype.toString.call(arr); // true</span><br><span class="line">// Considered harmful, because doesn&#x27;t work though iframes</span><br><span class="line">arr instanceof Array; // false</span><br></pre></td></tr></table></figure>

<h4 id="Array-isArray-与-Object-prototype-toString-call"><a href="#Array-isArray-与-Object-prototype-toString-call" class="headerlink" title="Array.isArray() 与 Object.prototype.toString.call()"></a>Array.isArray() 与 Object.prototype.toString.call()</h4><p>Array.isArray() 是ES5新增的方法，当不存在 Array.isArray() ，可以用 Object.prototype.toString.call() 实现。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (!Array.isArray) &#123;</span><br><span class="line">  Array.isArray = function(arg) &#123;</span><br><span class="line">    return Object.prototype.toString.call(arg) === &#x27;[object Array]&#x27;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>js 数据类型</title>
    <url>/2019/04/01/frontEnd/js%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p><img src="/2019/04/01/frontEnd/js%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20210720105048206.png" alt="image-20210720105048206"></p>
<span id="more"></span>



<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>JS 的数据类型分两大类</p>
<ul>
<li>基本数据类型 string，number，boolean，undefined，null，symbol</li>
<li>复杂数据类型（对象类型） Object</li>
</ul>
<h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>基本数据类型也就值类型，<strong>值类型里面存储的都是值，没有函数可调用</strong></p>
<p>譬如 <code>undefined.toString()</code> 会报错的，这时你会奇怪 <code>&#39;1&#39;.toString()</code> 又可以，是的，没错，但此时的 <code>&#39;1&#39;</code> 已经被强制转换为 String 对象类型了，注意哟，这是大写的 String。</p>
<p>其实你用 <code>typeof</code> 就可以看出小写和大写的区别了，小写表示值类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typeof(&#x27;1&#x27;) // string</span><br></pre></td></tr></table></figure>

<p>在基本类型中还需要注意的是 null 类型，该类型通过 <code>typeof</code> 去判断会输出 object，因为 <code>JS</code> 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，<code>000</code> 开头代表是对象，然而 <code>null</code> 表示为全零，所以将它错误的判断为 <code>object</code> 。</p>
<h3 id="对象类型"><a href="#对象类型" class="headerlink" title="对象类型"></a>对象类型</h3><p>复杂数据类型叫引用类型，常见的有对象，数组和函数，它存储的是地址（指针）。当你创建一个对象类型的时候，计算机会在内存中开辟一个空间来存放值。</p>
<p>对于基本数据类型而言，由于值在内存中占据固定大小的空间，因此保存在栈内存中，而对象类型在栈内存中存储的只是该值的地址的指针，值存储于堆内存中。</p>
<blockquote>
<p>栈（stack）和堆（heap）的知识<br>系统会划分出两张不同的内存空间，栈（stack）和堆（heap），Stack 是一种存放数据的内存区域<br>stack（栈）是有结构的（后进先出，从下到上）每个区域都按照一定次序存放，可以明确每个区块的大小。heap 没有结构，数据可以任意存放，因此 stack 的寻址速度要快于 heap。<br>一般来说，每个线程分配一个stack（栈）每个进程分配一个heap（堆）。就是说 stack 独占线程，heap 是共享线程。<br><br>所以，数据存放的规则是，只要是局部的，占用空间确定的数据，一般都存放在stack里面。否则就放在heap里面。局部变量一旦运行结束，就会 GC 回收，而heap的那个对象实例直到系统的GC将这里的内存回收，因此一般内存泄漏都发生在 heap 。</p>
</blockquote>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 文章加入置顶功能</title>
    <url>/2019/03/15/hexo/HexoNext%E6%96%87%E7%AB%A0%E5%8A%A0%E5%85%A5%E7%BD%AE%E9%A1%B6%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<p><img src="/2019/03/15/hexo/HexoNext%E6%96%87%E7%AB%A0%E5%8A%A0%E5%85%A5%E7%BD%AE%E9%A1%B6%E5%8A%9F%E8%83%BD/image-20210720113007594.png" alt="image-20210720113007594"></p>
<span id="more"></span>

<h4 id="加入置顶功能"><a href="#加入置顶功能" class="headerlink" title="加入置顶功能"></a>加入置顶功能</h4><p>这里的例子用的是 next 主题，其他主题自行尝试，感觉思路差不多</p>
<ol>
<li><p>首先我们要用的一个包</p>
<p>在根目录（<code>不是主题目录</code>哟）执行，安装 <code>hexo-generator-index-pin-top</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-generator-index-pin-top --save</span><br></pre></td></tr></table></figure></li>
<li><p>然后在需要置顶的文章 <code>Front-matter</code> 上加入 <code>top: true</code> 即可</p>
<p><img src="/2019/03/15/hexo/HexoNext%E6%96%87%E7%AB%A0%E5%8A%A0%E5%85%A5%E7%BD%AE%E9%A1%B6%E5%8A%9F%E8%83%BD/image-20210720113335538.png" alt="image-20210720113335538"> </p>
<p>这样置顶功能就完成了，不过，交互性不是很高，在页面上也没显示<code>置顶</code>两个字</p>
</li>
</ol>
<h4 id="设置置顶标志"><a href="#设置置顶标志" class="headerlink" title="设置置顶标志"></a>设置置顶标志</h4><p>我们需要修改下配置文件，我这里的 next 是 8.6 版本</p>
<p>进入<code>/themes/next/layout/_partials/post/post-meta.njk</code>，在 <code>post-meta</code> 中插入以下代码，不同版本路径可能不太一样，不过大同小异</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% if post.top %&#125;</span><br><span class="line">  &lt;i class=&quot;fa fa-thumb-tack&quot;&gt;&lt;/i&gt;</span><br><span class="line">  &lt;font color=7D26CD&gt;置顶&lt;/font&gt;</span><br><span class="line">  &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>



<p><img src="/2019/03/15/hexo/HexoNext%E6%96%87%E7%AB%A0%E5%8A%A0%E5%85%A5%E7%BD%AE%E9%A1%B6%E5%8A%9F%E8%83%BD/image-20210720113728181.png" alt="image-20210720113728181"></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>一招解决 Hexo 中 markdown 图片无法显示问题</title>
    <url>/2019/03/15/hexo/%E4%B8%80%E6%8B%9B%E8%A7%A3%E5%86%B3Hexo%E4%B8%ADmarkdown%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p><img src="/2019/03/15/hexo/%E4%B8%80%E6%8B%9B%E8%A7%A3%E5%86%B3Hexo%E4%B8%ADmarkdown%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/image-20210719161926497.png" alt="image-20210719161926497"></p>
<p>hexo 在编译过程中, 会造成图片路径无法找到, 此时我们需要通过插件解决这个问题</p>
<span id="more"></span>

<h4 id="问题本质"><a href="#问题本质" class="headerlink" title="问题本质"></a>问题本质</h4><p>hexo 默认无法自动处理文章插入本地图片，需要通过扩展插件支持。</p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ul>
<li><p>在 <code>hexo</code> 根目录 <code>_config.yml</code> 配置中将 <code>post_asset_folder:false</code> 选项设置成 true<br>  <img src="/2019/03/15/hexo/%E4%B8%80%E6%8B%9B%E8%A7%A3%E5%86%B3Hexo%E4%B8%ADmarkdown%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/image-20210713001409082.png" alt="image-20210713001409082"></p>
<p>这个选项设置成 true 意思是打包时候，会生成静态目录文件夹</p>
<p>  我们在执行</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new xxx</span><br></pre></td></tr></table></figure>
<p>  时候也会在 _post 目录下生成和文件同名的文件夹，这个文件夹里面可以存放图片</p>
<p>  <img src="/2019/03/15/hexo/%E4%B8%80%E6%8B%9B%E8%A7%A3%E5%86%B3Hexo%E4%B8%ADmarkdown%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/image-20210713002106528.png" alt="image-20210713002106528"></p>
</li>
<li><p>在 <code>hexo</code> 根目录下执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install https://github.com/CodeFalling/hexo-asset-image --save</span><br></pre></td></tr></table></figure>

<p>建议用 cmpn</p>
<p>这个包可以修改图片引用路径，如果没用这个包打包时候，会根据时间日期生成目录</p>
</li>
<li><p>我们在编写 md 文件时候，推荐使用 Typora 工具，该工具有个功能，在复制图片时候，可以自动生成一个图片文件夹，这里我们设置为当前文件名</p>
<p><img src="/2019/03/15/hexo/%E4%B8%80%E6%8B%9B%E8%A7%A3%E5%86%B3Hexo%E4%B8%ADmarkdown%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/image-20210713002250944.png" alt="image-20210713002250944"></p>
</li>
</ul>
<p>大功告成，此后可以愉快的插入图片了</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>git 常规用命令</title>
    <url>/2019/03/01/github/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p><img src="/2019/03/01/github/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20210720102435422.png" alt="image-20210720102435422"></p>
<span id="more"></span>

<table>
<thead>
<tr>
<th>command</th>
<th>describe</th>
<th>other</th>
</tr>
</thead>
<tbody><tr>
<td>git init</td>
<td>git 初始化</td>
<td></td>
</tr>
<tr>
<td>git remote add origin 地址</td>
<td>设置远端地址</td>
<td></td>
</tr>
<tr>
<td>git push -u origin master</td>
<td>提交新分支并与远端分支关联，这样每次push都不会出现关联提示</td>
<td></td>
</tr>
<tr>
<td>git reset –hard commit_id</td>
<td>回退到指定commit_id中</td>
<td></td>
</tr>
<tr>
<td>git reset –hard</td>
<td>撤销当前 add 提交并将文件内容回滚到 add 之前</td>
<td></td>
</tr>
<tr>
<td>git reset –hard~1</td>
<td>回滚到当前 hard 的前一个 hard commit</td>
<td></td>
</tr>
<tr>
<td>git commit -m “xxx”</td>
<td>提交commit</td>
<td></td>
</tr>
<tr>
<td>git pull</td>
<td>获取当前分支的远端分支版本与本地分支合并</td>
<td></td>
</tr>
<tr>
<td>git pull origin master</td>
<td>获取远端指定分支(master)中的内容与本地分支合并</td>
<td>git pull = git fetch + git merge</td>
</tr>
<tr>
<td>git fetch</td>
<td>从远程获取最新版本到本地, 不会自动merge</td>
<td></td>
</tr>
<tr>
<td>git reset HEAD .</td>
<td>撤销本地所有add 提交</td>
<td></td>
</tr>
<tr>
<td>git stash</td>
<td>存入缓存区</td>
<td></td>
</tr>
<tr>
<td>git stash pop</td>
<td>从缓存区恢复</td>
<td></td>
</tr>
<tr>
<td>git stash list</td>
<td>查看缓存区列表</td>
<td></td>
</tr>
<tr>
<td>git stash drop 缓存号</td>
<td>移除缓存区列表中某个缓存</td>
<td></td>
</tr>
<tr>
<td>git stash clear</td>
<td>清除缓存区</td>
<td></td>
</tr>
<tr>
<td>git config -list</td>
<td>查看当前全部配置</td>
<td></td>
</tr>
<tr>
<td>git config –global user.name “xxx”</td>
<td>设置全局用户名</td>
<td></td>
</tr>
<tr>
<td>git config –global user.email “xxx”</td>
<td>设置全局邮箱</td>
<td></td>
</tr>
<tr>
<td>git config user.name “xxx”</td>
<td>设置仓库级的用户名</td>
<td></td>
</tr>
<tr>
<td>git config user.email “xxx”</td>
<td>设置仓库级的邮箱</td>
<td></td>
</tr>
<tr>
<td>git checkout -b XXX origin/XXX</td>
<td>从远端拉取新分支到本地</td>
<td></td>
</tr>
<tr>
<td>git show 历史记录中的hash码</td>
<td>从历史记录中查看修改</td>
<td></td>
</tr>
<tr>
<td>git clone 路径</td>
<td>从github上下载代码</td>
<td></td>
</tr>
<tr>
<td>git remote -v</td>
<td>查看远程仓库</td>
<td></td>
</tr>
<tr>
<td>git branch -a</td>
<td>查看所有分支</td>
<td></td>
</tr>
<tr>
<td>git merge 分支名</td>
<td>合并分支</td>
<td></td>
</tr>
<tr>
<td>git fetch –all</td>
<td>下载远程仓库最新内容，不做合并</td>
<td></td>
</tr>
<tr>
<td>git reset –hard origin/master</td>
<td>把HEAD指向master最新版本也就是强制覆盖</td>
<td></td>
</tr>
<tr>
<td>git log –oneline –graph –decorate –all</td>
<td>用 git 代替 gitk 查看节点树</td>
<td></td>
</tr>
<tr>
<td>git reflog</td>
<td>展示出所有你之前的 git 操作，你以前所有的操作都被git记录了下来</td>
<td></td>
</tr>
<tr>
<td>git cherry-pick commit_id</td>
<td>拣选 —— 拣选会提取某次提交的补丁，之后尝试将其重新应用到当前分支上。这种方式在你只想引入特性分支中的某个提交时很有用</td>
<td></td>
</tr>
<tr>
<td>git commit –no-verify -m “xxx”</td>
<td>当你在终端输入git commit -m”XXX”,提交代码的时候，pre-commit(客户端)钩子，它会在Git键入提交信息前运行做代码风格检查，如果代码不符合相应规则，则报错。而这行命令可以绕过 pre-commit 检查钩子，实现代码提交。</td>
<td></td>
</tr>
<tr>
<td>history</td>
<td>查看历史输入命令</td>
<td></td>
</tr>
<tr>
<td>git push origin –delete xxx</td>
<td>删除远端 xxx 分支</td>
<td></td>
</tr>
<tr>
<td>git branch -D xxx</td>
<td>强制删除本地分支</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>github</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>git 必修课</title>
    <url>/2019/03/01/github/git%E5%BF%85%E4%BF%AE%E8%AF%BE/</url>
    <content><![CDATA[<p><img src="/2019/03/01/github/git%E5%BF%85%E4%BF%AE%E8%AF%BE/image-20210916223318337.png" alt="image-20210916223318337"></p>
<p><code>git</code> 是目前世界上最流行的分支管理工具之一，所以弄清楚 <code>git</code> 的操作和原理能让我们的开发之路如虎添翼</p>
<span id="more"></span>

<p>下面会根据几个维度去梳理 <code>git</code></p>
<ul>
<li>基本信息</li>
<li>操作</li>
</ul>
<h2 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>网上很多，这里就不一一叙述了</p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p><code>git</code> 的配置分两种，当前项目和所有项目，<code>.git</code> 文件夹下的就是当前项目的 <code>git</code> 配置，它包括了这个项目有关 <code>git</code> 的所有信息，要有这个文件夹才能够使用 <code>git</code> 命令。</p>
<p>其中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --local // 设置本地</span><br><span class="line">git config --global // 设置全局</span><br></pre></td></tr></table></figure>



<h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><p><code>git</code> 的所有操作都说围绕着 <code>4</code>  种状态去进行的，分别是 <code>未记录（untrack）</code>，<code>暂存（staged）</code>，<code>已修改（modified）</code>，<code>已提交（committed）</code></p>
<p> 通过 <code>git status</code> 命令可以查询 <code>git</code> 的状态</p>
<p>这是<strong>未记录</strong>，在该状态下，你的内容丢失了就找不回来的</p>
<p><img src="/2019/03/01/github/git%E5%BF%85%E4%BF%AE%E8%AF%BE/image-20210812222150173.png" alt="image-20210812222150173"></p>
<p>通过 <code>git add .</code> 可以将<strong>未记录</strong>状态转换为<strong>暂存</strong>状态</p>
<p><img src="/2019/03/01/github/git%E5%BF%85%E4%BF%AE%E8%AF%BE/image-20210812222447867.png" alt="image-20210812222447867"></p>
<p>在<strong>暂存</strong>状态下，修改了文件就会变成<strong>已修改</strong>状态，此刻如果增加了文件，就会变成<strong>未记录</strong>状态</p>
<p><img src="/2019/03/01/github/git%E5%BF%85%E4%BF%AE%E8%AF%BE/image-20210812222625676.png" alt="image-20210812222625676"></p>
<p>通过 <code>git commit -m &#39;xxx&#39;</code> 可以将<strong>暂存</strong>状态变成<strong>已提交</strong>状态  </p>
<p><img src="/2019/03/01/github/git%E5%BF%85%E4%BF%AE%E8%AF%BE/image-20210812225226664.png" alt="image-20210812225226664"></p>
<h3 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h3><p>git 有三个区块，分别是 <code>工作区</code>，<code>暂存区</code>，<code>存储区</code></p>
<ul>
<li>工作区，指编写代码的区域，对应的就是上面的未记录状态，这个区块的特定，代码一旦丢失了，就再也找不回来了</li>
<li>暂存区（缓冲区），指编写的代码被记录，就算撤销了，依旧可以找回来。如果是修改后覆盖了，就无法找回了</li>
<li>存储区，指编写的代码被永久存储起来，就算被覆盖后，也可以找回历史记录</li>
</ul>
<p>工作区 -&gt; 暂存区    git add.</p>
<p>暂存区 -&gt; 存储区    git commit</p>
<h4 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h4><p>工作区，持有你的实际文件，缓冲区，它像个缓存区域，临时保存你的改动，最后一个是 HEAD（存储区），指向你最近一次提交后的结果。</p>
<p><img src="/2019/03/01/github/git%E5%BF%85%E4%BF%AE%E8%AF%BE/image-20210914190910015.png" alt="image-20210914190910015"></p>
<h3 id="忽略文件（指定不需要-git-管理的文件）"><a href="#忽略文件（指定不需要-git-管理的文件）" class="headerlink" title="忽略文件（指定不需要 git 管理的文件）"></a>忽略文件（指定不需要 git 管理的文件）</h3><p>在项目根目录中，添加 <code>.gitignore</code> 文件，该文件将不会被 <code>git</code> 记录，跟踪，一般来说，我们会设置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node_modules/</span><br><span class="line">public/</span><br><span class="line">*.log</span><br></pre></td></tr></table></figure>

<p>这里指，当前目录下的所有 <code>node_modules</code> ， <code>publish</code> 文件夹，<code>.log</code> 文件，都不会被 git 记录</p>
<h3 id="git-文件夹"><a href="#git-文件夹" class="headerlink" title=".git 文件夹"></a>.git 文件夹</h3><h4 id="HEAD-文件"><a href="#HEAD-文件" class="headerlink" title="HEAD 文件"></a>HEAD 文件</h4><h4 id="config-文件"><a href="#config-文件" class="headerlink" title="config 文件"></a>config 文件</h4><h4 id="refs-文件夹"><a href="#refs-文件夹" class="headerlink" title="refs 文件夹"></a>refs 文件夹</h4><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><h3 id="仓库管理"><a href="#仓库管理" class="headerlink" title="仓库管理"></a>仓库管理</h3><ul>
<li><p>拉取代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone xxx.git</span><br></pre></td></tr></table></figure>

<p>此命令会将远端仓库代码拉取到本地</p>
</li>
<li><p>关联远端仓库</p>
<p>这种情景通常发生在本地通过 <code>git init</code> 创建 <code>git</code> 时才会用到，一般从 <code>github</code> 上拉取的都会自动关联</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add remote add origin git地址</span><br></pre></td></tr></table></figure></li>
<li><p>修改远程仓库地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote set-url origin git地址</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h3><ul>
<li><p>查看</p>
<ul>
<li><p>列出所有本地分支</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure></li>
<li><p>列出所有本地分支和远程分支</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure></li>
<li><p>列出所有远端分支</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch -r</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>新建分支</p>
<p>此命令是新建一个分支，指向当前 commit，命令执行完毕后，还是停留在当前分支，并不会切过去</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch branch_name</span><br></pre></td></tr></table></figure>

<p>新建分支并切换到新建分支，此时要用到参数 <code>-b</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout -b branch_name</span><br></pre></td></tr></table></figure></li>
<li><p>删除分支</p>
<p>该命令一定不能在需要删除的分支中使用，譬如说想删除 <code>A</code> 分支，此时需要切换到 <code>B</code> 分支去删除 <code>A</code> 分支</p>
<p>前提是该分支没有未合并的变动。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch -d branch_name</span><br></pre></td></tr></table></figure>

<p>强制删除分支，有时候我们会遇到各种问题，例如：遇到未合并的变动，导致无法通过 <code>-d</code> 来删除分支，此时需要用 <code>-D</code> 参数来删除，该参数不管有没有未合并变化。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch -D branch_name</span><br></pre></td></tr></table></figure></li>
<li><p>修改分支名</p>
<ul>
<li><p>为当前分支改名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch -m new_branch_name</span><br></pre></td></tr></table></figure></li>
<li><p>为指定分支改名，如果有重名分支，强制改名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch -m other_branch_name new_other_branch_name</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h3><ul>
<li><p>提交到暂存区</p>
<ul>
<li><p>提交单个文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add file1</span><br></pre></td></tr></table></figure></li>
<li><p>提交多个文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add file1 file2 file3</span><br></pre></td></tr></table></figure></li>
<li><p>提交所有文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add.</span><br></pre></td></tr></table></figure></li>
<li><p>提交文件夹</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add folder</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>提交到存储区</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;xxx&quot;</span><br></pre></td></tr></table></figure></li>
<li><p><code>-u</code> 只添加暂存区已有的文件（包括删除操作），但不添加新增文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add -u</span><br></pre></td></tr></table></figure></li>
<li><p><code>-f</code> 强制添加某个文件，不管 <code>.gitignore</code> 是否包含这个文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add -f file</span><br></pre></td></tr></table></figure></li>
<li><p><code>-p</code> 进入交互模式，指定那些修改需要添加到暂存区，即使是同一个文件，也可以只提交部分变动</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add -p</span><br></pre></td></tr></table></figure></li>
<li><p><code>-a</code> 将所有工作区的变动文件，提交到暂存区，再运行 <code>git commit</code> ，用了<code>-a</code>参数，就不用执行 <code>git add .</code> 命令了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -am &quot;xxx&quot;</span><br></pre></td></tr></table></figure></li>
<li><p><code>—allow-empty</code> 用于没有提交信息的 <code>commit</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit --allow-empty</span><br></pre></td></tr></table></figure></li>
<li><p><code>--amend</code> 参数用于撤销上一次 <code>commit</code>，然后生成一个新的 <code>commit</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit --amend - m &quot;xxx&quot;</span><br></pre></td></tr></table></figure></li>
<li><p><code>--fixup</code> 对某个 <code>commit</code> 内容进行修正，自动添加 <code>fixup</code></p>
<p>当前添加的 <code>commit</code> 是以前某一个 <code>commit</code> 的修正。以后执行互动式的 <code>git rebase</code> 的时候，这两个 <code>commit</code> 将会合并成一个。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit --fixup &lt;commit&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/2019/03/01/github/git%E5%BF%85%E4%BF%AE%E8%AF%BE/image-20210914221613547.png" alt="image-20210914221613547"></p>
</li>
</ul>
<h3 id="内容查看"><a href="#内容查看" class="headerlink" title="内容查看"></a>内容查看</h3><ul>
<li><p>切换到指定快照（commit）</p>
<p>譬如说提交了多个 <code>commit</code>，此时想要切到其中一个 <code>commit</code> 中看里面的代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout &lt;commitID&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>切换到某个 <code>tag</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout tags/xxx</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>查看工作区与暂存区所有修改文件的差异</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git diff</span><br></pre></td></tr></table></figure></li>
<li><p>查看某个文件的工作区与暂存区的差异</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git diff xxx</span><br></pre></td></tr></table></figure></li>
<li><p>查看暂存区与当前 commit 的差异</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git diff --cached</span><br></pre></td></tr></table></figure></li>
<li><p>查看两个commit的差异</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git diff &lt;commitBefore&gt; &lt;commitAfter&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>查看工作区与上一次commit之间的差异</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git diff HEAD</span><br></pre></td></tr></table></figure></li>
<li><p>查看工作区与某个 commit 的差异</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git diff &lt;commit&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>查看所有 commit</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure></li>
<li><p>列出某个文件的历史 commit，包括文件改名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log --follow [file]</span><br></pre></td></tr></table></figure></li>
<li><p>查看远程分支的变动情况</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log remote/branch</span><br></pre></td></tr></table></figure></li>
<li><p>查找log，即搜索commit信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log --搜索内容</span><br><span class="line">// -i 表示忽略大小写</span><br><span class="line">git log -i --搜索内容</span><br></pre></td></tr></table></figure></li>
<li><p>log 美好输出，不用背，复制就好</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log --graph --decorate --pretty=oneline --abbrev-commit</span><br></pre></td></tr></table></figure></li>
<li><p>log 简化输出，每个 commit 只占用一行 <code>--oneline</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log --oneline --decorate</span><br></pre></td></tr></table></figure></li>
<li><p>查看 commit 内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git show commit_Id</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="内容提取"><a href="#内容提取" class="headerlink" title="内容提取"></a>内容提取</h3><ul>
<li><p>将某个 commit 复制到其他分支中</p>
<p>这个场景经常出现，譬如说 <code>A</code> 分支有 <code>10</code>  条  <code>commit</code>，我想将第三条 <code>commit</code> 的内容提取出来放到 <code>B</code> 分支中，并产生一次新的提交。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git cherry-pick &lt;commitID&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="撤销（回滚）"><a href="#撤销（回滚）" class="headerlink" title="撤销（回滚）"></a>撤销（回滚）</h3><ul>
<li><p>撤销工作区内容</p>
<p>指修改了代码，发现改错了，要还原</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout .</span><br></pre></td></tr></table></figure></li>
<li><p>回到当前分支下的某个 <code>commit</code></p>
</li>
<li><p>撤销暂存区，将暂存区内容回退到工作区</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reset</span><br></pre></td></tr></table></figure></li>
<li><p>回退到某个 <code>commit</code>，并在工作区保留最新的修改</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reset &lt;commit id&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/2019/03/01/github/git%E5%BF%85%E4%BF%AE%E8%AF%BE/image-20210916090023611.png" alt="image-20210916090023611"></p>
<p><img src="/2019/03/01/github/git%E5%BF%85%E4%BF%AE%E8%AF%BE/image-20210916090734101.png" alt="image-20210916090734101"></p>
<p>一目了然，<code>git reset</code> 命令会让工作区保留最新的修改内容</p>
</li>
<li><p>回退到相应的 <code>commit</code> 状态</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reset --hard &lt;commit ID&gt;</span><br></pre></td></tr></table></figure>

<p>加了 <code>--hard</code> 参数就不得了了，它会回到相应的 <code>commit</code>，那个 <code>commit</code> 之前的内容都会被销毁，工作区将没有内容，如上图所示，执行了 <code>git reset --hard commit2</code> 后，存储区内容将变成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.2</span><br><span class="line">2.2</span><br><span class="line">3.2</span><br></pre></td></tr></table></figure>

<p>工作区内容为空<br><img src="/2019/03/01/github/git%E5%BF%85%E4%BF%AE%E8%AF%BE/image-20210916091507268.png" alt="image-20210916091507268"></p>
</li>
<li><p>解除某个被 <code>add</code> 的文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git rm --cache file_name</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h3><ul>
<li><p>将<strong>当前分支</strong>合并到<strong>指定分支</strong></p>
<p>将当前分支与 <code>other_branch_name</code> 分支合并，产生的新的 <code>commit</code> 对象有两个父节点。</p>
<p>如果“指定分支”本身是当前分支的一个直接子节点，则会产生 <code>fast-forward</code> 合并，即合并不会产生新的节点，只是让当前分支指向“指定分支”的最新<code>commit</code>。</p>
<p><code>Git</code> 合并所采用的方法是 <code>Three-way merge</code>，及合并的时候除了要合并的两个档案，还加上它们共同的父节点。这样可以大大减少人为处理  <code>conflict</code>  的情况。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git merge other_branch_name</span><br></pre></td></tr></table></figure></li>
<li><p>合并<strong>指定分支</strong>到<strong>当前分支</strong>，此时在当前分支执行这条命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git pull other_branch_name</span><br></pre></td></tr></table></figure></li>
<li><p>rebase</p>
<p><strong>为什么要用 rebase？</strong></p>
<ul>
<li><p>不利于代码 review</p>
<p>在我们开发过程中，会遇到同一个问题点，改了又改的情况，这时，产生了一堆的 <code>commit</code>，实际上都是指向同一个问题点的，譬如一个很小的功能，提交了<code>30</code> 个 <code>commit</code>，下次 <code>review</code> 时会不会看到崩溃？</p>
</li>
<li><p>分支污染</p>
<p>有用的 <code>commit</code> 对我们才有意义的，不过在开发过程中总免不了提交些无用的 <code>commit</code>，而这些 <code>commit</code> 没有被清理的情况下，万一线上出现紧急问题，需要回滚代码，都不知道回到哪里。</p>
</li>
</ul>
<p>因此，<strong>通过 <code>rebase</code> 可以解决上述问题，并维护好 <code>commit</code> 记录</strong></p>
<p><code>rebase</code> 命令格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git rebase [-i | --interactive] [options] [--onto &lt;newbase&gt;]  &lt;upstream&gt; [&lt;branch&gt;]</span><br><span class="line">git rebase [-i | --interactive] [options] –onto &lt;newbase&gt;  –root [&lt;branch&gt;]</span><br><span class="line">git rebase –continue | –skip | –abort</span><br></pre></td></tr></table></figure>

<p>从命令格式，可以看到 <code>git-rebae</code> 命令<strong>至少</strong>需要一个参数，那就是 <code>&lt;upstream&gt;</code>，这个参数可以是一个分支名称，也可以是一次有效的 <code>commit</code>。</p>
<ul>
<li><p>场景一：对多个 <code>commit</code> 进行合并处理</p>
<p>合并最近 4 次的 <code>commit</code> 记录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git rebase -i HEAD~4</span><br></pre></td></tr></table></figure>

<p>执行完这条命令会进入 <code>vi</code> 编辑模式</p>
<p><img src="/2019/03/01/github/git%E5%BF%85%E4%BF%AE%E8%AF%BE/image-20210915212840866.png" alt="image-20210915212840866"></p>
<p>按照如上命令来修改你的提交纪录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s 686aa86 t</span><br><span class="line">s 7f865fb 1</span><br><span class="line">s 53a7e34 fixup! 1</span><br><span class="line">p e603ee0 t</span><br></pre></td></tr></table></figure>

<p>如果出现这个错误，说明</p>
<blockquote>
<p>注意不要合并先前提交的东西，也就是已经提交远程分支的纪录。</p>
</blockquote>
<p><img src="/2019/03/01/github/git%E5%BF%85%E4%BF%AE%E8%AF%BE/image-20210915213358609.png" alt="image-20210915213358609"></p>
<p>如果异常退出了 <code>vi</code> 窗口，可以通过下面命令回去编辑状态</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git rebase --edit-todo</span><br></pre></td></tr></table></figure>

<p>可以看到上图中，我们处于 <code>REBASE</code> 模式</p>
<p>通过下面命令可以保存</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git rebase --continue</span><br></pre></td></tr></table></figure>

<p>最后再通过 <code>git log</code> 查看 <code>rebase</code> 后的结果</p>
</li>
<li><p>场景二：分支合并</p>
<p>从 <code>master</code> 切出一个分支 <code>feature1</code> 进行开发</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout -b feature1</span><br></pre></td></tr></table></figure>

<p><img src="/2019/03/01/github/git%E5%BF%85%E4%BF%AE%E8%AF%BE/image-20210915214303234.png" alt="image-20210915214303234"></p>
<p>这时候其他同事更新了代码，并合入 <code>master</code>，此时 <code>master</code> 分支领先于你的 <code>feature1</code> 分支</p>
<p><img src="/2019/03/01/github/git%E5%BF%85%E4%BF%AE%E8%AF%BE/image-20210915215100098.png" alt="image-20210915215100098"></p>
<p>同事告诉你，<code>master</code> 更新了，让你在当前分支同步下，我们优先想到的是 <code>merge</code>，执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git merge master</span><br></pre></td></tr></table></figure>

<p>结构图就变成这样了</p>
<p><img src="/2019/03/01/github/git%E5%BF%85%E4%BF%AE%E8%AF%BE/image-20210915215526801.png" alt="image-20210915215526801"></p>
<p>其中绿色的点就是合并后的结果，通过 <code>git log</code> 可以看到有 <code>master_commit 信息 -&gt; feature1_log 信息 -&gt; master_log 信息 -&gt; feature1 合并后的 commit 信息</code>，原来通过 <code>merge</code> 我们会把所有的信息融在一起，我们不想污染 <code>commit</code> 记录，只想要保持一份干净的 <code>commit</code>，这时候，<code>git rebase</code> 就派上用场了。</p>
<p>我们将 <code>git merge</code> 替换成 <code>git rebase</code></p>
<p><strong><code>git rebase</code> 会做以下的几个操作</strong></p>
<ul>
<li>首先，<code>git</code> 会把 <code>feature1</code> 分支里面的每个 <code>commit</code> 取消掉</li>
<li>其次，把上面的操作临时保存成 <code>patch</code> 文件，存在 <code>.git/rebase</code> 目录下</li>
<li>然后，把 <code>feature1</code> 分支更新到最新的 <code>master</code> 分支</li>
<li>最后，把上面保存的 <code>patch</code> 文件应用到 <code>feature1</code> 分支上</li>
</ul>
<p><img src="/2019/03/01/github/git%E5%BF%85%E4%BF%AE%E8%AF%BE/image-20210915220426468.png" alt="image-20210915220426468"></p>
<p>可以理解为，<code>rebase</code> 有个中间站，它把<strong>当前分支</strong>的 <code>commit</code> 暂存起来保存为 <code>patch</code> 文件，合并完<strong>目标分支</strong>的 <code>commit</code>，再把<strong>当前分支</strong> <code>commit</code> 追加到末尾。 </p>
<p>在 <code>rebase</code> 的过程中，也许会出现冲突 <code>conflict</code>。在这种情况，<code>git</code> 会停止 <code>rebase</code> 并会让你去解决冲突。在解决完冲突后，用 <code>git add</code> 命令去更新这些内容。</p>
<blockquote>
<p>注意，你无需执行 git-commit，只要执行 continue</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git rebase --continue</span><br></pre></td></tr></table></figure>

<p>这样 <code>git</code> 会继续应用余下的 <code>patch</code> 补丁文件</p>
<p><strong>当你不想要 rebase 时，在任何时候，我们都可以用 <code>--abort</code> 参数来终止 <code>rebase</code> 的行动，并且分支会回到 <code>rebase</code> 开始前的状态。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git rebase --abort</span><br></pre></td></tr></table></figure>

<p>记住哟，是回到最开始的状态，也就是说，<code>rebase</code> 过程中所有操作都会复原，又要重头再来。</p>
</li>
<li><p>场景三：对一个分支进行<strong>变基</strong>操作 — 核心价值</p>
<blockquote>
<p>变基：改变分支的基准点，譬如说，每次的需求迭代都是才最新的 master 这个基准点上进行开发，有时候，因为外在因素，需要中断当前开发的需求，去进行其他的需求的开发工作，过了一段时间，又要继续开发这个需求，很显然，这个需求已经落后了，此时要在最新基准点上开发，切换基准点的过程就叫变基。</p>
</blockquote>
<p>当我们在一个过时的分支上面开发的时候，执行 <code>rebase</code> 以此同步 <code>master</code> 分支最新变动，当需要在最新的基准点上工作时，<code>rebase</code> 是最适合的选择。</p>
</li>
<li><p><strong>rebase 的使用边界</strong></p>
<p>任何一条命令都有它的使用边界，<code>rebase</code> 也不例外，它不是万能的，当两个同事在<strong>同一个分支</strong>上进行开发时，<code>A</code> 同事优先提交代码到远端，变成了这样，看起来没什么问题</p>
<p><img src="/2019/03/01/github/git%E5%BF%85%E4%BF%AE%E8%AF%BE/image-20210915223017624.png" alt="image-20210915223017624"></p>
<p><code>B</code> 同事也在你的分支上进行开发</p>
<p><img src="/2019/03/01/github/git%E5%BF%85%E4%BF%AE%E8%AF%BE/image-20210915223508932.png" alt="image-20210915223508932"></p>
<p>当他 <code>pull</code> 远程 <code>master</code> 的时候，就会有丢失提交纪录。这就是为什么我们经常听到有人说 <code>git rebase</code> 是一个危险命令，因为它<strong>改变了历史，或者说覆盖了历史</strong>，应该谨慎使用。</p>
<p>如果你能很肯定这个分支就是你用，你就放心的 rebase，否则谨慎使用，</p>
<p><strong>结论：只要你的分支上需要 <code>rebase</code> 的所有 <code>commits</code> 历史还没有被 <code>push</code> 过，就可以安全地使用 <code>git-rebase</code>来操作。</strong></p>
</li>
</ul>
</li>
</ul>
<h3 id="暂存"><a href="#暂存" class="headerlink" title="暂存"></a>暂存</h3><p>暂存，也就是暂时存储，在开发过程中，突然有个线上问题需要去解决，只开发到一半，不需要 <code>commit</code> 情况下，通过如下命令，可以把<strong>工作区或暂存区</strong>的文件<strong>临时</strong>存储，待线上问题解决后，再还原。这是第一步，任何暂存都要从这里开始</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git stash</span><br></pre></td></tr></table></figure>

<ul>
<li><p>查看暂存列表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git stash list</span><br></pre></td></tr></table></figure>

<p><img src="/2019/03/01/github/git%E5%BF%85%E4%BF%AE%E8%AF%BE/image-20210916220553797.png" alt="image-20210916220553797"></p>
</li>
<li><p>恢复最近一次 <code>stash</code> 文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git stash pop</span><br></pre></td></tr></table></figure></li>
<li><p>恢复指定的 <code>stash</code> 文件，譬如，这里指定恢复 <code>stash@&#123;0&#125;</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git stash apply stash@&#123;0&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>清除所有暂存</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git stash clear</span><br></pre></td></tr></table></figure></li>
<li><p>丢弃最近一次 <code>stash</code> 的文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git stash drop</span><br></pre></td></tr></table></figure></li>
</ul>
<p><code>git stash</code> 命令可以运行多次，保存多个未提交的修改。这些修改以“先进后出”的 <code>stack</code> 结构保存。</p>
<h3 id="冲突解决"><a href="#冲突解决" class="headerlink" title="冲突解决"></a>冲突解决</h3><p>在合并代码时候，会有很多的冲突场景，大多数情况下，都是在 <code>vscode</code> 上面修改就行，不过也有些情况，可以快速解决冲突。</p>
<ul>
<li><p>以某一分支的内容为准</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout --theirs xxx</span><br></pre></td></tr></table></figure>

<p>另一个参数 <code>--ours</code>，以另一个分支文件为准</p>
</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://jartto.wang/2018/12/11/git-rebase/">彻底搞懂 Git-Rebase</a></p>
<p><a href="https://www.bookstack.cn/read/git-tutorial/docs-commands-git-branch.md">阮一峰 GIT 教程</a></p>
]]></content>
      <categories>
        <category>github</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>如何用 Github issues 写技术博客？</title>
    <url>/2019/01/01/github/%E5%A6%82%E4%BD%95%E7%94%A8Githubissues%E5%86%99%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p><img src="/2019/01/01/github/%E5%A6%82%E4%BD%95%E7%94%A8Githubissues%E5%86%99%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/image-20210719161213300.png" alt="image-20210719161213300"></p>
<p>工作也好几年了，辗转于各大平台写博客，最后还是 Github 是我的最爱</p>
<span id="more"></span>

<p>要通过 issues 写技术博客，需要以下几个步骤</p>
<h3 id="1、在-Github-上创建-Blog-项目仓库"><a href="#1、在-Github-上创建-Blog-项目仓库" class="headerlink" title="1、在 Github 上创建 Blog 项目仓库"></a>1、在 Github 上创建 Blog 项目仓库</h3><p>这步就不多说了，有 Github 账号的应该都会创建吧<br><img src="/2019/01/01/github/%E5%A6%82%E4%BD%95%E7%94%A8Githubissues%E5%86%99%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/81579083-48b3ff00-93de-11ea-9152-bc956ac01918.png" alt="image"></p>
<h3 id="2、创建-Projects"><a href="#2、创建-Projects" class="headerlink" title="2、创建 Projects"></a>2、创建 Projects</h3><p>Projects 可以理解为一个一个组，写好的 issues 可以存放到相应的组中<br><img src="/2019/01/01/github/%E5%A6%82%E4%BD%95%E7%94%A8Githubissues%E5%86%99%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/81632927-091cff80-943e-11ea-978a-205c07d9b20c.png" alt="image"></p>
<h3 id="3、创建-Labels"><a href="#3、创建-Labels" class="headerlink" title="3、创建 Labels"></a>3、创建 Labels</h3><p>在项目的 issues 下有个 Labels 功能，通过它，你可以创建相应的 Labels，Labels 可以理解为 Blog 中的一个个标签，通过标签，可以搜索分类你的内容.<br><img src="/2019/01/01/github/%E5%A6%82%E4%BD%95%E7%94%A8Githubissues%E5%86%99%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/81585146-52d9fb80-93e6-11ea-9536-1f31e7bc4d22.png" alt="image"><br><img src="/2019/01/01/github/%E5%A6%82%E4%BD%95%E7%94%A8Githubissues%E5%86%99%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/81585188-61281780-93e6-11ea-9df0-a7d6b3c9de13.png" alt="image"></p>
<h3 id="4、创建-issues"><a href="#4、创建-issues" class="headerlink" title="4、创建 issues"></a>4、创建 issues</h3><p>issues 就是我们博客的内容了，new issues 开启我们的博客编写页面<br><img src="/2019/01/01/github/%E5%A6%82%E4%BD%95%E7%94%A8Githubissues%E5%86%99%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/81630270-bb9d9400-9437-11ea-96f7-9b0d44987846.png" alt="image"></p>
<p>在 issues 里，可以做相应配置，选择一个project，提交后这个issue就会分类到这个project下面<br><img src="/2019/01/01/github/%E5%A6%82%E4%BD%95%E7%94%A8Githubissues%E5%86%99%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/81630881-49c64a00-9439-11ea-873a-38dc93678434.png" alt="image"></p>
<h3 id="5、在-Projects-上建立关联"><a href="#5、在-Projects-上建立关联" class="headerlink" title="5、在 Projects 上建立关联"></a>5、在 Projects 上建立关联</h3><p>进入需要关联的 Projects 后，创建子分组，例如我这里创建一个 Blog<br><img src="/2019/01/01/github/%E5%A6%82%E4%BD%95%E7%94%A8Githubissues%E5%86%99%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/81633008-3ec1e880-943e-11ea-9d90-21e6929dc15c.png" alt="image"></p>
<p>然后点击 add card 在里面可以找到刚刚编写的 issues<br><img src="/2019/01/01/github/%E5%A6%82%E4%BD%95%E7%94%A8Githubissues%E5%86%99%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/81633170-ad9f4180-943e-11ea-8a7c-299ec30ae9af.png" alt="image"></p>
<p>最后将 issues 拖入到子分组中<br><img src="/2019/01/01/github/%E5%A6%82%E4%BD%95%E7%94%A8Githubissues%E5%86%99%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/81633213-cdcf0080-943e-11ea-9441-a96df8fa3874.png" alt="image"></p>
<p>以上就完成了博客的开发功能了</p>
<h3 id="6、在-README-中呈现"><a href="#6、在-README-中呈现" class="headerlink" title="6、在 README 中呈现"></a>6、在 README 中呈现</h3><p>博客编写好了，在 README 上配置相应的入口，这样就完成了呢<br><img src="/2019/01/01/github/%E5%A6%82%E4%BD%95%E7%94%A8Githubissues%E5%86%99%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/81633590-adec0c80-943f-11ea-98b2-38b268430c80.png" alt="image"></p>
<p>这样我们就可以在主页上快速找到 Blog 了<br><img src="/2019/01/01/github/%E5%A6%82%E4%BD%95%E7%94%A8Githubissues%E5%86%99%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/81633646-ccea9e80-943f-11ea-9d88-b48b52cb1313.png" alt="image"></p>
<h3 id="极简博客"><a href="#极简博客" class="headerlink" title="极简博客"></a>极简博客</h3><p>说了半天，有的小伙伴觉得，这样也太复杂了吧，又点这又点那，还要配置关联 projects，那么有没有像其他平台一样，分类 + 文章呢？ of course，安排！<br>最快速的方法就是在 issues 编写，然后在首页 README 中建立相应连接即可<br><img src="/2019/01/01/github/%E5%A6%82%E4%BD%95%E7%94%A8Githubissues%E5%86%99%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/81634772-366bac80-9442-11ea-97a6-3d4f98b84551.png" alt="image"></p>
]]></content>
      <categories>
        <category>github</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>lodash</title>
    <url>/2011/12/30/algorithms/lodash/</url>
    <content><![CDATA[<p><img src="/2011/12/30/algorithms/lodash/image-20220226224602747.png" alt="image-20220226224602747"></p>
<blockquote>
<p>小练习，实现 lodash 库中的方法</p>
</blockquote>
<span id="more"></span>

<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="chunk"><a href="#chunk" class="headerlink" title="chunk"></a>chunk</h3><blockquote>
<p>将数组（array）拆分成多个 size 长度的区块，并将这些区块组成一个新数组。 如果array 无法被分割成全部等长的区块，那么最后剩余的元素将组成一个区块。</p>
</blockquote>
<p>参数</p>
<ul>
<li>array (Array): 需要处理的数组</li>
<li>[size=1] (number): 每个数组区块的长度</li>
</ul>
<p>返回</p>
<ul>
<li>(Array): 返回一个包含拆分区块的新数组（注：相当于一个二维数组）。</li>
</ul>
<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_.chunk([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;], 2);</span><br><span class="line">// =&gt; [[&#x27;a&#x27;, &#x27;b&#x27;], [&#x27;c&#x27;, &#x27;d&#x27;]]</span><br><span class="line"> </span><br><span class="line">_.chunk([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;], 3);</span><br><span class="line">// =&gt; [[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;], [&#x27;d&#x27;]]</span><br></pre></td></tr></table></figure>

<p>实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const slice = (array, start, end) =&gt; &#123;</span><br><span class="line">	const arr = []</span><br><span class="line">	for (let i = start; i &lt; array.length &amp;&amp; i &lt; end; i++) &#123;</span><br><span class="line">		arr.push(array[i])</span><br><span class="line">	&#125;</span><br><span class="line">	return arr</span><br><span class="line">&#125;</span><br><span class="line">const chunk = (array, size) =&gt; &#123;</span><br><span class="line">	const arr = []</span><br><span class="line">	let start = 0</span><br><span class="line">	while(start &lt; array.length) &#123;</span><br><span class="line">		arr.push(slice(array, start, start += size))</span><br><span class="line">	&#125;</span><br><span class="line">	return arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="compact"><a href="#compact" class="headerlink" title="compact"></a>compact</h3><blockquote>
<p>创建一个新数组，包含原数组中所有的非假值元素。例如false, null,0, “”, undefined, 和 NaN 都是被认为是“假值”。</p>
</blockquote>
<p>参数</p>
<ul>
<li>array (Array): 待处理的数组</li>
</ul>
<p>返回</p>
<ul>
<li>(Array): 返回过滤掉假值的新数组</li>
</ul>
<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_.compact([0, 1, false, 2, &#x27;&#x27;, 3]);</span><br><span class="line">// =&gt; [1, 2, 3]</span><br></pre></td></tr></table></figure>

<p>实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const compact = (array) =&gt; &#123;</span><br><span class="line">	return array.filter(Boolean)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="difference"><a href="#difference" class="headerlink" title="difference"></a>difference</h3><blockquote>
<p>创建一个具有唯一array值的数组，每个值不包含在其他给定的数组中。（注：即创建一个新数组，这个数组中的值，为第一个数字（array 参数）排除了给定数组中的值。）该方法使用SameValueZero做相等比较。结果值的顺序是由第一个数组中的顺序确定。</p>
</blockquote>
<p>参数</p>
<ul>
<li>array (Array): 要检查的数组。</li>
<li>[values] (…Array): 排除的值。</li>
</ul>
<p>返回值</p>
<ul>
<li>(Array): 返回一个过滤值后的新数组。</li>
</ul>
<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_.difference([3, 2, 1], [4, 2]);</span><br><span class="line">// =&gt; [3, 1]</span><br></pre></td></tr></table></figure>

<p>实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const difference = (arr1, arr2) =&gt; arr1.filter(item =&gt; !arr2.includes(item))</span><br></pre></td></tr></table></figure>



<h3 id="flatten"><a href="#flatten" class="headerlink" title="flatten"></a>flatten</h3><blockquote>
<p>减少 array 嵌套深度。</p>
</blockquote>
<p>参数</p>
<ul>
<li>array (Array): 需要减少嵌套层级的数组。</li>
</ul>
<p>返回值</p>
<ul>
<li>(Array): 返回减少嵌套层级后的新数组。</li>
</ul>
<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_.flatten([1, [2, [3, [4]], 5]]);</span><br><span class="line">// =&gt; [1, 2, [3, [4]], 5]</span><br></pre></td></tr></table></figure>

<p>实现</p>
<ul>
<li>方法1：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> flatten = <span class="function">(<span class="params">array</span>) =&gt;</span> array.join().split(<span class="string">&#x27;,&#x27;</span>).map(<span class="built_in">Number</span>)</span><br></pre></td></tr></table></figure></li>
<li>方法2<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> flatten = <span class="function">(<span class="params">array</span>) =&gt;</span> array.reduce(<span class="function">(<span class="params">acc, cur</span>) =&gt;</span> (<span class="built_in">Array</span>.isArray(cur) ? [...acc, ...flatten(cur)] : [...acc, cur]), [])</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="变种"><a href="#变种" class="headerlink" title="变种"></a>变种</h4><blockquote>
<p>如果期望按照层级去减少 array 嵌套深度，怎么做呢？</p>
</blockquote>
<p>参数</p>
<ul>
<li>array (Array): 需要减少嵌套层级的数组。</li>
<li>index: 减少的层级深度</li>
</ul>
<p>返回值</p>
<ul>
<li>(Array): 返回减少嵌套层级后的新数组。</li>
</ul>
<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var array = [1, [2, [3, [4]], 5]];</span><br><span class="line"> </span><br><span class="line">_.flattenDepth(array, 1);</span><br><span class="line">// =&gt; [1, 2, [3, [4]], 5]</span><br><span class="line"></span><br><span class="line">_.flattenDepth(array, 2);</span><br><span class="line">// =&gt; [1, 2, 3, [4], 5]</span><br></pre></td></tr></table></figure>

<p>实现</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> flattenDepth = <span class="function">(<span class="params">array, index</span>) =&gt;</span>array.reduce(<span class="function">(<span class="params">acc, cur</span>) =&gt;</span> (index !== <span class="number">0</span> &amp;&amp; (<span class="built_in">Array</span>.isArray(cur)) ? [...acc, ...flattenDepth(cur, index - <span class="number">1</span>)] : [...acc, cur]), [])</span><br></pre></td></tr></table></figure>



<h3 id="fromPairs"><a href="#fromPairs" class="headerlink" title="fromPairs"></a>fromPairs</h3><blockquote>
<p>这个方法返回一个由键值对<code>pairs</code>构成的对象。</p>
</blockquote>
<p>参数</p>
<ul>
<li><code>pairs</code> <em>(Array)</em>: 键值对<code>pairs</code>。</li>
</ul>
<p>返回值</p>
<ul>
<li><em>(Object)</em>: 返回一个新对象。</li>
</ul>
<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_.fromPairs([[&#x27;fred&#x27;, 30], [&#x27;barney&#x27;, 40]]);</span><br><span class="line">// =&gt; &#123; &#x27;fred&#x27;: 30, &#x27;barney&#x27;: 40 &#125;</span><br></pre></td></tr></table></figure>

<p>实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const fromPairs = (array) =&gt; &#123;</span><br><span class="line">  const map = &#123;&#125;</span><br><span class="line">  array.forEach(item =&gt; &#123;</span><br><span class="line">    const [key, value] = item</span><br><span class="line">    map[key] = value </span><br><span class="line">  &#125;)</span><br><span class="line">  return map</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>





<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><h3 id="at"><a href="#at" class="headerlink" title="at"></a>at</h3><blockquote>
<p>创建一个数组，值来自 <code>object</code> 的<code>paths</code>路径相应的值。</p>
</blockquote>
<p>参数</p>
<ol>
<li><code>object</code> <em>(Object)</em>: 要迭代的对象。</li>
<li><code>[paths]</code> <em>(…(string|string[]))</em>: 要获取的对象的元素路径，单独指定或者指定在数组中。</li>
</ol>
<p>返回</p>
<ul>
<li><em>(Array)</em>: 返回选中值的数组。</li>
</ul>
<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var object = &#123; &#x27;a&#x27;: [&#123; &#x27;b&#x27;: &#123; &#x27;c&#x27;: 3 &#125; &#125;, 4] &#125;;</span><br><span class="line"> </span><br><span class="line">_.at(object, [&#x27;a[0].b.c&#x27;, &#x27;a[1]&#x27;]);</span><br><span class="line">// =&gt; [3, 4]</span><br></pre></td></tr></table></figure>

<p>实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const at = (object, path) =&gt; &#123;</span><br><span class="line">  const res = []</span><br><span class="line">  for (let i = 0; i &lt; path.length; i++) &#123;</span><br><span class="line">    res.push(path[i].replace(/\[/g, &#x27;.&#x27;).replace(/\]/g, &#x27;&#x27;).split(&#x27;.&#x27;).reduce((o, k) =&gt; (o || &#123;&#125;)[k], object))</span><br><span class="line">  &#125;</span><br><span class="line">  return res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><blockquote>
<p>根据 <code>object</code>对象的<code>path</code>路径获取值。 如果解析 value 是 <code>undefined</code> 会以 <code>defaultValue</code> 取代。</p>
</blockquote>
<p>参数</p>
<ol>
<li><code>object</code> <em>(Object)</em>: 要检索的对象。</li>
<li><code>path</code> <em>(Array|string)</em>: 要获取属性的路径。</li>
<li><code>[defaultValue]</code> <em>(*)</em>: 如果解析值是 <code>undefined</code> ，这值会被返回。</li>
</ol>
<p>返回值</p>
<ul>
<li><em>(*)</em>: 返回解析的值。</li>
</ul>
<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var object = &#123; &#x27;a&#x27;: [&#123; &#x27;b&#x27;: &#123; &#x27;c&#x27;: 3 &#125; &#125;] &#125;;</span><br><span class="line"> </span><br><span class="line">_.get(object, &#x27;a[0].b.c&#x27;);</span><br><span class="line">// =&gt; 3</span><br><span class="line"> </span><br><span class="line">_.get(object, [&#x27;a&#x27;, &#x27;0&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]);</span><br><span class="line">// =&gt; 3</span><br><span class="line"> </span><br><span class="line">_.get(object, &#x27;a.b.c&#x27;, &#x27;default&#x27;);</span><br><span class="line">// =&gt; &#x27;default&#x27;</span><br></pre></td></tr></table></figure>

<p>实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const get = (object, path, defaultValue) =&gt; &#123;</span><br><span class="line">	return (Array.isArray(path) ? path : path.replace(/\[/g, &#x27;.&#x27;).replace(/\]/g. &#x27;&#x27;).split(&#x27;.&#x27;))</span><br><span class="line">		.reduce((o, k) =&gt; (o || &#123;&#125;)[k], object) || defaultValue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="defaults"><a href="#defaults" class="headerlink" title="defaults"></a>defaults</h3><blockquote>
<p>分配来源对象的可枚举属性到目标对象所有解析为 <code>undefined</code> 的属性上。 来源对象从左到右应用。 一旦设置了相同属性的值，后续的将被忽略掉。</p>
</blockquote>
<p>参数</p>
<ol>
<li><code>object</code> <em>(Object)</em>: 目标对象。</li>
<li><code>[sources]</code> <em>(…Object)</em>: 来源对象。</li>
</ol>
<p>返回</p>
<ul>
<li><em>(Object)</em>: 返回 <code>object</code>。</li>
</ul>
<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_.defaults(&#123; &#x27;a&#x27;: 1 &#125;, &#123; &#x27;b&#x27;: 2 &#125;, &#123; &#x27;a&#x27;: 3 &#125;);</span><br><span class="line">// =&gt; &#123; &#x27;a&#x27;: 1, &#x27;b&#x27;: 2 &#125;</span><br></pre></td></tr></table></figure>

<p>实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const defaults = (...params) =&gt; &#123;</span><br><span class="line">  const res = &#123;&#125;</span><br><span class="line">  for (let i = 0; i &lt; params.length; i++) &#123;</span><br><span class="line">    const key = Object.keys(params[i])[0]</span><br><span class="line">    if (!res[key]) &#123;</span><br><span class="line">      res[key] = params[i][key]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>时间复杂度 O(log n) 意味着什么？</title>
    <url>/2011/12/11/algorithms/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6O(logn)%E6%84%8F%E5%91%B3%E7%9D%80%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<span id="more"></span>

<p>在学习算法过程中，<code>O(1)</code> 和 <code>O(n)</code> 都是比较好理解的，<code>O(1)</code> 表示一次操作即可直接取得目标元素，比如字典或哈希表，还有数组的取值，<code>O(n)</code> 意味着先要检查 <code>n</code> 个元素来搜索目标，譬如说数组的循环查找。但 <code>O(log n)</code> 是什么鬼？</p>
<p>第一次听说 <code>O(log n)</code> 是在学二分搜索算法的时候，那么二分搜索一定有办法让复杂度变成 <code>O(logn)</code> 的，让我们回顾下过程</p>
<p>譬如说现在要有个长度为 20 的数组，要找到数字 8 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20</span><br></pre></td></tr></table></figure>

<p>其中间点为 <code>10</code>，取一半的长度 20 / 2 = 10，判断 8 是否小于中心点，是，则舍弃一半，从 1 ~ 10 中寻找</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1,2,3,4,5,6,7,8,9,10</span><br></pre></td></tr></table></figure>

<p>重复这个过程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6,7,8,9,10</span><br></pre></td></tr></table></figure>

<p>最终找到数字 8</p>
<p>简化后，我们得到一个公式，就是每次取二分之一</p>
<p>因此，类似的，有 n 个元素 <code>n*((1/2)^k)</code>，因此化简后有</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 = n^k</span><br></pre></td></tr></table></figure>

<p>在对数定义中</p>
<blockquote>
<p>为使某数（底数）等于一给定数而必须取的乘幂的幂指数。</p>
</blockquote>
<p>因此 <code>2 = n^k</code> 等价于 <code>log2^n = k</code></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数组</title>
    <url>/2011/11/23/algorithms/%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p><img src="/2011/11/23/algorithms/%E6%95%B0%E7%BB%84/image-20211123220952200.png" alt="image-20211123220952200"></p>
<blockquote>
<p>数组是一种数据类型，它是一种最基础的数据结构，它是一种线性表数据结构，它用一组连续的内存空间，来存储一组具有相同类型的数据。它只有前后两个方向。</p>
</blockquote>
<span id="more"></span>



<h2 id="线性结构和非线性结构"><a href="#线性结构和非线性结构" class="headerlink" title="线性结构和非线性结构"></a>线性结构和非线性结构</h2><p>线性结构：顾名思义就是像一条线一样的结构，每个线性结构的数据最多只有前和后两个方向。除了数组，链表，队列，栈等都是线性结构</p>
<p><img src="/2011/11/23/algorithms/%E6%95%B0%E7%BB%84/b6b71ec46935130dff5c4b62cf273477.jpg" alt="img"></p>
<p>非线性结构：与线性结构相对立的，比如二叉树、堆、图等。之所以叫非线性，是因为，在非线性表中，<strong>数据之间并不是简单的前后关系</strong>。</p>
<p><img src="/2011/11/23/algorithms/%E6%95%B0%E7%BB%84/6ebf42641b5f98f912d36f6bf86f6569.jpg" alt="img"></p>
<h2 id="数组的特点"><a href="#数组的特点" class="headerlink" title="数组的特点"></a>数组的特点</h2><ul>
<li>线性结构</li>
<li>连续的内存空间和相同类型的数据</li>
</ul>
<p>因为上述原因，数组的特性：随机访问，<strong>查找数据很高效，插入删除，很低效</strong>。</p>
<blockquote>
<p>数组和链表的区别？</p>
<p>数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)。</p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法基本概念</title>
    <url>/2011/11/13/algorithms/base/</url>
    <content><![CDATA[<p><img src="/2011/11/13/algorithms/base/image-20211113153746161.png" alt="image-20211113153746161"></p>
<span id="more"></span>

<ul>
<li><p>数据结构和算法是什么？</p>
<ul>
<li>数据结构是指一组数据的存储结构</li>
<li>算法就是操作数据的方法</li>
<li>数据结构和算法是相辅相成的，数据结构是为算法服务的，而算法要作用在特定的数据结构之上</li>
<li><strong>这个数据该怎么存储，就是数据结构，如何处理数据的就是算法。</strong></li>
</ul>
<p>数据结构和算法是相辅相成的，数据结构是为算法服务的，算法要作用在特定的数据结构之上，因此，缺少一个都无从谈起。譬如说，数组具有随机访问的特点，常用的二分查找算法需要用数组来存储数据，但如果我们选择链表这种数据结构，二分查找算法就无法工作了，因为链表并不支持随机访问。</p>
<p>数据结构是静态的，它只是组织数据的一种方式，如果不在它的基础上操作，构建算法，孤立存在的数据结构就是没用的。</p>
</li>
<li><p>学习重点在哪里？</p>
<p>数据结构和算法解决的是如何更省，更快地存储和处理数据的问题，因此，我们就需要一个考量效率和资源消耗的方法，这就是复杂度分析方法，在学习数据结构和算法的过程中，要学习它的【来历】，【自身特点】，【适合解决的问题】以及【实际的应用场景】。</p>
<ul>
<li>数据结构和算法学习的精髓—复杂度分析</li>
<li>最常用的，最基础的数据结构（10个）：数组，链表，栈，队列，散列表，二叉树，堆，跳表，图，Trie树</li>
<li>最常用的算法（10个）：递归，排序，二分查找，搜索，哈希算法，贪心算法，分治算法，回溯算法，动态规划，字符串匹配算法。</li>
</ul>
</li>
</ul>
<p><img src="/2011/11/13/algorithms/base/image-20211113152358452.png" alt="image-20211113152358452"></p>
<ul>
<li><p>怎么衡量数据结构和算法</p>
<p>衡量标准 —— 时间复杂度和空间复杂度</p>
</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>时空复杂度</title>
    <url>/2011/11/13/algorithms/%E6%97%B6%E7%A9%BA%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
    <content><![CDATA[<p><img src="/2011/11/13/algorithms/%E6%97%B6%E7%A9%BA%E5%A4%8D%E6%9D%82%E5%BA%A6/image-20211113154056208.png" alt="image-20211113154056208"></p>
<blockquote>
<p>我们都知道，数据结构和算法本身是为了解决”快”和”省”的问题，如何让代码运行得更快，如何让代码更省存储空间，所以说执行效率是算法一个非常重要的考量指标。</p>
</blockquote>
<span id="more"></span>

<blockquote>
<p>复杂度也叫渐进复杂度，包括时间复杂度和空间复杂度，用来分析算法执行效率与数据规模之间的增长关系，可以粗略地表示，越高阶复杂度的算法，执行效率越低。常见的复杂度并不多，从低阶到高阶有：O(1)、O(logn)、O(n)、O(nlogn)、O(n2 )。等</p>
</blockquote>
<h2 id="大-O-表示法"><a href="#大-O-表示法" class="headerlink" title="大 O 表示法"></a>大 O 表示法</h2><blockquote>
<p>T(n) = O(fn)</p>
</blockquote>
<p>T 表示代码执行时间，n 表示数据规模大小，f(n) 表示每行代码执行的次数总和。O 表示代码的执行时间 T(n) 与 f(n) 表达式成正比。</p>
<p>譬如说</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">T(n) = O(2n + 2)</span><br><span class="line">T(n) = O(2n² + 2n + 3)</span><br></pre></td></tr></table></figure>

<p>这就是大 O 表示法，大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以也叫作渐进时间复杂度，简称时间复杂度。</p>
<h3 id="如何分析时间复杂度？"><a href="#如何分析时间复杂度？" class="headerlink" title="如何分析时间复杂度？"></a>如何分析时间复杂度？</h3><ul>
<li><p>只关注循环执行次数最多的一段代码</p>
<p>大 O 这种复杂度表示方法只是表示一种变化趋势，我们通常会忽略掉公式中的常量，低阶，系数，只需要记录一个最大阶的量级就可以了。也就是说 <strong>一段代码中，只关注循环执行次数最多的那一段代码就可以了</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const func = () =&gt; &#123;</span><br><span class="line">	const n = 10000</span><br><span class="line">	const num = 1</span><br><span class="line">	for(let i = 0; i &lt; n; i++) &#123;</span><br><span class="line">		console.log(i, num)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码中，从时间复杂度而言，只需要关注循环，即，n。</p>
</li>
<li><p>加法法则：总复杂度等于量级最大的那段代码的复杂度</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const func = (n) =&gt; &#123;</span><br><span class="line">	const sum = 0</span><br><span class="line">	for(let i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">		sum += i</span><br><span class="line">	&#125;</span><br><span class="line">	for(let j = 0; i &lt; n; j++) &#123;</span><br><span class="line">		sum += j</span><br><span class="line">	&#125;</span><br><span class="line">	for(let k = 0; i &lt; n; k++) &#123;</span><br><span class="line">		sum += k</span><br><span class="line">		for(let l = 0; l &lt; n; l++) &#123;</span><br><span class="line">      sum += l</span><br><span class="line">    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个代码有 3 个大循环体，我们可以分析每个循环体的时间复杂度，然后加在一起，取量级最大的作为整段代码的复杂度</p>
<p>第一个循环体，时间复杂度为常量，因为它有个具体的值，n1 = 100</p>
<p>第二个循环体，时间复杂度为 n</p>
<p>第三个循环体，时间复杂度为 n²</p>
<p>因此这段代码，时间复杂度为 <code>T(n) = O(n² + n)</code>，取最大，化简为<code>T(n) = O(n²)</code>，即如果 <code>T1(n) = O(f(n))</code>，<code>T2(n) = O(g(n))</code>，那么 <code>T(n) = T1(n) + T2(n) = max(O(f(n)) * O(g(n))) = O(max(f(n), g(n)))</code></p>
</li>
<li><p>乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const func = (n) =&gt; &#123;</span><br><span class="line">	const sum = 0</span><br><span class="line">	for(let k = 0; i &lt; n; k++) &#123;</span><br><span class="line">		sum += k</span><br><span class="line">		for(let l = 0; l &lt; n; l++) &#123;</span><br><span class="line">      sum += l</span><br><span class="line">    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码中有个嵌套循环，因此次循环体的时间复杂度是  <code>T(n) = O(n²)</code>，即  <code>T1(n) = O(f(n))</code>，<code>T2(n) = O(g(n))</code>，那么<code>T(n) = T1(n) * T2(n) = O(f(n)) * O(g(n)) = O(f(n) * g(n))</code>。</p>
</li>
</ul>
<h2 id="复杂度量级（按数量级递增）"><a href="#复杂度量级（按数量级递增）" class="headerlink" title="复杂度量级（按数量级递增）"></a>复杂度量级（按数量级递增）</h2><ul>
<li>常量级 O(1)</li>
<li>指数阶 O(2^n)</li>
<li>对数阶 O(logn)</li>
<li>阶乘阶 O(n!)</li>
<li>线性阶 O(n)</li>
<li>线性对数阶 O(nlogn)</li>
<li>平方阶 O(n²)</li>
<li>立方阶 O(n³)</li>
<li>k次方阶 O(n^k)</li>
</ul>
<p>复杂度量级可以分为两类，多项式量级和非多项式量级，其中，非多项式量级只有两个 <code>O(2^n)</code> 和 <code>O(n!)</code></p>
<p>当数据规模 <code>n</code> 越来越大时，非多项式量级算法的执行时间会急剧增加，求解问题的执行时间会无限增长，所以，<strong>非多项式时间复杂度的算法其实是非常低效的算法。</strong></p>
<p>我们把时间复杂度为非多项式量级的算法问题叫做<strong>NP问题</strong>(Non-Deterministic Polynomial, 非确定多项式)。</p>
<ul>
<li><p>多项量级就是说这个时间复杂度是由<code>n</code>作为底数的 <code>O(n)</code> 或 <code> O(nlogn)</code> </p>
</li>
<li><p>非多项量级就是 <code>n</code> 不是作为底数的指数阶级</p>
</li>
</ul>
<h3 id="O-1"><a href="#O-1" class="headerlink" title="O(1)"></a>O(1)</h3><p>常量级时间复杂度的一种表示法，它不随 n 的变化而变化的，一般来说，算法中只要不存在循环语句或者递归语句，即使有上千行代码，时间复杂度也是 O(1)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const n1 = 1</span><br><span class="line">const n2 = 2</span><br><span class="line">const sum = n1 + n2</span><br></pre></td></tr></table></figure>



<h3 id="O-logn-、O-nlogn"><a href="#O-logn-、O-nlogn" class="headerlink" title="O(logn)、O(nlogn)"></a>O(logn)、O(nlogn)</h3><p>对数阶时间复杂度</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let i = 1</span><br><span class="line">while(i &lt;= n) &#123;</span><br><span class="line">	i = i * 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据前面的分析，第三行代码是执行次数最多的，因此只要计算出这行代码被执行了多少次，就能知道整段代码的时间复杂度。当 <code>i</code> 大于 <code>n</code> 时，循环结束。其实这段代码是个<strong>等比数列</strong>，变量 <code>i</code> 的值从 <code>1</code> 开始取，每循环一次就乘以 <code>2</code>。当大于 <code>n</code> 时，循环结束。因此</p>
<blockquote>
<p>等比数列是指从第二项起，每一项与它的前一项的比值等于同一个常数的一种数列，常用G、P表示。这个常数叫做等比数列的公比，公比通常用字母q表示(q≠0)，等比数列a1≠ 0。其中{an}中的每一项均不为0。注：q=1 时，an为常数列。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2^0，2^1，2^2，2^3，2^4 …… 2^x = n</span><br><span class="line">2 ^ x = n </span><br><span class="line">x = log2^n</span><br></pre></td></tr></table></figure>

<p>这段代码的时间复杂度是 <code>O(log2^n)</code>，我们知道对数中是可以互相转换的，<code>log2^n = log2^2 * log2^n</code>，<code>log3^n = log3^2 * log2^n</code>，因为前者是个常量，因此<strong>在对数阶时间复杂度里，我们统一忽略对数的底</strong>，统一表示为<code>O(logn)</code></p>
<p><code>O(nlogn)</code> 更好理解了，它就是将对数循环 <code>n</code> 次，比如归并排序，快速排序的时间复杂度都是 <code>O(nlogn)</code>。</p>
<h3 id="O-m-n-、O-m-n"><a href="#O-m-n-、O-m-n" class="headerlink" title="O(m+n)、O(m*n)"></a>O(m+n)、O(m*n)</h3><p>这种类型的时间复杂度由数据规模来决定的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const func = (x, y) =&gt; &#123;</span><br><span class="line">	let sum = 0</span><br><span class="line">	for(let i = 0; i &lt; x; i++) &#123;</span><br><span class="line">		sum += i</span><br><span class="line">	&#125;</span><br><span class="line">	for(let j = 0; j &lt; y; j++) &#123;</span><br><span class="line">		sum += j</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和上面的例子不太一样，由于有两个数据规模，因此不知道那个数据规模量级更大，所以在表示复杂度的时候，不能简单的利用加法法则，省略小的，因此上面的时间复杂度是 <code>O(x+y)</code></p>
<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><blockquote>
<p>空间复杂度全称是渐进空间复杂度，表示算法的存储空间与数据规模之间的增长关系</p>
</blockquote>
<p>空间，讲究的是占用内存的多少</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const func = (n) =&gt; &#123;</span><br><span class="line">	const arr = []</span><br><span class="line">	for(let i = 0; i&lt;n; i++) &#123;</span><br><span class="line">		arr.push(i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>for</code> 循环中，我们申请了一个空间存储变量 <code>i</code>，所以，整段代码的空间复杂度就是 <code>O(n)</code>。</p>
<p>我们常见的空间复杂度就是<code>O(1)</code>、<code>O(n)</code>、<code>O(n2 )</code>，像 <code>O(logn)</code>、<code>O(nlogn)</code> 这样的对数阶复杂度平时都用不到。</p>
<h2 id="浅析最好、最坏、平均、均摊时间复杂度"><a href="#浅析最好、最坏、平均、均摊时间复杂度" class="headerlink" title="浅析最好、最坏、平均、均摊时间复杂度"></a>浅析最好、最坏、平均、均摊时间复杂度</h2><h3 id="最好、最坏情况时间复杂度"><a href="#最好、最坏情况时间复杂度" class="headerlink" title="最好、最坏情况时间复杂度"></a>最好、最坏情况时间复杂度</h3><p>一段代码中通过条件语句可以控制它的执行逻辑，这也产生了不同的复杂度，我们把最理想的情况称为最好情况时间复杂度，最不理想的情况称为最差时间复杂度。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const func = (arr) =&gt; &#123;</span><br><span class="line">	for(let i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">		if (arr.includes(i)) &#123;</span><br><span class="line">			break</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码中，如果数组中包含长度以内的数字，它就会提前返回，否则，就会循环数组长度次，因此最好的时间复杂度，就是 <code>O(1)</code> 否则就是 <code>O(n)</code></p>
<h3 id="平均时间复杂度"><a href="#平均时间复杂度" class="headerlink" title="平均时间复杂度"></a>平均时间复杂度</h3><p>用代码在所有情况下执行的次数的加权平均值表示。</p>
<h3 id="均摊时间复杂度"><a href="#均摊时间复杂度" class="headerlink" title="均摊时间复杂度"></a>均摊时间复杂度</h3><p>均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好情况时间复杂度。</p>
<p>在代码执行的所有复杂度情况中绝大部分是低级别的复杂度，个别情况是高级别复杂度且发生具有时序关系时，可以将个别高级别复杂度均摊到低级别复杂度上。基本上均摊结果就等于低级别复杂度。</p>
<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q &amp; A"></a>Q &amp; A</h2><ul>
<li>什么是复杂度分析？<ul>
<li>数据结构和算法解决是“如何让计算机更快时间、更省空间的解决问题”。</li>
<li>因此需从执行时间和占用空间两个维度来评估数据结构和算法的性能。</li>
<li>分别用时间复杂度和空间复杂度两个概念来描述性能问题，二者统称为复杂度。</li>
<li>复杂度描述的是算法执行时间（或占用空间）与数据规模的增长关系。</li>
</ul>
</li>
<li>复杂度分析法则<ul>
<li>单段代码看高频：比如循环。</li>
<li>多段代码取最大：比如一段代码中有单循环和多重循环，那么取多重循环的复杂度。</li>
<li>嵌套代码求乘积：比如递归、多重循环等</li>
<li>多个规模求加法：比如方法有两个参数控制两个循环的次数，那么这时就取二者复杂度相加。</li>
</ul>
</li>
<li>常用的复杂度级别？<ul>
<li>多项式阶：随着数据规模的增长，算法的执行时间和空间占用，按照多项式的比例增长。包括，O(1)（常数阶）、O(logn)（对数阶）、O(n)（线性阶）、O(nlogn)（线性对数阶）、O(n^2)（平方阶）、O(n^3)（立方阶）</li>
<li>非多项式阶：随着数据规模的增长，算法的执行时间和空间占用暴增，这类算法性能极差。包括，O(2^n)（指数阶）、O(n!)（阶乘阶）</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
